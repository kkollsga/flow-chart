<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Diagram Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <style>
        /* --- Base Setup --- */
        html { height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

        /* --- SVG Connection Styles --- */
        .connection-path { 
            stroke-width: 2; 
            fill: none; 
            cursor: pointer; 
            transition: stroke 0.2s ease, stroke-width 0.2s ease, opacity 0.2s ease; 
        }
        .connection-path:hover { 
            opacity: 0.85; 
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.15));
        }
        
        /* Pattern styles */
        .connection-pattern-normal { stroke-dasharray: none; }
        .connection-pattern-dashed { stroke-dasharray: 10, 5; }
        .connection-pattern-dotted { stroke-dasharray: 2, 4; }
        
        /* Thickness styles */
        .connection-thickness-thin { stroke-width: 1; }
        .connection-thickness-normal { stroke-width: 2; }
        .connection-thickness-bold { stroke-width: 4; }

        /* --- Arrow hotspot styles --- */
        .arrow-hotspot {
            fill: transparent;
            stroke: transparent;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        .arrow-hotspot:hover {
            fill: rgba(0, 0, 0, 0.05);
        }

        /* --- Custom box styles --- */
        .box-default {
            border: 1.5px solid #4b5563;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            transform: translateY(0);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        
        .box-default:hover {
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        /* --- Markdown styling (single line) --- */
        .markdown-content { font-size: 14px; line-height: 1.5; word-wrap: break-word; }
        .markdown-content h1 { font-size: 1.5em; font-weight: bold; margin-top: 0.5em; margin-bottom: 0.3em; }
        .markdown-content h2 { font-size: 1.3em; font-weight: bold; margin-top: 0.4em; margin-bottom: 0.2em; }
        .markdown-content h3 { font-size: 1.1em; font-weight: bold; margin-top: 0.3em; margin-bottom: 0.1em; }
        .markdown-content p { margin-bottom: 0.5em; }
        .markdown-content ul, .markdown-content ol { padding-left: 1.5em; margin-bottom: 0.5em; }
        .markdown-content code { background-color: #f3f4f6; padding: 0.1em 0.2em; border-radius: 0.2em; font-family: monospace; }
        .markdown-content hr { margin: 0.5em 0; border: none; border-top: 1px solid #d1d5db; }
        .markdown-content a { color: #8b5cf6; text-decoration: underline; }
        
        /* --- Textarea styling --- */
        .edit-textarea { width: 100%; height: 100%; box-sizing: border-box; padding: 0.5rem; border: none; font-family: inherit; font-size: 14px; line-height: 1.5; resize: none; overflow: auto; background-color: transparent; }
        .edit-textarea:focus { outline: none; }
        
        /* --- Transitions and Animations --- */
        .box-transition { transition: width 0.2s ease, height 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; }
        #preview-connection { stroke-dasharray: 5, 5; animation: dash 15s linear infinite; stroke: #4b5563; }
        @keyframes dash { to { stroke-dashoffset: -1000; } }
        
        /* --- Help button --- */
        .help-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            background: #6b7280;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.6;
            transition: opacity 0.2s ease;
            z-index: 50;
        }
        .help-button:hover {
            opacity: 1;
        }
        .help-tooltip {
            position: fixed;
            bottom: 40px;
            right: 10px;
            background: white;
            color: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 220px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 51;
            display: none;
        }
        
        /* --- Keyboard hint overlay --- */
        .keys-hint {
            position: fixed;
            left: 10px;
            bottom: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            color: #4b5563;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 40;
        }
    </style>
</head>
<body class="h-screen w-screen m-0 p-0 overflow-hidden bg-gray-100">
    <div id="canvas" class="relative w-full h-full cursor-default overflow-hidden">
        <svg id="connections" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10">
             <defs>
                 <marker id="arrowhead-end" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                     <polygon points="0 0, 10 3.5, 0 7" fill="#4b5563"/>
                 </marker>
                 <marker id="arrowhead-start" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                     <polygon points="10 0, 0 3.5, 10 7" fill="#4b5563"/>
                 </marker>
             </defs>
            <path id="preview-connection" stroke="#4b5563" stroke-width="2" fill="none" marker-end="url(#arrowhead-end)" opacity="0.5" display="none" stroke-dasharray="5, 5"/>
        </svg>
        <div id="box-container" class="absolute top-0 left-0 w-full h-full z-20 pointer-events-none"></div>
        <div id="helper-text" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-500 text-lg text-center pointer-events-none select-none z-0">
             Double click anywhere to add a box<br>
             <span class="text-sm">Use Markdown in boxes for rich formatting</span>
         </div>
    </div>
    <div class="keys-hint">
        Hover + <kbd>c</kbd>: change color | 
        Box: <kbd>s</kbd>: change width | 
        <kbd>Delete</kbd>: remove
    </div>

<script>
// --- Constants ---
const INITIAL_BOX_WIDTH = 200;
const INITIAL_BOX_HEIGHT = 80;
const LINE_HEIGHT = 23; // Height per line in pixels
const PADDING_HEIGHT = 30; // Additional padding for box height

// Width type constants
const WIDTH_TYPES = { SMALL: 'small', MEDIUM: 'medium', LARGE: 'large' };
const WIDTH_TYPE_VALUES = { [WIDTH_TYPES.SMALL]: 200, [WIDTH_TYPES.MEDIUM]: 350, [WIDTH_TYPES.LARGE]: 500 };

// Separated connection style constants
const CONNECTION_PATTERNS = {
    NORMAL: 'normal',
    DASHED: 'dashed',
    DOTTED: 'dotted'
};

const CONNECTION_THICKNESSES = {
    THIN: 'thin',
    NORMAL: 'normal',
    BOLD: 'bold'
};

// Color theme configuration - easy to add/modify themes
const COLOR_THEMES = {
    // Each theme has a unique key and defines background, border, and text colors
    default: {
        name: 'Default',
        bg: 'bg-white',
        border: 'border-gray-500',
        text: 'text-gray-900',
        stroke: '#4b5563' // Added stroke color for connections
    },
    red: {
        name: 'Red',
        bg: 'bg-red-100',
        border: 'border-red-500',
        text: 'text-red-900',
        stroke: '#ef4444'
    },
    green: {
        name: 'Green',
        bg: 'bg-green-100',
        border: 'border-green-500',
        text: 'text-green-900',
        stroke: '#10b981'
    },
    purple: {
        name: 'Purple',
        bg: 'bg-purple-100',
        border: 'border-purple-500',
        text: 'text-purple-900',
        stroke: '#8b5cf6'
    },
    blue: {
        name: 'Blue',
        bg: 'bg-blue-100',
        border: 'border-blue-500',
        text: 'text-blue-900',
        stroke: '#3b82f6'
    },
    grey: {
        name: 'Grey',
        bg: 'bg-gray-200',
        border: 'border-black',
        text: 'text-gray-900',
        stroke: '#111827'
    },
    yellow: {
        name: 'Yellow',
        bg: 'bg-yellow-100',
        border: 'border-yellow-500',
        text: 'text-yellow-900',
        stroke: '#f59e0b'
    }
};

// Get all theme keys for cycling
const THEME_KEYS = Object.keys(COLOR_THEMES);

// Define base classes for reuse in JS - using Tailwind utility classes
const BASE_BOX_CLASSES = 'absolute rounded-lg box-default bg-white cursor-move no-select py-2 px-3 pointer-events-auto overflow-hidden box-transition';

// Simple fallback markdown renderer
function simpleMarkdownParser(text) { if (!text) return ''; return text.replace(/\n/g, '<br>').replace(/### (.*?)(<br>|$)/g, '<h3>$1</h3>').replace(/## (.*?)(<br>|$)/g, '<h2>$1</h2>').replace(/# (.*?)(<br>|$)/g, '<h1>$1</h1>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/`(.*?)`/g, '<code>$1</code>').replace(/(<br>|^)- (.*?)(?=<br>|$)/g, '$1<ul><li>$2</li></ul>'); }

// Helper to safely remove CSS classes
function safeRemoveClass(element, className) {
    if (element && className && className.trim() !== '') {
        element.classList.remove(className);
    }
}

// --- Box Class ---
class Box {
    constructor(boxData, manager) {
        this.data = boxData;
        if (!this.data.widthType) { this.data.widthType = WIDTH_TYPES.MEDIUM; }
        if (!this.data.markdown) { this.data.markdown = '# New Box\nUse **markdown** to format'; }
        if (!this.data.themeKey) { this.data.themeKey = 'default'; }
        this.manager = manager;
        this.isEditing = false;
        this.element = this.createElement();
        this.contentDiv = this.element.firstChild;
        this.textarea = null;
        this.updateElementPosition();
        this.applyColorTheme();
        this.renderMarkdown();
        this.setupEventListeners();
    }

    createElement() { 
        const div = document.createElement('div'); 
        div.className = BASE_BOX_CLASSES; 
        div.dataset.id = this.data.id; 
        div.dataset.type = 'box';
        const contentDiv = document.createElement('div'); 
        contentDiv.className = 'markdown-content relative w-full h-full'; 
        div.appendChild(contentDiv); 
        return div; 
    }
    
    setupEventListeners() {
        let isDragging = false;
        
        this.element.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.element.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.element.addEventListener('mousedown', (e) => { 
            isDragging = false; 
            // Start dragging on mousedown
            if (e.button === 0 && !this.isEditing) {
                this.manager.startDragging(this, e);
            } else if (e.button === 2) {
                // Right mouse button down - start connection or change width
                this.manager.handleBoxRightMouseDown(e, this);
            }
        });
        
        this.element.addEventListener('mousemove', () => { 
            if (this.manager.draggingBox === this) { 
                isDragging = true; 
            } 
        });
        
        this.element.addEventListener('dblclick', (e) => { 
            e.stopPropagation(); 
            if (!this.isEditing) { 
                this.startEditing(); 
            } 
        });
        
        this.element.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            return false; 
        });
    }

    // Updates the element's CSS position
    updateElementPosition() {
        const x = this.data.cx - this.data.width / 2;
        const y = this.data.cy - this.data.height / 2;
        this.element.style.left = `${Math.round(x)}px`;
        this.element.style.top = `${Math.round(y)}px`;
        this.element.style.width = `${this.data.width}px`;
        this.element.style.height = `${this.data.height}px`;
    }

    // Updates position using center coordinates - for dragging
    setCenterPosition(cx, cy) { this.data.cx = cx; this.data.cy = cy; this.updateElementPosition(); }
    
    // Apply color theme to the box
    applyColorTheme() {
        // Get the theme object (with fallback to default if not found)
        const theme = COLOR_THEMES[this.data.themeKey] || COLOR_THEMES.default;
        
        // Remove all possible theme background classes
        THEME_KEYS.forEach(key => {
            const themeToRemove = COLOR_THEMES[key];
            if (themeToRemove) {
                safeRemoveClass(this.element, themeToRemove.bg);
                safeRemoveClass(this.element, themeToRemove.border);
                safeRemoveClass(this.contentDiv, themeToRemove.text);
            }
        });
        
        // Add new theme classes
        if (theme.bg) this.element.classList.add(theme.bg);
        if (theme.border) this.element.classList.add(theme.border);
        if (theme.text) this.contentDiv.classList.add(theme.text);
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyColorTheme();
    }

    // Toggle between width types
    toggleWidthType() {
        const types = Object.values(WIDTH_TYPES);
        const currentIndex = types.indexOf(this.data.widthType);
        const nextIndex = (currentIndex + 1) % types.length;
        this.data.widthType = types[nextIndex];
        
        // Set the new width directly
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        this.data.width = width;
        
        // Update size based on current mode
        if (this.isEditing) {
            this.updateEditModeSize();
        } else {
            this.renderMarkdown();
        }
        
        this.manager.updateConnectionsForBox(this);
    }

    // Renders markdown content to HTML and calculates size
    renderMarkdown() {
        if (!this.data.markdown) return;
        
        try {
            // Use marked.js or fallback
            this.contentDiv.innerHTML = typeof marked !== 'undefined' && typeof marked.parse === 'function' 
                ? marked.parse(this.data.markdown) 
                : simpleMarkdownParser(this.data.markdown);
        } catch (e) {
            console.error('Error parsing markdown:', e);
            this.contentDiv.innerHTML = simpleMarkdownParser(this.data.markdown);
        }
        
        // Update size after rendering
        this.calculateRenderedSize();
    }

    // Calculate size with fixed width based on type
    calculateRenderedSize() {
        // Clone for measurement
        const clone = this.element.cloneNode(true);
        document.body.appendChild(clone);
        
        // Reset styles for measurement
        clone.style.position = 'absolute';
        clone.style.visibility = 'hidden';
        clone.style.left = '-9999px';
        clone.style.top = '-9999px';
        clone.style.height = 'auto';
        clone.style.maxWidth = 'none';
        clone.style.transition = 'none';
        
        // Use fixed width from width type directly
        const fixedWidth = WIDTH_TYPE_VALUES[this.data.widthType];
        clone.style.width = `${fixedWidth}px`;
        
        // Force reflow and measure height with the fixed width
        clone.offsetHeight;
        const newHeight = Math.max(clone.offsetHeight, 50);
        
        // Clean up
        document.body.removeChild(clone);
        
        // Update size
        this.data.width = fixedWidth;
        this.data.height = newHeight;
        this.updateElementPosition();
        
        return { width: fixedWidth, height: newHeight };
    }

    // Calculate box height based on line count
    calculateHeightFromLineCount() {
        if (!this.isEditing || !this.textarea) return 50;
        
        const lineCount = this.textarea.value.split('\n').length;
        return PADDING_HEIGHT + (lineCount * LINE_HEIGHT);
    }

    // Updates box size based on text content during editing
    updateEditModeSize() {
        if (!this.isEditing || !this.textarea) return;
        
        // Always use fixed width from width type
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Calculate height based on line count
        const height = this.calculateHeightFromLineCount();
        
        // Update size
        this.data.width = width;
        this.data.height = height;
        this.updateElementPosition();
        this.manager.updateConnectionsForBox(this);
    }

    // Switches to editing mode
    startEditing() {
        if (this.isEditing) return;
        this.isEditing = true;
        this.element.classList.remove('cursor-move');
        
        // Clear and prepare container
        this.contentDiv.innerHTML = '';
        
        // Create textarea
        this.textarea = document.createElement('textarea');
        this.textarea.className = 'edit-textarea';
        this.textarea.value = this.data.markdown || '';
        this.textarea.placeholder = 'Add markdown content...';
        
        // Set fixed width from width type
        this.data.width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Add event listeners
        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') { 
                e.preventDefault(); 
                this.cancelEdit(); 
            } else if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.commitEdit();
            }
            
            // Update size on next tick
            setTimeout(() => this.updateEditModeSize(), 0);
        });
        
        this.textarea.addEventListener('input', () => {
            this.updateEditModeSize();
        });
        
        // Prevent event propagation
        this.textarea.addEventListener('mousedown', e => e.stopPropagation());
        this.textarea.addEventListener('contextmenu', e => e.stopPropagation());
        this.textarea.addEventListener('dblclick', e => e.stopPropagation());
        this.textarea.addEventListener('click', e => e.stopPropagation());

        this.contentDiv.appendChild(this.textarea);

        // Focus and select text
        requestAnimationFrame(() => {
            this.textarea.focus();
            if (this.textarea.value) this.textarea.select();
            this.updateEditModeSize();
        });
    }

    commitEdit() { if (!this.isEditing || !this.textarea) return false; const markdown = this.textarea.value.trim(); if (!markdown) { this.cancelEdit(); return false; } this.data.markdown = markdown; this.cleanupEdit(); this.renderMarkdown(); this.manager.updateConnectionsForBox(this); console.log('Box Edit Committed:', structuredClone(this.data)); return true; }
    cancelEdit() { if (!this.isEditing) return; if (!this.data.markdown) { console.log('Box Edit Cancelled & Deleted:', this.data.id); this.manager.deleteBox(this); return; } this.cleanupEdit(); this.renderMarkdown(); console.log('Box Edit Cancelled:', structuredClone(this.data)); }
    cleanupEdit() { this.isEditing = false; if (this.textarea && this.textarea.parentNode) { this.textarea.remove(); } this.textarea = null; this.element.classList.add('cursor-move'); }
    getBounds() { const x = this.data.cx - this.data.width / 2; const y = this.data.cy - this.data.height / 2; return { left: x, right: x + this.data.width, top: y, bottom: y + this.data.height, width: this.data.width, height: this.data.height }; }
}

// --- Connection Class ---
class Connection {
    constructor(connectionData, startBox, endBox, manager) { 
        this.data = connectionData; 
        // Initialize data if needed
        if (!this.data.themeKey) this.data.themeKey = 'default';
        if (!this.data.pattern) this.data.pattern = CONNECTION_PATTERNS.NORMAL;
        if (!this.data.thickness) this.data.thickness = CONNECTION_THICKNESSES.NORMAL;
        if (this.data.bidirectional === undefined) this.data.bidirectional = false;
        
        this.startBox = startBox; 
        this.endBox = endBox; 
        this.manager = manager; 
        
        // Create main connection path
        this.element = this.createElement();
        
        // Create invisible hotspots for better arrow interaction
        this.startHotspot = null;
        this.endHotspot = null;
        this.createHotspots();
        
        this.update(); 
        this.setupEventListeners(); 
    }
    
    createElement() { 
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
        p.setAttribute('class', 'connection-path pointer-events-auto'); 
        p.dataset.id = this.data.id; 
        p.dataset.type = 'connection';
        
        // Set markers based on if bidirectional
        if (this.data.bidirectional) {
            p.setAttribute('marker-start', 'url(#arrowhead-start)');
        }
        p.setAttribute('marker-end', 'url(#arrowhead-end)');
        
        return p; 
    }
    
    // Create invisible hotspots for better arrow interaction
    createHotspots() {
        // Create start hotspot
        this.startHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.startHotspot.setAttribute('class', 'arrow-hotspot');
        this.startHotspot.setAttribute('r', '12');
        this.startHotspot.dataset.connection = this.data.id;
        this.startHotspot.dataset.end = 'start';
        this.manager.svg.appendChild(this.startHotspot);
        
        // Create end hotspot
        this.endHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.endHotspot.setAttribute('class', 'arrow-hotspot');
        this.endHotspot.setAttribute('r', '12');
        this.endHotspot.dataset.connection = this.data.id;
        this.endHotspot.dataset.end = 'end';
        this.manager.svg.appendChild(this.endHotspot);
        
        // Add event listeners to hotspots
        this.startHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.startHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.startHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
        });
        
        this.endHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.endHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.endHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
        });
    }
    
    // Toggle bidirectionality of the connection
    toggleBidirectional() {
        this.data.bidirectional = !this.data.bidirectional;
        
        if (this.data.bidirectional) {
            this.element.setAttribute('marker-start', 'url(#arrowhead-start)');
        } else {
            this.element.removeAttribute('marker-start');
        }
        
        // Update the connection
        this.update();
    }
    
    setupEventListeners() { 
        this.element.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.element.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        // Add left-click event to toggle line pattern
        this.element.addEventListener('click', (e) => {
            e.stopPropagation();
            this.cyclePattern();
        });
        
        // Add right-click event to toggle thickness
        this.element.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.cycleThickness();
        });
    }
    
    // Apply the current theme to the connection
    applyTheme() {
        const theme = COLOR_THEMES[this.data.themeKey] || COLOR_THEMES.default;
        if (this.element) {
            this.element.setAttribute('stroke', theme.stroke);
        }
        
        // Update arrowhead - safely
        this.updateArrowheadColor(theme.stroke);
    }
    
    // Update arrowhead color safely
    updateArrowheadColor(color) {
        // Update start arrowhead
        try {
            const startArrowhead = document.getElementById('arrowhead-start');
            if (startArrowhead) {
                const polygon = startArrowhead.querySelector('polygon');
                if (polygon) {
                    polygon.setAttribute('fill', color);
                }
            }
        } catch (e) {
            console.warn("Could not update start arrowhead color", e);
        }
        
        // Update end arrowhead
        try {
            const endArrowhead = document.getElementById('arrowhead-end');
            if (endArrowhead) {
                const polygon = endArrowhead.querySelector('polygon');
                if (polygon) {
                    polygon.setAttribute('fill', color);
                }
            }
        } catch (e) {
            console.warn("Could not update end arrowhead color", e);
        }
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyTheme();
    }
    
    // Apply current pattern to the connection
    applyPattern() {
        // Remove all pattern classes first
        this.element.classList.remove(
            'connection-pattern-normal',
            'connection-pattern-dashed', 
            'connection-pattern-dotted'
        );
        
        // Add current pattern class
        this.element.classList.add(`connection-pattern-${this.data.pattern}`);
    }
    
    // Apply current thickness to the connection
    applyThickness() {
        // Remove all thickness classes first
        this.element.classList.remove(
            'connection-thickness-thin',
            'connection-thickness-normal',
            'connection-thickness-bold'
        );
        
        // Add current thickness class
        this.element.classList.add(`connection-thickness-${this.data.thickness}`);
    }
    
    // Cycle to the next line pattern (left click)
    cyclePattern() {
        const patterns = Object.values(CONNECTION_PATTERNS);
        const currentIndex = patterns.indexOf(this.data.pattern);
        const nextIndex = (currentIndex + 1) % patterns.length;
        this.data.pattern = patterns[nextIndex];
        this.applyPattern();
    }
    
    // Cycle to the next thickness (right click)
    cycleThickness() {
        const thicknesses = Object.values(CONNECTION_THICKNESSES);
        const currentIndex = thicknesses.indexOf(this.data.thickness);
        const nextIndex = (currentIndex + 1) % thicknesses.length;
        this.data.thickness = thicknesses[nextIndex];
        this.applyThickness();
    }
    
    calculateIntersection(startPt, endPt, targetBox) { const bounds = targetBox.getBounds(); const dx = endPt.x - startPt.x; const dy = endPt.y - startPt.y; if (bounds.width <= 0 || bounds.height <= 0 || (dx === 0 && dy === 0)) { return { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; } let t = Infinity; let intersection = null; const tol = 0.1; const checkT = (newT, x, y, b) => { if (newT >= 0 && newT < t && x >= b.left - tol && x <= b.right + tol && y >= b.top - tol && y <= b.bottom + tol) { t = newT; return { x, y }; } return null; }; if (dx !== 0) { let tL = (bounds.left - startPt.x) / dx; let yL = startPt.y + tL * dy; intersection = checkT(tL, bounds.left, yL, bounds) || intersection; let tR = (bounds.right - startPt.x) / dx; let yR = startPt.y + tR * dy; intersection = checkT(tR, bounds.right, yR, bounds) || intersection; } if (dy !== 0) { let tT = (bounds.top - startPt.y) / dy; let xT = startPt.x + tT * dx; intersection = checkT(tT, xT, bounds.top, bounds) || intersection; let tB = (bounds.bottom - startPt.y) / dy; let xB = startPt.x + tB * dx; intersection = checkT(tB, xB, bounds.bottom, bounds) || intersection; } if (intersection) { const len = Math.sqrt(dx*dx + dy*dy) || 1; const ux = dx / len; const uy = dy / len; intersection.x -= ux * 2; intersection.y -= uy * 2; } return intersection || { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; }
    
    update() { 
        if (!this.startBox || !this.endBox) return; 
        const sC = { x: this.startBox.data.cx, y: this.startBox.data.cy }; 
        const eC = { x: this.endBox.data.cx, y: this.endBox.data.cy }; 
        const eP = this.calculateIntersection(sC, eC, this.endBox); 
        const sP = this.calculateIntersection(eP, sC, this.startBox); 
        
        if (!isNaN(sP.x) && !isNaN(eP.x)) { 
            this.element.setAttribute('d', `M ${sP.x} ${sP.y} L ${eP.x} ${eP.y}`); 
            
            // Update hotspot positions
            this.updateHotspotPositions(sP, eP);
        } else { 
            this.element.setAttribute('d', ''); 
        } 
        
        this.updateElementStyle(); 
    }
    
    // Update hotspot positions
    updateHotspotPositions(startPoint, endPoint) {
        // Calculate vector
        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len === 0) return;
        
        const ux = dx / len;
        const uy = dy / len;
        
        // Position hotspots
        if (this.startHotspot) {
            const startHotspotX = startPoint.x + ux * 12;
            const startHotspotY = startPoint.y + uy * 12;
            this.startHotspot.setAttribute('cx', startHotspotX);
            this.startHotspot.setAttribute('cy', startHotspotY);
        }
        
        if (this.endHotspot) {
            const endHotspotX = endPoint.x - ux * 12;
            const endHotspotY = endPoint.y - uy * 12;
            this.endHotspot.setAttribute('cx', endHotspotX);
            this.endHotspot.setAttribute('cy', endHotspotY);
        }
    }
    
    updateElementStyle() { 
        // Apply theme, pattern and thickness
        this.applyTheme();
        this.applyPattern();
        this.applyThickness();
    }
    
    // Clean up the connection by removing hotspot elements
    cleanup() {
        if (this.startHotspot) {
            this.startHotspot.remove();
            this.startHotspot = null;
        }
        
        if (this.endHotspot) {
            this.endHotspot.remove();
            this.endHotspot = null;
        }
    }
}

// --- Diagram Manager Class ---
class DiagramManager {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.svg = document.getElementById('connections');
        this.boxContainer = document.getElementById('box-container');
        this.helperText = document.getElementById('helper-text');
        this.previewPath = document.getElementById('preview-connection');
        
        this.boxes = new Map();
        this.connections = new Map();
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        this.draggingBox = null;
        this.dragStartPos = { x: 0, y: 0 };
        this.dragBoxStartCenter = { cx: 0, cy: 0 };
        this.connectionStartBox = null;
        this.hoveredElement = null; // Track currently hovered element
        
        this.setupEventListeners();
        this.updateHelperText();
        this.setupHelpButton();
    }
    
    setupEventListeners() { 
        this.canvas.addEventListener('dblclick', this.handleCanvasDoubleClick.bind(this)); 
        this.canvas.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this)); 
        document.addEventListener('mousemove', this.handleMouseMove.bind(this)); 
        document.addEventListener('mouseup', this.handleMouseUp.bind(this)); 
        document.addEventListener('keydown', this.handleKeyDown.bind(this)); 
        document.addEventListener('click', this.handleGlobalClick.bind(this), true); 
        document.addEventListener('contextmenu', e => e.preventDefault()); 
        document.addEventListener('mouseleave', () => { 
            if (this.connectionStartBox) { 
                this.previewPath.setAttribute('display', 'none'); 
                this.connectionStartBox = null; 
            } 
        }); 
    }
    
    setupHelpButton() {
        const helpButton = document.createElement('div');
        helpButton.className = 'help-button';
        helpButton.textContent = '?';
        helpButton.title = 'Help';
        document.body.appendChild(helpButton);
        
        const helpTooltip = document.createElement('div');
        helpTooltip.className = 'help-tooltip';
        helpTooltip.innerHTML = `
            Double click: edit content<br>
            Right drag: create connection<br>
            Left click line: change style<br>
            Right click line: change thickness<br>
            Hover + c: change color<br>
            Box + s: change width<br>
            Click arrow: bidirectional<br>
            Delete: remove hovered item
        `;
        document.body.appendChild(helpTooltip);
        
        helpButton.addEventListener('mouseenter', () => {
            helpTooltip.style.display = 'block';
        });
        
        helpButton.addEventListener('mouseleave', () => {
            helpTooltip.style.display = 'none';
        });
    }
    
    handleCanvasDoubleClick(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            const rect = this.boxContainer.getBoundingClientRect(); 
            const cx = e.clientX - rect.left; 
            const cy = e.clientY - rect.top; 
            if (cx >= 0 && cy >= 0 && cx <= rect.width && cy <= rect.height) { 
                this.createBox(cx, cy); 
            } 
        } 
    }
    
    handleCanvasMouseDown(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            // No-op for now - we don't have selection state anymore
        } 
    }
    
    startDragging(box, e) {
        if (!box || box.isEditing) return;
        
        this.draggingBox = box;
        this.dragStartPos = { x: e.clientX, y: e.clientY };
        this.dragBoxStartCenter = { cx: box.data.cx, cy: box.data.cy };
    }
    
    handleBoxRightMouseDown(e, box) {
        if (!box || box.isEditing) return;
        
        e.preventDefault();
        
        // Right-click for starting connection
        this.connectionStartBox = box;
        const sC = { cx: box.data.cx, cy: box.data.cy };
        const r = this.svg.getBoundingClientRect();
        const mX = e.clientX - r.left;
        const mY = e.clientY - r.top;
        this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`);
        this.previewPath.setAttribute('display', 'block');
        
        // Also toggle width if mouse up on the same box
        this.rightClickBox = box;
    }
    
    handleMouseMove(e) { 
        if (this.draggingBox) { 
            const dx = e.clientX - this.dragStartPos.x; 
            const dy = e.clientY - this.dragStartPos.y; 
            const nCx = this.dragBoxStartCenter.cx + dx; 
            const nCy = this.dragBoxStartCenter.cy + dy; 
            this.draggingBox.setCenterPosition(nCx, nCy); 
            this.updateConnectionsForBox(this.draggingBox); 
        } else if (this.connectionStartBox) { 
            const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
            const r = this.svg.getBoundingClientRect(); 
            const mX = e.clientX - r.left; 
            const mY = e.clientY - r.top; 
            this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
        } 
    }
    
    handleMouseUp(e) { 
        if (this.draggingBox) { 
            this.draggingBox = null; 
        } else if (this.connectionStartBox && e.button === 2) { 
            e.preventDefault(); 
            this.previewPath.setAttribute('display', 'none'); 
            let eTE = document.elementFromPoint(e.clientX, e.clientY); 
            let eBE = eTE?.closest('.box-default'); 
            
            if (eBE) { 
                const eB = this.boxes.get(eBE.dataset.id); 
                if (eB && eB !== this.connectionStartBox) { 
                    // Create or update connection between boxes
                    this.createOrUpdateConnection(this.connectionStartBox, eB); 
                } else if (eB === this.connectionStartBox) {
                    // Change width if right-click and release on the same box
                    eB.toggleWidthType();
                }
            } 
            
            this.connectionStartBox = null; 
            this.rightClickBox = null;
        } 
        
        if (e.button === 0) { 
            this.draggingBox = null; 
        } 
    }
    
    handleGlobalClick(e) { 
        const targetTextarea = e.target.closest('textarea'); 
        
        if (!targetTextarea) { 
            // Check if any box is in edit mode
            let editingBox = false;
            this.boxes.forEach(box => { 
                if (box.isEditing) { 
                    editingBox = true; 
                    box.commitEdit(); 
                } 
            }); 
        } 
    }
    
    handleKeyDown(e) { 
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return; 
        
        // Handle Delete/Backspace for removing hovered element
        if ((e.key === 'Delete' || e.key === 'Backspace') && this.hoveredElement) {
            // Delete the hovered element
            if (this.hoveredElement instanceof Box) {
                this.deleteBox(this.hoveredElement);
            } else if (this.hoveredElement instanceof Connection) {
                this.deleteConnection(this.hoveredElement);
            }
        }
        
        // Handle 'c' key for changing color of hovered element
        if (e.key === 'c' && this.hoveredElement) {
            if (this.hoveredElement instanceof Box || this.hoveredElement instanceof Connection) {
                this.hoveredElement.cycleColorTheme();
            }
        }
        
        // Handle 's' key for changing width of hovered box (NOT connections)
        if (e.key === 's' && this.hoveredElement instanceof Box) {
            this.hoveredElement.toggleWidthType();
        }
    }
    
    createBox(cx, cy) { 
        const id = `box-${this.nextBoxId++}`; 
        const bD = { 
            id: id, 
            cx: cx, 
            cy: cy, 
            width: INITIAL_BOX_WIDTH, 
            height: INITIAL_BOX_HEIGHT, 
            widthType: WIDTH_TYPES.MEDIUM,
            themeKey: 'default',
            markdown: '# Title\nUse **markdown** for formatting'
        }; 
        const b = new Box(bD, this); 
        this.boxContainer.appendChild(b.element); 
        this.boxes.set(id, b); 
        this.updateHelperText(); 
        b.startEditing(); 
        return b; 
    }
    
    // Create a new connection or update existing one to be bidirectional
    createOrUpdateConnection(startBox, endBox) { 
        if (!startBox || !endBox || startBox === endBox) return null; 
        
        // Check if there's already a connection in the opposite direction
        let existingConnection = null;
        this.connections.forEach(conn => {
            if (conn.startBox === endBox && conn.endBox === startBox) {
                existingConnection = conn;
            }
        });
        
        // If there's an existing connection, make it bidirectional
        if (existingConnection) {
            existingConnection.data.bidirectional = true;
            existingConnection.element.setAttribute('marker-start', 'url(#arrowhead-start)');
            // No longer changing the style when making bidirectional
            existingConnection.update();
            return existingConnection;
        }
        
        // Otherwise create a new connection
        const id = `conn-${this.nextConnectionId++}`; 
        const cD = { 
            id: id, 
            startBoxId: startBox.data.id, 
            endBoxId: endBox.data.id,
            themeKey: 'default',
            pattern: CONNECTION_PATTERNS.NORMAL,
            thickness: CONNECTION_THICKNESSES.NORMAL,
            bidirectional: false
        }; 
        const c = new Connection(cD, startBox, endBox, this); 
        this.connections.set(id, c); 
        this.svg.appendChild(c.element); 
        
        // Apply theme after adding to DOM
        c.applyTheme();
        c.applyPattern();
        c.applyThickness();
        
        return c; 
    }
    
    deleteBox(boxInstance) { 
        if (!boxInstance) return; 
        const bId = boxInstance.data.id; 
        const cTR = []; 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) cTR.push(c); 
        }); 
        cTR.forEach(c => this.deleteConnection(c)); 
        boxInstance.element.remove(); 
        this.boxes.delete(bId); 
        this.updateHelperText(); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === boxInstance) {
            this.hoveredElement = null;
        }
    }
    
    deleteConnection(connInstance) { 
        if (!connInstance) return; 
        
        // Clean up hotspot elements
        connInstance.cleanup();
        
        const cId = connInstance.data.id; 
        connInstance.element.remove(); 
        this.connections.delete(cId); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === connInstance) {
            this.hoveredElement = null;
        }
    }
    
    updateConnectionsForBox(boxInstance) { 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) c.update(); 
        }); 
    }
    
    updateHelperText() { 
        this.helperText.style.display = this.boxes.size === 0 ? 'block' : 'none'; 
    }
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    window.diagramManager = new DiagramManager();
});
</script>

</body>
</html>
