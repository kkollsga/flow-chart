<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* --- Dark Mode Variables --- */
        :root {
            --bg-primary: #f3f4f6;
            --bg-secondary: #fff;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --text-muted: rgba(75, 85, 99, 0.4);
            --border-color: #d1d5db;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            --box-shadow-hover: 0 8px 15px rgba(0, 0, 0, 0.12);
            --font-scale: 1; /* Default font scale */
            /* Light mode scrollbar colors */
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-thumb-hover: #a1a1a1;
            /* Table specific variables */
            --table-header-bg: #4b5563;
            --table-header-text: #ffffff;
            --table-row-odd: transparent;
            --table-row-even: rgba(0, 0, 0, 0.04);
            --table-border: var(--border-color);
        }

        .dark-mode {
            --bg-primary: #1f2937;
            --bg-secondary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: rgba(209, 213, 219, 0.4);
            --border-color: #4b5563;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            --box-shadow-hover: 0 8px 15px rgba(0, 0, 0, 0.35);
            /* Dark mode scrollbar colors */
            --scrollbar-track: #2d3748;
            --scrollbar-thumb: #4a5568;
            --scrollbar-thumb-hover: #718096;
            /* Table specific variables */
            --table-header-bg: #6366f1;
            --table-header-text: #ffffff;
            --table-row-odd: transparent;
            --table-row-even: rgba(255, 255, 255, 0.05);
            --table-border: var(--border-color);
        }

        #canvas {
            overflow: visible;
        }
        
        #connections {
            overflow: visible;
        }
        
        #box-container {
            overflow: visible;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: auto;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        /* Scrollbar width */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        /* Scrollbar track */
        ::-webkit-scrollbar-track {
            background-color: var(--scrollbar-track);
            border-radius: 6px;
        }
        
        /* Scrollbar thumb */
        ::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--scrollbar-thumb-hover);
        }
        
        /* Scrollbar corner */
        ::-webkit-scrollbar-corner {
            background-color: var(--scrollbar-track);
        }
        
        /* Firefox scrollbar styling */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }


        /* --- Theme Toggle Icons --- */
        .theme-toggle {
            position: relative;
        }

        .theme-toggle svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Hide both icons initially */
        #sun-icon, #moon-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6);
            display: block; /* Ensure SVGs are always in layout */
        }

        /* Show active icon based on theme */
        body:not(.dark-mode) #sun-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        body.dark-mode #moon-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Hover animations */
        body:not(.dark-mode) .theme-toggle:hover #sun-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6) rotate(45deg);
        }

        body:not(.dark-mode) .theme-toggle:hover #moon-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        body.dark-mode .theme-toggle:hover #moon-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6) rotate(-45deg);
        }

        body.dark-mode .theme-toggle:hover #sun-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Sun icon styles */
        #sun-icon {
            fill: #f59e0b; /* Yellow fill */
            color: #f59e0b;
        }

        /* Moon icon styles */
        #moon-icon {
            fill: #2563eb; /* Dark blue fill */
            color: #2563eb;
        }

        /* --- Project Title --- */
        #project-title {
            color: var(--text-muted);
            font-weight: 300;
            letter-spacing: 0.05em;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* --- Base Setup --- */
        html { height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

        /* --- SVG Connection Styles --- */
        .connection-path { 
            stroke-width: 2; 
            fill: none; 
            cursor: pointer; 
            transition: stroke 0.2s ease, stroke-width 0.2s ease, opacity 0.2s ease;
            pointer-events: none;
        }

        /* Improved hitbox for all connections */
        .connection-hitbox {
            stroke-width: 12; /* Wide hit area for easier interaction */
            stroke: transparent;
            fill: none;
            cursor: pointer;
            pointer-events: stroke;
        }

        .connection-path:hover { 
            opacity: 0.85; 
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.15));
        }

        /* Pattern styles */
        .connection-pattern-normal { stroke-dasharray: none; }
        .connection-pattern-dashed { stroke-dasharray: 10, 5; }
        .connection-pattern-dotted { stroke-dasharray: 2, 4; }

        /* Thickness styles */
        .connection-thickness-thin { stroke-width: 1; }
        .connection-thickness-normal { stroke-width: 2; }
        .connection-thickness-bold { stroke-width: 4; }

        /* --- Arrow hotspot styles --- */
        .arrow-hotspot {
            fill: transparent;
            stroke: transparent;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        .arrow-hotspot:hover {
            fill: rgba(0, 0, 0, 0.05);
        }

        /* --- Custom box styles --- */
        .box-default {
            border: 1.5px solid var(--border-color);
            box-shadow: var(--box-shadow);
            transform: translateY(0);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.3s ease, border-color 0.3s ease;
        }

        .box-default:hover {
            box-shadow: var(--box-shadow-hover);
            transform: translateY(-2px);
        }

        /* --- Markdown styling (enhanced) --- */
        .markdown-content { 
            font-size: calc(14px * var(--font-scale)); 
            line-height: 1.5; 
            word-wrap: break-word; 
            color: var(--text-primary); 
        }
        .markdown-content h1 { 
            font-size: calc(1.5em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.5em; 
            margin-bottom: 0.3em; 
        }
        .markdown-content h2 { 
            font-size: calc(1.3em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.4em; 
            margin-bottom: 0.2em; 
        }
        .markdown-content h3 { 
            font-size: calc(1.1em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.3em; 
            margin-bottom: 0.1em; 
        }
        .markdown-content p { margin-bottom: 0.5em; }
        .markdown-content ul, .markdown-content ol { 
            padding-left: 1.5em; 
            margin-bottom: 0.5em; 
            list-style-position: outside; 
        }
        .markdown-content ul { list-style-type: disc; }
        .markdown-content ol { list-style-type: decimal; }
        .markdown-content li { margin-bottom: 0.2em; }
        .markdown-content li > ul, .markdown-content li > ol { margin-top: 0.2em; }
        .markdown-content code { 
            background-color: rgba(0, 0, 0, 0.05); 
            padding: 0.1em 0.2em; 
            border-radius: 0.2em; 
            font-family: monospace; 
            font-size: calc(0.9em * var(--font-scale));
        }
        .markdown-content hr { margin: 0.5em 0; border: none; border-top: 1px solid var(--border-color); }
        .markdown-content a { color: #8b5cf6; text-decoration: underline; }
        
        /* Table base styling */
        .markdown-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; font-size: calc(0.9em * var(--font-scale)); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); border-radius: 4px; overflow: hidden; }
        .markdown-content table td { border: 1px solid var(--border-color); padding: 0.4em 0.7em; }
        .markdown-content table tr:nth-child(odd) { background-color: transparent; }
        .markdown-content table tr:nth-child(even) { background-color: rgba(0, 0, 0, 0.05); }
        .dark-mode .markdown-content table tr:nth-child(even) { background-color: rgba(255, 255, 255, 0.07); }
        .markdown-content table tr:hover { background-color: rgba(0, 0, 0, 0.08); }
        .dark-mode .markdown-content table tr:hover { background-color: rgba(255, 255, 255, 0.1); }
        .markdown-content table th { border: 1px solid var(--border-color); padding: 0.5em 0.7em; text-align: left; font-weight: bold; }

        /* Theme-specific table header styling for light mode - with softer colors */
        div[data-theme="default"] .markdown-content table th { background-color: #6b7280; color: #ffffff; border-color: #9ca3af; }
        div[data-theme="red"] .markdown-content table th { background-color: #f87171; color: #7f1d1d; border-color: #ef4444; }
        div[data-theme="green"] .markdown-content table th { background-color: #34d399; color: #064e3b; border-color: #10b981; }
        div[data-theme="blue"] .markdown-content table th { background-color: #60a5fa; color: #1e3a8a; border-color: #3b82f6; }
        div[data-theme="purple"] .markdown-content table th { background-color: #a78bfa; color: #4c1d95; border-color: #8b5cf6; }
        div[data-theme="yellow"] .markdown-content table th { background-color: #fbbf24; color: #78350f; border-color: #f59e0b; }
        div[data-theme="grey"] .markdown-content table th { background-color: #4b5563; color: #f9fafb; border-color: #6b7280; }

        /* Theme-specific table header styling for dark mode - with better contrast */
        .dark-mode div[data-theme="default"] .markdown-content table th { background-color: #4b5563; color: #f3f4f6; border-color: #6b7280; }
        .dark-mode div[data-theme="red"] .markdown-content table th { background-color: #b91c1c; color: #fee2e2; border-color: #ef4444; }
        .dark-mode div[data-theme="green"] .markdown-content table th { background-color: #047857; color: #d1fae5; border-color: #10b981; }
        .dark-mode div[data-theme="blue"] .markdown-content table th { background-color: #1d4ed8; color: #dbeafe; border-color: #3b82f6; }
        .dark-mode div[data-theme="purple"] .markdown-content table th { background-color: #6d28d9; color: #ede9fe; border-color: #8b5cf6; }
        .dark-mode div[data-theme="yellow"] .markdown-content table th { background-color: #b45309; color: #fef3c7; border-color: #f59e0b; }
        .dark-mode div[data-theme="grey"] .markdown-content table th { background-color: #1f2937; color: #f9fafb; border-color: #4b5563; }
 
        /* --- Textarea styling --- */
        .edit-textarea { 
            width: 100%; 
            height: 100%; 
            box-sizing: border-box; 
            padding: 0.5rem; 
            border: none; 
            font-family: inherit; 
            font-size: calc(14px * var(--font-scale)); 
            line-height: 1.5; 
            resize: none; 
            overflow: auto; 
            background-color: transparent;
            color: var(--text-primary);
        }
        .edit-textarea:focus { outline: none; }

        /* --- Transitions and Animations --- */
        .box-transition { transition: width 0.2s ease, height 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; }
        #preview-connection { stroke-dasharray: 5, 5; animation: dash 15s linear infinite; stroke: var(--text-secondary); }
        @keyframes dash { to { stroke-dashoffset: -1000; } }
        
        /* Theme-specific box/text classes for light mode */
        .light-default-bg { background-color: #ffffff; }
        .light-default-text { color: #1f2937; }
        .light-default-border { border-color: #6b7280; }

        .light-red-bg { background-color: #fee2e2; }
        .light-red-text { color: #7f1d1d; }
        .light-red-border { border-color: #ef4444; }

        .light-green-bg { background-color: #dcfce7; }
        .light-green-text { color: #14532d; }
        .light-green-border { border-color: #10b981; }

        .light-blue-bg { background-color: #dbeafe; }
        .light-blue-text { color: #1e3a8a; }
        .light-blue-border { border-color: #3b82f6; }

        .light-purple-bg { background-color: #ede9fe; }
        .light-purple-text { color: #5b21b6; }
        .light-purple-border { border-color: #8b5cf6; }

        .light-yellow-bg { background-color: #fef9c3; }
        .light-yellow-text { color: #713f12; }
        .light-yellow-border { border-color: #f59e0b; }

        .light-grey-bg { background-color: #e5e7eb; }
        .light-grey-text { color: #111827; }
        .light-grey-border { border-color: #111827; }

        /* Theme-specific box/text classes for dark mode */
        .dark-default-bg { background-color: #374151; }
        .dark-default-text { color: #f9fafb; }
        .dark-default-border { border-color: #9ca3af; }

        .dark-red-bg { background-color: #7f1d1d; }
        .dark-red-text { color: #fecaca; }
        .dark-red-border { border-color: #ef4444; }

        .dark-green-bg { background-color: #14532d; }
        .dark-green-text { color: #a7f3d0; }
        .dark-green-border { border-color: #10b981; }

        .dark-blue-bg { background-color: #1e3a8a; }
        .dark-blue-text { color: #bfdbfe; }
        .dark-blue-border { border-color: #3b82f6; }

        .dark-purple-bg { background-color: #5b21b6; }
        .dark-purple-text { color: #ddd6fe; }
        .dark-purple-border { border-color: #8b5cf6; }

        .dark-yellow-bg { background-color: #713f12; }
        .dark-yellow-text { color: #fef08a; }
        .dark-yellow-border { border-color: #f59e0b; }

        .dark-grey-bg { background-color: #1f2937; }
        .dark-grey-text { color: #e5e7eb; }
        .dark-grey-border { border-color: #9ca3af; }
    </style>
</head>
<body class="h-screen m-0 p-0">
    <!-- Project title header -->
    <div id="project-title-container" class="fixed top-5 left-0 w-full text-center pointer-events-none z-0">
        <h1 id="project-title" class="text-3xl tracking-wide"></h1>
    </div>

    <div id="canvas" class="relative w-full cursor-default">
        <svg id="connections" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10" style="overflow: visible;">
             <defs>
                 <marker id="arrowhead-end" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                     <polygon points="0 0, 10 3.5, 0 7" fill="currentColor"/>
                 </marker>
                 <marker id="arrowhead-start" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                     <polygon points="10 0, 0 3.5, 10 7" fill="currentColor"/>
                 </marker>
             </defs>
            <path id="preview-connection" stroke="currentColor" stroke-width="2" fill="none" marker-end="url(#arrowhead-end)" opacity="0.5" display="none" stroke-dasharray="5, 5"/>
        </svg>
        <div id="box-container" class="absolute top-0 left-0 w-full z-20 pointer-events-none"></div>
        <div id="helper-text" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-500 text-lg text-center pointer-events-none select-none z-0">
             Double click anywhere to add a box<br>
             <span class="text-sm">Use Markdown in boxes for formatting</span>
         </div>
    </div>
    
    <!-- Settings Menu (right-click style) -->
    <div id="settings-menu" class="fixed bottom-12 right-2 w-72 rounded-lg shadow-lg z-50 overflow-hidden transition-all duration-200 max-h-[80vh] flex flex-col hidden opacity-0 transform translate-y-2 pointer-events-none" style="background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: 0 5px 15px var(--shadow-color);">
        <div class="px-4 py-3 border-b border-solid" style="border-color: var(--border-color);">
            <div class="flex justify-between items-center">
                <h3 class="text-base font-semibold m-0">Projects</h3>
                <button id="add-project-toggle" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>
        
        <div class="px-4 py-3 overflow-y-auto max-h-[50vh]">
            <!-- New project form (hidden by default) -->
            <div id="new-project-form" class="mb-3 hidden overflow-hidden transition-all duration-200 max-h-0">
                <div class="flex items-center mb-2">
                    <input type="text" id="project-name" class="flex-1 p-2 rounded border border-solid mr-2" placeholder="Enter project name"
                        style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                    <button id="commit-new-project" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600">
                        <i class="fas fa-check"></i>
                    </button>
                    <button id="cancel-new-project" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600 ml-1">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            
            <div id="project-list" class="space-y-2">
                <!-- Projects will be loaded here -->
                <div class="text-center text-gray-500 py-3" id="no-projects-message">No projects yet</div>
            </div>
        </div>
        
        <div class="h-px w-full" style="background-color: var(--border-color);"></div>
        
        <div class="px-4 py-3 border-t border-solid" style="border-color: var(--border-color);">
            <div>
                <label class="block mb-1 font-medium" for="text-scale">Text Size</label>
                <div class="flex items-center">
                    <input type="range" id="text-scale" class="w-full mr-2" min="0.8" max="1.5" step="0.1" value="1">
                    <span class="inline-block font-medium" id="text-scale-value">1.0x</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme toggle button with improved icons -->
    <div class="theme-toggle fixed bottom-2.5 right-12 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" id="theme-toggle" title="Toggle dark/light mode">
        <!-- Sun icon (filled, yellow) -->
        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        
        <!-- Moon icon (filled, dark blue) -->
        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
    </div>
    
    <!-- Settings button (gear icon) -->
    <div class="fixed bottom-2.5 right-2.5 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" id="settings-button" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" title="Projects & Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>

<script>
// --- Constants ---
const INITIAL_BOX_WIDTH = 200;
const INITIAL_BOX_HEIGHT = 80;
const LINE_HEIGHT = 23; // Height per line in pixels
const PADDING_HEIGHT = 30; // Additional padding for box height

// Width type constants
const WIDTH_TYPES = { SMALL: 'small', MEDIUM: 'medium', LARGE: 'large' };
const WIDTH_TYPE_VALUES = { [WIDTH_TYPES.SMALL]: 200, [WIDTH_TYPES.MEDIUM]: 350, [WIDTH_TYPES.LARGE]: 500 };

// Separated connection style constants
const CONNECTION_PATTERNS = {
    NORMAL: 'normal',
    DASHED: 'dashed',
    DOTTED: 'dotted'
};

const CONNECTION_THICKNESSES = {
    THIN: 'thin',
    NORMAL: 'normal',
    BOLD: 'bold'
};

// Enhanced color theme configuration with light and dark variants
const COLOR_THEMES = {
    default: {
        name: 'Default',
        light: {
            bg: 'light-default-bg',
            border: 'light-default-border',
            text: 'light-default-text',
            stroke: '#4b5563'
        },
        dark: {
            bg: 'dark-default-bg',
            border: 'dark-default-border',
            text: 'dark-default-text',
            stroke: '#9ca3af'
        }
    },
    red: {
        name: 'Red',
        light: {
            bg: 'light-red-bg',
            border: 'light-red-border',
            text: 'light-red-text',
            stroke: '#ef4444'
        },
        dark: {
            bg: 'dark-red-bg',
            border: 'dark-red-border',
            text: 'dark-red-text',
            stroke: '#fca5a5'
        }
    },
    green: {
        name: 'Green',
        light: {
            bg: 'light-green-bg',
            border: 'light-green-border',
            text: 'light-green-text',
            stroke: '#10b981'
        },
        dark: {
            bg: 'dark-green-bg',
            border: 'dark-green-border',
            text: 'dark-green-text',
            stroke: '#34d399'
        }
    },
    blue: {
        name: 'Blue',
        light: {
            bg: 'light-blue-bg',
            border: 'light-blue-border',
            text: 'light-blue-text',
            stroke: '#3b82f6'
        },
        dark: {
            bg: 'dark-blue-bg',
            border: 'dark-blue-border',
            text: 'dark-blue-text',
            stroke: '#60a5fa'
        }
    },
    purple: {
        name: 'Purple',
        light: {
            bg: 'light-purple-bg',
            border: 'light-purple-border',
            text: 'light-purple-text',
            stroke: '#8b5cf6'
        },
        dark: {
            bg: 'dark-purple-bg',
            border: 'dark-purple-border',
            text: 'dark-purple-text',
            stroke: '#a78bfa'
        }
    },
    yellow: {
        name: 'Yellow',
        light: {
            bg: 'light-yellow-bg',
            border: 'light-yellow-border',
            text: 'light-yellow-text',
            stroke: '#f59e0b'
        },
        dark: {
            bg: 'dark-yellow-bg',
            border: 'dark-yellow-border',
            text: 'dark-yellow-text',
            stroke: '#fbbf24'
        }
    },
    grey: {
        name: 'Grey',
        light: {
            bg: 'light-grey-bg',
            border: 'light-grey-border',
            text: 'light-grey-text',
            stroke: '#111827'
        },
        dark: {
            bg: 'dark-grey-bg',
            border: 'dark-grey-border',
            text: 'dark-grey-text',
            stroke: '#9ca3af'
        }
    }
};

// Get all theme keys for cycling
const THEME_KEYS = Object.keys(COLOR_THEMES);

// Define base classes for reuse in JS - using Tailwind utility classes
const BASE_BOX_CLASSES = 'absolute rounded-lg box-default cursor-move no-select py-2 px-3 pointer-events-auto overflow-hidden box-transition';

// Enhanced markdown parser with better support for lists and tables
function simpleMarkdownParser(text) {
    if (!text) return '';
    
    // Store code blocks so they don't get processed
    const codeBlocks = [];
    text = text.replace(/```([\s\S]*?)```/g, function(match) {
        codeBlocks.push(match);
        return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
    });
    
    // Process text
    text = text
        // Headers
        .replace(/### (.*?)(\n|$)/g, '<h3>$1</h3>\n')
        .replace(/## (.*?)(\n|$)/g, '<h2>$1</h2>\n')
        .replace(/# (.*?)(\n|$)/g, '<h1>$1</h1>\n')
        
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        
        // Inline code
        .replace(/`([^`]*)`/g, '<code>$1</code>')
        
        // Horizontal rule
        .replace(/^---+$/gm, '<hr>')
        
        // Tables - this is a simplified implementation
        .replace(/^\|(.+)\|$/gm, function(match, content) {
            // Split the table row into cells
            const cells = content.split('|').map(cell => cell.trim());
            
            // Check if this is a header separator row (contains only dashes and colons)
            if (cells.every(cell => /^:?-+:?$/.test(cell))) {
                return match; // Return unchanged, we'll remove these later
            }
            
            // Create table cells
            const cellsHtml = cells.map(cell => `<td>${cell}</td>`).join('');
            return `<tr>${cellsHtml}</tr>`;
        })
        // Process tables by finding consecutive table rows
        .replace(/(<tr>.*?<\/tr>)\n\|([-:\s|]+)\|\n(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, headerRow, separatorRow, bodyRows) {
            // Convert the header row's cells to <th> instead of <td>
            const tableHeader = headerRow.replace(/<td>(.*?)<\/td>/g, '<th>$1</th>');
            return `<table><thead>${tableHeader}</thead><tbody>${bodyRows}</tbody></table>`;
        })
        // Handle tables without headers
        .replace(/(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, rows) {
            // Only convert to a table if it's not already in a table
            if (!match.includes('<table>')) {
                return `<table><tbody>${rows}</tbody></table>`;
            }
            return match;
        })
        
        // Ordered lists - look for consecutive lines starting with numbers
        .replace(/^(\d+\. .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the number and period, then trim
                const content = item.replace(/^\d+\.\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ol>${listItems}</ol>\n`;
        })
        
        // Unordered lists - handle multiple list markers
        .replace(/^([\*\-\+] .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the list marker, then trim
                const content = item.replace(/^[\*\-\+]\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ul>${listItems}</ul>\n`;
        })
        
        // Paragraphs (lines not already processed)
        .replace(/^([^\n<][^\n]*?)(?:\n|$)/gm, function(match, content) {
            // Don't wrap empty lines in <p> tags
            if (content.trim() === '') return '\n';
            // Don't wrap lines that are likely part of lists or other block elements
            if (/^<\/(ol|ul|table|h[1-6])>/.test(content)) return content + '\n';
            return `<p>${content}</p>\n`;
        })
        
        // Clean up extra newlines
        .replace(/\n+/g, '\n');
    
    // Restore code blocks
    text = text.replace(/__CODE_BLOCK_(\d+)__/g, function(match, index) {
        const code = codeBlocks[parseInt(index)]
            .replace(/```(?:\w+)?\n([\s\S]*?)```/g, '$1')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        return `<pre><code>${code}</code></pre>`;
    });
    
    return text;
}

// Helper to safely remove CSS classes
function safeRemoveClass(element, className) {
    if (element && className && className.trim() !== '') {
        element.classList.remove(className);
    }
}

// --- Settings Manager ---
class SettingsManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager; // Store reference to diagram manager
        this.settings = {
            textScale: 1.0
        };
        this.loadSettings();
    }
    
    loadSettings() {
        try {
            const storedSettings = localStorage.getItem('markdownDiagramSettings');
            if (storedSettings) {
                this.settings = { ...this.settings, ...JSON.parse(storedSettings) };
            }
            this.applySettings();
        } catch (error) {
            console.error('Error loading settings:', error);
        }
    }
    
    saveSettings() {
        try {
            localStorage.setItem('markdownDiagramSettings', JSON.stringify(this.settings));
            // Update all boxes after saving settings
            if (this.diagramManager) {
                this.diagramManager.updateAllBoxSizes();
            }
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }
    
    applySettings() {
        // Apply text scale
        document.documentElement.style.setProperty('--font-scale', this.settings.textScale);
        
        // Update UI if elements exist
        const textScaleSlider = document.getElementById('text-scale');
        const textScaleValue = document.getElementById('text-scale-value');
        
        if (textScaleSlider) textScaleSlider.value = this.settings.textScale;
        if (textScaleValue) textScaleValue.textContent = `${this.settings.textScale.toFixed(1)}x`;
        
        // Update all box sizes when settings are applied (e.g. on page load)
        if (this.diagramManager) {
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                this.diagramManager.updateAllBoxSizes();
            }, 100);
        }
    }
}

// --- Project Management ---
class ProjectManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager;
        this.projects = [];
        this.currentProjectId = null;
        this.storageKey = 'markdownDiagramProjects';
        this.projectListEl = document.getElementById('project-list');
        this.noProjectsMessage = document.getElementById('no-projects-message');
        this.projectNameInput = document.getElementById('project-name');
        this.settingsMenu = document.getElementById('settings-menu');
        this.textScaleSlider = document.getElementById('text-scale');
        this.textScaleValue = document.getElementById('text-scale-value');
        this.newProjectForm = document.getElementById('new-project-form');
        this.addProjectToggle = document.getElementById('add-project-toggle');
        
        // Store which project is currently being edited/confirmed for deletion
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        this.showingNewProjectForm = false;
        
        this.loadProjects();
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Settings button opens the menu
        document.getElementById('settings-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleSettingsMenu();
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!this.settingsMenu.contains(e.target) && 
                e.target.id !== 'settings-button' && 
                !e.target.closest('#settings-button')) {
                this.hideSettingsMenu();
            }
        });
        
        // Add project toggle
        this.addProjectToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleNewProjectForm();
        });
        
        // Commit new project
        document.getElementById('commit-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.createNewProject();
        });
        
        // Cancel new project
        document.getElementById('cancel-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.hideNewProjectForm();
        });
        
        // Create project on Enter
        this.projectNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.createNewProject();
            }
        });
        
        // Cancel on Escape key
        this.projectNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideNewProjectForm();
            }
        });
        
        // Text scale slider auto-save
        this.textScaleSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            this.textScaleValue.textContent = `${value.toFixed(1)}x`;
            
            // Save immediately to localStorage
            const settings = JSON.parse(localStorage.getItem('markdownDiagramSettings') || '{"textScale":1.0}');
            settings.textScale = value;
            localStorage.setItem('markdownDiagramSettings', JSON.stringify(settings));
            
            // Apply the setting
            document.documentElement.style.setProperty('--font-scale', value);
            
            // Update box sizes
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = setTimeout(() => {
                this.diagramManager.updateAllBoxSizes();
            }, 50);
        });
    }
    
    toggleNewProjectForm() {
        if (this.showingNewProjectForm) {
            this.hideNewProjectForm();
        } else {
            this.showNewProjectForm();
        }
    }
    
    showNewProjectForm() {
        this.showingNewProjectForm = true;
        this.newProjectForm.classList.remove('hidden');
        
        // Use setTimeout to ensure transition works
        setTimeout(() => {
            this.newProjectForm.style.maxHeight = '100px';
            // Focus the input field
            this.projectNameInput.focus();
        }, 10);
    }
    
    hideNewProjectForm() {
        this.showingNewProjectForm = false;
        this.newProjectForm.style.maxHeight = '0';
        this.projectNameInput.value = '';
        
        // Hide after transition
        setTimeout(() => {
            this.newProjectForm.classList.add('hidden');
        }, 200);
    }
    
    toggleSettingsMenu() {
        if (this.settingsMenu.classList.contains('hidden')) {
            this.showSettingsMenu();
        } else {
            this.hideSettingsMenu();
        }
    }
    
    showSettingsMenu() {
        this.settingsMenu.classList.remove('hidden');
        
        // Animate in
        setTimeout(() => {
            this.settingsMenu.classList.remove('opacity-0', 'translate-y-2', 'pointer-events-none');
            this.settingsMenu.classList.add('opacity-100', 'translate-y-0');
        }, 10);
        
        // Update project list when showing menu
        this.renderProjectList();
    }
    
    hideSettingsMenu() {
        // Reset all sub-states
        this.hideNewProjectForm();
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        
        // Animate out
        this.settingsMenu.classList.add('opacity-0', 'translate-y-2', 'pointer-events-none');
        this.settingsMenu.classList.remove('opacity-100', 'translate-y-0');
        
        // Hide after animation
        setTimeout(() => {
            this.settingsMenu.classList.add('hidden');
        }, 200);
    }
    
    loadProjects() {
        try {
            const storedProjects = localStorage.getItem(this.storageKey);
            if (storedProjects) {
                this.projects = JSON.parse(storedProjects);
                this.renderProjectList();
                
                // Load last active project if exists
                const lastActiveId = localStorage.getItem('lastActiveProject');
                if (lastActiveId && this.projects.find(p => p.id === lastActiveId)) {
                    this.loadProject(lastActiveId);
                } else if (this.projects.length > 0) {
                    // Load first project if no last active
                    this.loadProject(this.projects[0].id);
                }
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            this.projects = [];
        }
        
        this.updateProjectsVisibility();
        this.updateProjectTitle();
    }
    
    saveProjects() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.projects));
            if (this.currentProjectId) {
                localStorage.setItem('lastActiveProject', this.currentProjectId);
            }
        } catch (error) {
            console.error('Error saving projects:', error);
        }
    }
    
    updateProjectTitle() {
        const projectTitleEl = document.getElementById('project-title');
        const currentProject = this.getCurrentProject();
        
        if (currentProject) {
            // Update the H1 element
            projectTitleEl.textContent = currentProject.name;
            
            // Update the page title
            document.title = `${currentProject.name} - Flow Chart`;
        } else {
            projectTitleEl.textContent = 'New Project';
            document.title = 'Flow Chart';
        }
    }
    
    createNewProject() {
        const name = this.projectNameInput.value.trim();
        if (!name) return;
        
        const newProject = {
            id: 'project_' + Date.now(),
            name: name,
            dateCreated: new Date().toISOString(),
            dateModified: new Date().toISOString(),
            data: {
                boxes: [],
                connections: [],
                nextBoxId: 1,
                nextConnectionId: 1
            }
        };
        
        this.projects.push(newProject);
        this.saveProjects();
        this.hideNewProjectForm();
        this.renderProjectList();
        this.loadProject(newProject.id);
        this.updateProjectsVisibility();
    }
    
    renderProjectList() {
        // Clear existing projects except the "no projects" message
        const children = Array.from(this.projectListEl.children);
        children.forEach(child => {
            if (child !== this.noProjectsMessage) {
                child.remove();
            }
        });
        
        // Add project items
        this.projects.forEach(project => {
            const projectItem = document.createElement('div');
            projectItem.className = 'mb-2 rounded overflow-hidden';
            projectItem.dataset.id = project.id;
            
            // Main project container
            const projectContainer = document.createElement('div');
            projectContainer.className = 'p-2 flex justify-between items-center cursor-pointer group';
            projectContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
            
            if (project.id === this.currentProjectId) {
                projectContainer.classList.add('bg-purple-600', 'bg-opacity-20');
            }
            
            // Check if this project is being edited
            if (this.editingProjectId === project.id) {
                // Render edit form
                projectContainer.innerHTML = `
                    <div class="flex w-full items-center">
                        <input type="text" class="flex-1 px-2 py-1 mr-2 border rounded" value="${project.name}" id="edit-${project.id}" style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" data-id="${project.id}" title="Save">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600 ml-1" data-id="${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                // Setup event listeners for the edit form
                const input = projectContainer.querySelector('input');
                const commitBtn = projectContainer.querySelector('button[title="Save"]');
                const cancelBtn = projectContainer.querySelector('button[title="Cancel"]');
                
                // Focus the input
                setTimeout(() => input.focus(), 0);
                
                // Commit on button click
                commitBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.commitProjectEdit(project.id, input.value);
                });
                
                // Cancel edit
                cancelBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.editingProjectId = null;
                    this.renderProjectList();
                });
                
                // Commit on Enter key
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.commitProjectEdit(project.id, input.value);
                    }
                });
                
                // Cancel on Escape key
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.editingProjectId = null;
                        this.renderProjectList();
                    }
                });
            }
            // Normal project display
            else {
                const dateModified = new Date(project.dateModified);
                const formattedDate = dateModified.toLocaleDateString();
                
                projectContainer.innerHTML = `
                    <div>
                        <div class="truncate">${project.name}</div>
                        <div class="text-xs opacity-60">Modified: ${formattedDate}</div>
                    </div>
                    <div class="flex gap-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Edit">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Delete">
                            <i class="fas fa-trash-alt text-red-500"></i>
                        </button>
                    </div>
                `;
            }
            
            projectItem.appendChild(projectContainer);
            
            // Check if this project has a delete confirmation showing
            if (this.confirmingDeleteId === project.id) {
                // Create delete confirmation that slides down
                const confirmDelete = document.createElement('div');
                confirmDelete.className = 'p-2 flex items-center justify-between transition-all duration-200 overflow-hidden';
                confirmDelete.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                confirmDelete.innerHTML = `
                    <span class="text-sm">Confirm delete</span>
                    <div class="flex gap-2">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" id="confirm-delete-${project.id}" title="Confirm">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600" id="cancel-delete-${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                projectItem.appendChild(confirmDelete);
                
                // Add event listeners for confirmation buttons
                confirmDelete.querySelector(`#confirm-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteProject(project.id);
                });
                
                confirmDelete.querySelector(`#cancel-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.confirmingDeleteId = null;
                    this.renderProjectList();
                });
            }
            
            // Add click event to load project (only if not in edit mode)
            if (this.editingProjectId !== project.id) {
                projectContainer.addEventListener('click', (e) => {
                    // Don't load if clicking buttons
                    if (!e.target.closest('button')) {
                        this.loadProject(project.id);
                        this.hideSettingsMenu();
                    }
                });
                
                // Add event listeners for edit and delete buttons
                const editBtn = projectContainer.querySelector('button[title="Edit"]');
                if (editBtn) {
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.startProjectEdit(project.id);
                    });
                }
                
                const deleteBtn = projectContainer.querySelector('button[title="Delete"]');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.confirmDeleteProject(project.id);
                    });
                }
            }
            
            this.projectListEl.appendChild(projectItem);
        });
        
        this.updateProjectsVisibility();
    }
    
    // Start editing a project name
    startProjectEdit(projectId) {
        this.editingProjectId = projectId;
        this.renderProjectList();
    }
    
    // Commit project name edit
    commitProjectEdit(projectId, newName) {
        newName = newName.trim();
        if (!newName) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === projectId);
        if (projectIndex >= 0) {
            this.projects[projectIndex].name = newName;
            this.saveProjects();
            
            // Update title if editing current project
            if (projectId === this.currentProjectId) {
                this.updateProjectTitle();
            }
        }
        
        this.editingProjectId = null;
        this.renderProjectList();
    }
    
    // Show delete confirmation
    confirmDeleteProject(projectId) {
        this.confirmingDeleteId = projectId;
        this.renderProjectList();
    }
    
    updateProjectsVisibility() {
        if (this.projects.length === 0) {
            this.noProjectsMessage.style.display = 'block';
        } else {
            this.noProjectsMessage.style.display = 'none';
        }
    }
    
    deleteProject(projectId) {
        this.projects = this.projects.filter(project => project.id !== projectId);
        this.saveProjects();
        
        // If deleted current project, load another one
        if (projectId === this.currentProjectId) {
            if (this.projects.length > 0) {
                this.loadProject(this.projects[0].id);
            } else {
                // No projects left, clear diagram
                this.diagramManager.clearDiagram();
                this.currentProjectId = null;
                this.updateProjectTitle();
            }
        }
        
        this.confirmingDeleteId = null;
        this.renderProjectList();
        this.updateProjectsVisibility();
    }
    
    loadProject(projectId) {
        const project = this.projects.find(p => p.id === projectId);
        if (!project) return;
        
        // Save current project if exists
        this.saveCurrentProject();
        
        // Load new project
        this.currentProjectId = projectId;
        this.diagramManager.loadFromProjectData(project.data);
        
        // Update project title
        this.updateProjectTitle();
        
        localStorage.setItem('lastActiveProject', projectId);
    }
    
    saveCurrentProject() {
        if (!this.currentProjectId) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === this.currentProjectId);
        if (projectIndex >= 0) {
            const diagramData = this.diagramManager.exportData();
            this.projects[projectIndex].data = diagramData;
            this.projects[projectIndex].dateModified = new Date().toISOString();
            this.saveProjects();
        }
    }
    
    getCurrentProject() {
        return this.projects.find(p => p.id === this.currentProjectId);
    }
}

// --- Box Class ---
class Box {
    constructor(boxData, manager) {
        this.data = boxData;
        if (!this.data.widthType) { this.data.widthType = WIDTH_TYPES.MEDIUM; }
        if (!this.data.markdown) { this.data.markdown = '# New Box\nUse **markdown** to format'; }
        if (!this.data.themeKey) { this.data.themeKey = 'default'; }
        this.manager = manager;
        this.isEditing = false;
        this.element = this.createElement();
        this.contentDiv = this.element.firstChild;
        this.textarea = null;
        this.updateElementPosition();
        this.applyColorTheme();
        this.renderMarkdown();
        this.setupEventListeners();
    }

    createElement() { 
        const div = document.createElement('div'); 
        div.className = BASE_BOX_CLASSES; 
        div.dataset.id = this.data.id; 
        div.dataset.type = 'box';
        div.dataset.theme = this.data.themeKey;
        const contentDiv = document.createElement('div'); 
        contentDiv.className = 'markdown-content relative w-full h-full'; 
        div.appendChild(contentDiv); 
        return div; 
    }
    
    setupEventListeners() {
        let isDragging = false;
        
        this.element.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.element.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.element.addEventListener('mousedown', (e) => { 
            isDragging = false; 
            // Start dragging on mousedown
            if (e.button === 0 && !this.isEditing) {
                this.manager.startDragging(this, e);
            } else if (e.button === 2) {
                // Right mouse button down - start connection or change width
                this.manager.handleBoxRightMouseDown(e, this);
            }
        });
        
        this.element.addEventListener('mousemove', () => { 
            if (this.manager.draggingBox === this) { 
                isDragging = true; 
            } 
        });
        
        this.element.addEventListener('dblclick', (e) => { 
            e.stopPropagation(); 
            if (!this.isEditing) { 
                this.startEditing(); 
            } 
        });
        
        this.element.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            return false; 
        });
    }

    // Updates the element's CSS position
    updateElementPosition() {
        const x = this.data.cx - this.data.width / 2;
        const y = this.data.cy - this.data.height / 2;
        this.element.style.left = `${Math.round(x)}px`;
        this.element.style.top = `${Math.round(y)}px`;
        this.element.style.width = `${this.data.width}px`;
        this.element.style.height = `${this.data.height}px`;
    }

    // Updates position using center coordinates - for dragging
    setCenterPosition(cx, cy) { this.data.cx = cx; this.data.cy = cy; this.updateElementPosition(); }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Apply color theme to the box
    applyColorTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get the mode-specific theme
        const modeTheme = theme[mode];
        
        // Remove all theme classes
        THEME_KEYS.forEach(key => {
            const lightTheme = COLOR_THEMES[key].light;
            const darkTheme = COLOR_THEMES[key].dark;
            
            // Remove both light and dark variants
            safeRemoveClass(this.element, lightTheme.bg);
            safeRemoveClass(this.element, lightTheme.border);
            safeRemoveClass(this.contentDiv, lightTheme.text);
            
            safeRemoveClass(this.element, darkTheme.bg);
            safeRemoveClass(this.element, darkTheme.border);
            safeRemoveClass(this.contentDiv, darkTheme.text);
        });
        
        // Add current theme classes for the current mode
        if (modeTheme.bg) this.element.classList.add(modeTheme.bg);
        if (modeTheme.border) this.element.classList.add(modeTheme.border);
        if (modeTheme.text) this.contentDiv.classList.add(modeTheme.text);
        
        // Update data attribute for theme identification
        this.element.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyColorTheme();
    }

    // Toggle between width types
    toggleWidthType() {
        const types = Object.values(WIDTH_TYPES);
        const currentIndex = types.indexOf(this.data.widthType);
        const nextIndex = (currentIndex + 1) % types.length;
        this.data.widthType = types[nextIndex];
        
        // Set the new width directly
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        this.data.width = width;
        
        // Update size based on current mode
        if (this.isEditing) {
            this.updateEditModeSize();
        } else {
            this.renderMarkdown();
        }
        
        this.manager.updateConnectionsForBox(this);
    }

    // Renders markdown content to HTML and calculates size
    renderMarkdown() {
        if (!this.data.markdown) return;
        
        try {
            // Use marked.js or fallback
            this.contentDiv.innerHTML = typeof marked !== 'undefined' && typeof marked.parse === 'function' 
                ? marked.parse(this.data.markdown) 
                : simpleMarkdownParser(this.data.markdown);
        } catch (e) {
            console.error('Error parsing markdown:', e);
            this.contentDiv.innerHTML = simpleMarkdownParser(this.data.markdown);
        }
        
        // Update size after rendering
        this.calculateRenderedSize();
    }

    // Calculate size with fixed width based on type
    calculateRenderedSize() {
        // Clone for measurement
        const clone = this.element.cloneNode(true);
        document.body.appendChild(clone);
        
        // Reset styles for measurement
        clone.style.position = 'absolute';
        clone.style.visibility = 'hidden';
        clone.style.left = '-9999px';
        clone.style.top = '-9999px';
        clone.style.height = 'auto';
        clone.style.maxWidth = 'none';
        clone.style.transition = 'none';
        
        // Use fixed width from width type directly
        const fixedWidth = WIDTH_TYPE_VALUES[this.data.widthType];
        clone.style.width = `${fixedWidth}px`;
        
        // Force reflow and measure height with the fixed width
        clone.offsetHeight;
        const newHeight = Math.max(clone.offsetHeight, 50);
        
        // Clean up
        document.body.removeChild(clone);
        
        // Update size
        this.data.width = fixedWidth;
        this.data.height = newHeight;
        this.updateElementPosition();
        
        return { width: fixedWidth, height: newHeight };
    }

    // Calculate box height based on line count
    calculateHeightFromLineCount() {
        if (!this.isEditing || !this.textarea) return 50;
        
        const lineCount = this.textarea.value.split('\n').length;
        return PADDING_HEIGHT + (lineCount * LINE_HEIGHT);
    }

    // Updates box size based on text content during editing
    updateEditModeSize() {
        if (!this.isEditing || !this.textarea) return;
        
        // Always use fixed width from width type
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Calculate height based on line count
        const height = this.calculateHeightFromLineCount();
        
        // Update size
        this.data.width = width;
        this.data.height = height;
        this.updateElementPosition();
        this.manager.updateConnectionsForBox(this);
    }

    // Switches to editing mode
    startEditing() {
        if (this.isEditing) return;
        this.isEditing = true;
        this.element.classList.remove('cursor-move');
        
        // Clear and prepare container
        this.contentDiv.innerHTML = '';
        
        // Create textarea
        this.textarea = document.createElement('textarea');
        this.textarea.className = 'edit-textarea';
        this.textarea.value = this.data.markdown || '';
        this.textarea.placeholder = 'Add markdown content...';
        
        // Set fixed width from width type
        this.data.width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Add event listeners
        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') { 
                e.preventDefault(); 
                this.cancelEdit(); 
            } else if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.commitEdit();
            }
            
            // Update size on next tick
            setTimeout(() => this.updateEditModeSize(), 0);
        });
        
        this.textarea.addEventListener('input', () => {
            this.updateEditModeSize();
        });
        
        // Prevent event propagation
        this.textarea.addEventListener('mousedown', e => e.stopPropagation());
        this.textarea.addEventListener('contextmenu', e => e.stopPropagation());
        this.textarea.addEventListener('dblclick', e => e.stopPropagation());
        this.textarea.addEventListener('click', e => e.stopPropagation());

        this.contentDiv.appendChild(this.textarea);

        // Focus and select text
        requestAnimationFrame(() => {
            this.textarea.focus();
            if (this.textarea.value) this.textarea.select();
            this.updateEditModeSize();
        });
    }

    commitEdit() { 
        if (!this.isEditing || !this.textarea) return false; 
        const markdown = this.textarea.value.trim(); 
        if (!markdown) { 
            this.cancelEdit(); 
            return false; 
        } 
        this.data.markdown = markdown; 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
        this.manager.updateConnectionsForBox(this); 
        this.manager.saveCurrentProject();
        this.manager.updateCanvasSize(); // Update canvas size after edit
        return true; 
    }
    
    cancelEdit() { 
        if (!this.isEditing) return; 
        if (!this.data.markdown) { 
            this.manager.deleteBox(this); 
            return; 
        } 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
    }
    
    cleanupEdit() { 
        this.isEditing = false; 
        if (this.textarea && this.textarea.parentNode) { 
            this.textarea.remove(); 
        } 
        this.textarea = null; 
        this.element.classList.add('cursor-move'); 
    }
    
    getBounds() { 
        const x = this.data.cx - this.data.width / 2; 
        const y = this.data.cy - this.data.height / 2; 
        return { 
            left: x, 
            right: x + this.data.width, 
            top: y, 
            bottom: y + this.data.height, 
            width: this.data.width, 
            height: this.data.height 
        }; 
    }
    
    // Export box data
    exportData() {
        return {
            id: this.data.id,
            cx: this.data.cx,
            cy: this.data.cy,
            width: this.data.width,
            height: this.data.height,
            widthType: this.data.widthType,
            themeKey: this.data.themeKey,
            markdown: this.data.markdown
        };
    }
}

// --- Connection Class ---
class Connection {
    constructor(connectionData, startBox, endBox, manager) { 
        this.data = connectionData; 
        // Initialize data if needed
        if (!this.data.themeKey) this.data.themeKey = 'default';
        if (!this.data.pattern) this.data.pattern = CONNECTION_PATTERNS.NORMAL;
        if (!this.data.thickness) this.data.thickness = CONNECTION_THICKNESSES.NORMAL;
        if (this.data.bidirectional === undefined) this.data.bidirectional = false;
        
        this.startBox = startBox; 
        this.endBox = endBox; 
        this.manager = manager; 
        
        // Create connection group
        this.createElements();
        
        // Create invisible hotspots for better arrow interaction
        this.startHotspot = null;
        this.endHotspot = null;
        this.createHotspots();
        
        this.update(); 
        this.setupEventListeners(); 
    }
    
    createElements() {
        // Create the hitbox path with wide stroke for easier clicking
        this.hitboxElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        this.hitboxElement.setAttribute('class', 'connection-hitbox');
        this.hitboxElement.dataset.id = this.data.id;
        this.hitboxElement.dataset.type = 'connection-hitbox';
        
        // Create the visible connection path
        this.element = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
        this.element.setAttribute('class', 'connection-path pointer-events-none'); 
        this.element.dataset.id = this.data.id; 
        this.element.dataset.type = 'connection';
        this.element.dataset.theme = this.data.themeKey;
        
        // Set markers based on if bidirectional
        if (this.data.bidirectional) {
            this.element.setAttribute('marker-start', 'url(#arrowhead-start)');
        }
        this.element.setAttribute('marker-end', 'url(#arrowhead-end)');
    }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Create invisible hotspots for better arrow interaction
    createHotspots() {
        // Create start hotspot
        this.startHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.startHotspot.setAttribute('class', 'arrow-hotspot');
        this.startHotspot.setAttribute('r', '12');
        this.startHotspot.dataset.connection = this.data.id;
        this.startHotspot.dataset.end = 'start';
        this.manager.svg.appendChild(this.startHotspot);
        
        // Create end hotspot
        this.endHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.endHotspot.setAttribute('class', 'arrow-hotspot');
        this.endHotspot.setAttribute('r', '12');
        this.endHotspot.dataset.connection = this.data.id;
        this.endHotspot.dataset.end = 'end';
        this.manager.svg.appendChild(this.endHotspot);
        
        // Add event listeners to hotspots
        this.startHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.startHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.startHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
        
        this.endHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.endHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.endHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
    }
    
    // Toggle bidirectionality of the connection
    toggleBidirectional() {
        this.data.bidirectional = !this.data.bidirectional;
        
        if (this.data.bidirectional) {
            this.element.setAttribute('marker-start', 'url(#arrowhead-start)');
        } else {
            this.element.removeAttribute('marker-start');
        }
        
        // Update the connection
        this.update();
    }
    
    setupEventListeners() { 
        // Add interaction events to the hitbox element
        this.hitboxElement.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.hitboxElement.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        // Add left-click event to toggle line pattern
        this.hitboxElement.addEventListener('click', (e) => {
            e.stopPropagation();
            this.cyclePattern();
            this.manager.saveCurrentProject();
        });
        
        // Add right-click event to toggle thickness
        this.hitboxElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.cycleThickness();
            this.manager.saveCurrentProject();
        });
    }
    
    // Apply the current theme to the connection
    applyTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get stroke color for current mode
        const strokeColor = theme[mode].stroke;
        
        if (this.element) {
            this.element.setAttribute('stroke', strokeColor);
        }
        
        // Update data attribute for theme identification
        this.element.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyTheme();
        this.manager.saveCurrentProject();
    }
    
    // Apply current pattern to the connection
    applyPattern() {
        // Remove all pattern classes first
        this.element.classList.remove(
            'connection-pattern-normal',
            'connection-pattern-dashed', 
            'connection-pattern-dotted'
        );
        
        // Add current pattern class
        this.element.classList.add(`connection-pattern-${this.data.pattern}`);
    }
    
    // Apply current thickness to the connection
    applyThickness() {
        // Remove all thickness classes first
        this.element.classList.remove(
            'connection-thickness-thin',
            'connection-thickness-normal',
            'connection-thickness-bold'
        );
        
        // Add current thickness class
        this.element.classList.add(`connection-thickness-${this.data.thickness}`);
    }
    
    // Cycle to the next line pattern (left click)
    cyclePattern() {
        const patterns = Object.values(CONNECTION_PATTERNS);
        const currentIndex = patterns.indexOf(this.data.pattern);
        const nextIndex = (currentIndex + 1) % patterns.length;
        this.data.pattern = patterns[nextIndex];
        this.applyPattern();
    }
    
    // Cycle to the next thickness (right click)
    cycleThickness() {
        const thicknesses = Object.values(CONNECTION_THICKNESSES);
        const currentIndex = thicknesses.indexOf(this.data.thickness);
        const nextIndex = (currentIndex + 1) % thicknesses.length;
        this.data.thickness = thicknesses[nextIndex];
        this.applyThickness();
    }
    
    calculateIntersection(startPt, endPt, targetBox) { const bounds = targetBox.getBounds(); const dx = endPt.x - startPt.x; const dy = endPt.y - startPt.y; if (bounds.width <= 0 || bounds.height <= 0 || (dx === 0 && dy === 0)) { return { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; } let t = Infinity; let intersection = null; const tol = 0.1; const checkT = (newT, x, y, b) => { if (newT >= 0 && newT < t && x >= b.left - tol && x <= b.right + tol && y >= b.top - tol && y <= b.bottom + tol) { t = newT; return { x, y }; } return null; }; if (dx !== 0) { let tL = (bounds.left - startPt.x) / dx; let yL = startPt.y + tL * dy; intersection = checkT(tL, bounds.left, yL, bounds) || intersection; let tR = (bounds.right - startPt.x) / dx; let yR = startPt.y + tR * dy; intersection = checkT(tR, bounds.right, yR, bounds) || intersection; } if (dy !== 0) { let tT = (bounds.top - startPt.y) / dy; let xT = startPt.x + tT * dx; intersection = checkT(tT, xT, bounds.top, bounds) || intersection; let tB = (bounds.bottom - startPt.y) / dy; let xB = startPt.x + tB * dx; intersection = checkT(tB, xB, bounds.bottom, bounds) || intersection; } if (intersection) { const len = Math.sqrt(dx*dx + dy*dy) || 1; const ux = dx / len; const uy = dy / len; intersection.x -= ux * 2; intersection.y -= uy * 2; } return intersection || { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; }
    
    update() { 
        if (!this.startBox || !this.endBox) return; 
        const sC = { x: this.startBox.data.cx, y: this.startBox.data.cy }; 
        const eC = { x: this.endBox.data.cx, y: this.endBox.data.cy }; 
        const eP = this.calculateIntersection(sC, eC, this.endBox); 
        const sP = this.calculateIntersection(eP, sC, this.startBox); 
        
        if (!isNaN(sP.x) && !isNaN(eP.x)) { 
            const pathData = `M ${sP.x} ${sP.y} L ${eP.x} ${eP.y}`;
            
            // Update both the visible path and hitbox path
            this.element.setAttribute('d', pathData); 
            this.hitboxElement.setAttribute('d', pathData);
            
            // Update hotspot positions
            this.updateHotspotPositions(sP, eP);
        } else { 
            this.element.setAttribute('d', ''); 
            this.hitboxElement.setAttribute('d', '');
        } 
        
        this.updateElementStyle(); 
    }
    
    // Update hotspot positions
    updateHotspotPositions(startPoint, endPoint) {
        // Calculate vector
        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len === 0) return;
        
        const ux = dx / len;
        const uy = dy / len;
        
        // Position hotspots
        if (this.startHotspot) {
            const startHotspotX = startPoint.x + ux * 12;
            const startHotspotY = startPoint.y + uy * 12;
            this.startHotspot.setAttribute('cx', startHotspotX);
            this.startHotspot.setAttribute('cy', startHotspotY);
        }
        
        if (this.endHotspot) {
            const endHotspotX = endPoint.x - ux * 12;
            const endHotspotY = endPoint.y - uy * 12;
            this.endHotspot.setAttribute('cx', endHotspotX);
            this.endHotspot.setAttribute('cy', endHotspotY);
        }
    }
    
    updateElementStyle() { 
        // Apply theme, pattern and thickness
        this.applyTheme();
        this.applyPattern();
        this.applyThickness();
    }
    
    // Clean up the connection by removing hotspot elements
    cleanup() {
        if (this.startHotspot) {
            this.startHotspot.remove();
            this.startHotspot = null;
        }
        
        if (this.endHotspot) {
            this.endHotspot.remove();
            this.endHotspot = null;
        }
        
        if (this.hitboxElement) {
            this.hitboxElement.remove();
            this.hitboxElement = null;
        }
        
        if (this.element) {
            this.element.remove();
            this.element = null;
        }
    }
    
    // Export connection data
    exportData() {
        return {
            id: this.data.id,
            startBoxId: this.startBox.data.id,
            endBoxId: this.endBox.data.id,
            themeKey: this.data.themeKey,
            pattern: this.data.pattern,
            thickness: this.data.thickness,
            bidirectional: this.data.bidirectional
        };
    }
}

// --- Diagram Manager Class ---
class DiagramManager {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.svg = document.getElementById('connections');
        this.boxContainer = document.getElementById('box-container');
        this.helperText = document.getElementById('helper-text');
        this.previewPath = document.getElementById('preview-connection');
        
        this.boxes = new Map();
        this.connections = new Map();
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        this.draggingBox = null;
        this.dragStartPos = { x: 0, y: 0 };
        this.dragBoxStartCenter = { cx: 0, cy: 0 };
        this.connectionStartBox = null;
        this.hoveredElement = null; // Track currently hovered element
        
        // Initialize theme
        this.initTheme();
        
        // Initialize settings manager with reference to this diagram manager
        this.settingsManager = new SettingsManager(this);
        
        // Initialize UI
        this.setupEventListeners();
        this.updateHelperText();
        this.setupThemeToggle();
        
        // Initialize project manager
        this.projectManager = new ProjectManager(this);
        
        // Set initial canvas size
        this.updateCanvasSize();
        
        // Add window resize listener
        window.addEventListener('resize', () => {
            this.updateCanvasSize();
        });
    }
    
    // Update canvas size based on box positions with buffer zone
    updateCanvasSize() {
        // Find the maximum bounds in all directions
        let maxRight = 0;
        let maxBottom = 0;
        
        this.boxes.forEach(box => {
            const bounds = box.getBounds();
            maxRight = Math.max(maxRight, bounds.right);
            maxBottom = Math.max(maxBottom, bounds.bottom);
        });
        
        // Add buffer only for height (half viewport height)
        const bufferHeight = window.innerHeight / 2;
        
        // Get visible viewport dimensions (accounts for scrollbar presence)
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight;
        
        // For width: use exactly the content width or viewport width, whichever is larger
        // For height: add buffer for more natural vertical scrolling
        const newWidth = Math.max(maxRight, viewportWidth);
        const newHeight = Math.max(maxBottom + bufferHeight, viewportHeight);
        
        // Apply the new dimensions to relevant elements
        this.canvas.style.width = `${newWidth}px`;
        this.canvas.style.height = `${newHeight}px`;
        
        this.svg.style.width = `${newWidth}px`;
        this.svg.style.height = `${newHeight}px`;
        
        this.boxContainer.style.width = `${newWidth}px`;
        this.boxContainer.style.height = `${newHeight}px`;
    }

    updateAllBoxSizes() {
        // Recalculate and update the size of all boxes
        this.boxes.forEach(box => {
            // Force box to recalculate its size with current text scale
            box.renderMarkdown();
        });
        
        // Update all connections after box sizes change
        this.connections.forEach(connection => {
            connection.update();
        });
        
        // Update canvas size to accommodate new box sizes
        this.updateCanvasSize();
    }
    
    initTheme() {
        // Check for saved theme preference
        const darkMode = localStorage.getItem('darkMode') === 'true';
        if (darkMode) {
            document.body.classList.add('dark-mode');
        }
    }
    
    setupEventListeners() { 
        this.canvas.addEventListener('dblclick', this.handleCanvasDoubleClick.bind(this)); 
        this.canvas.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this)); 
        
        // Use separate event handlers for better scroll position management
        document.addEventListener('mousemove', (e) => {
            // Handle box dragging
            if (this.draggingBox) { 
                const dx = e.clientX - this.dragStartPos.x; 
                const dy = e.clientY - this.dragStartPos.y; 
                const nCx = this.dragBoxStartCenter.cx + dx; 
                const nCy = this.dragBoxStartCenter.cy + dy; 
                this.draggingBox.setCenterPosition(nCx, nCy); 
                this.updateConnectionsForBox(this.draggingBox); 
            } 
            // Handle connection preview drawing
            else if (this.connectionStartBox) { 
                const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
                
                // Get scroll position for accurate coordinates
                const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                
                // Get mouse position relative to canvas with scroll offsets
                const r = this.svg.getBoundingClientRect(); 
                const mX = e.clientX - r.left + scrollX; 
                const mY = e.clientY - r.top + scrollY; 
                
                this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
            }
        }); 
        
        document.addEventListener('mouseup', (e) => {
            if (this.draggingBox) { 
                this.draggingBox = null; 
                this.saveCurrentProject();
                this.updateCanvasSize(); // Update canvas size after drag
            } else if (this.connectionStartBox && e.button === 2) { 
                e.preventDefault(); 
                this.previewPath.setAttribute('display', 'none'); 
                
                // Get correct element at mouse position
                let eTE = document.elementFromPoint(e.clientX, e.clientY); 
                let eBE = eTE?.closest('.box-default'); 
                
                if (eBE) { 
                    const eB = this.boxes.get(eBE.dataset.id); 
                    if (eB && eB !== this.connectionStartBox) { 
                        // Create or update connection between boxes
                        const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                        if (connection) {
                            this.saveCurrentProject();
                        }
                    } else if (eB === this.connectionStartBox) {
                        // Change width if right-click and release on the same box
                        eB.toggleWidthType();
                        this.saveCurrentProject();
                    }
                } 
                
                this.connectionStartBox = null; 
                this.rightClickBox = null;
            } 
            
            if (e.button === 0) { 
                this.draggingBox = null; 
            } 
        });

        document.addEventListener('keydown', this.handleKeyDown.bind(this)); 
        document.addEventListener('click', this.handleGlobalClick.bind(this), true); 
        document.addEventListener('contextmenu', e => e.preventDefault()); 

        // Handle mouse leaving the window
        document.addEventListener('mouseleave', () => { 
            if (this.connectionStartBox) { 
                this.previewPath.setAttribute('display', 'none'); 
                this.connectionStartBox = null; 
            } 
        }); 

        // Add scroll event handling to ensure connections update during scrolling
        window.addEventListener('scroll', () => {
            // Update all connections when scrolling to ensure they remain accurate
            this.connections.forEach(connection => {
                connection.update();
            });
        });
    }

    setupThemeToggle() {
        const toggleBtn = document.getElementById('theme-toggle');
        
        toggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            
            // Store theme preference in localStorage
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
            
            // Update all box and connection themes
            this.updateAllThemes();
        });
    }

    // Update themes for all boxes and connections when theme mode changes
    updateAllThemes() {
        // Update boxes
        this.boxes.forEach(box => {
            box.applyColorTheme();
        });
        
        // Update connections
        this.connections.forEach(conn => {
            conn.applyTheme();
        });
    }

    handleCanvasDoubleClick(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            const rect = this.boxContainer.getBoundingClientRect(); 
            const cx = e.clientX - rect.left; 
            const cy = e.clientY - rect.top; 
            if (cx >= 0 && cy >= 0 && cx <= rect.width && cy <= rect.height) { 
                this.createBox(cx, cy); 
            } 
        } 
    }

    handleCanvasMouseDown(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            // No-op for now - we don't have selection state anymore
        } 
    }

    startDragging(box, e) {
        if (!box || box.isEditing) return;
        
        this.draggingBox = box;
        this.dragStartPos = { x: e.clientX, y: e.clientY };
        this.dragBoxStartCenter = { cx: box.data.cx, cy: box.data.cy };
    }

    handleBoxRightMouseDown(e, box) {
        if (!box || box.isEditing) return;
        
        e.preventDefault();
        
        // Right-click for starting connection
        this.connectionStartBox = box;
        const sC = { cx: box.data.cx, cy: box.data.cy };
        const r = this.svg.getBoundingClientRect();
        const mX = e.clientX - r.left;
        const mY = e.clientY - r.top;
        this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`);
        this.previewPath.setAttribute('display', 'block');
        
        // Also toggle width if mouse up on the same box
        this.rightClickBox = box;
    }

    handleMouseMove(e) { 
        if (this.draggingBox) { 
            const dx = e.clientX - this.dragStartPos.x; 
            const dy = e.clientY - this.dragStartPos.y; 
            const nCx = this.dragBoxStartCenter.cx + dx; 
            const nCy = this.dragBoxStartCenter.cy + dy; 
            this.draggingBox.setCenterPosition(nCx, nCy); 
            this.updateConnectionsForBox(this.draggingBox); 
        } else if (this.connectionStartBox) { 
            const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
            
            // Calculate the correct mouse position with scroll offsets
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            const r = this.svg.getBoundingClientRect(); 
            const mX = e.clientX - r.left + scrollX; 
            const mY = e.clientY - r.top + scrollY; 
            
            this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
        } 
    }

    handleMouseUp(e) { 
        if (this.draggingBox) { 
            this.draggingBox = null; 
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after drag
        } else if (this.connectionStartBox && e.button === 2) { 
            e.preventDefault(); 
            this.previewPath.setAttribute('display', 'none'); 
            let eTE = document.elementFromPoint(e.clientX, e.clientY); 
            let eBE = eTE?.closest('.box-default'); 
            
            if (eBE) { 
                const eB = this.boxes.get(eBE.dataset.id); 
                if (eB && eB !== this.connectionStartBox) { 
                    // Create or update connection between boxes
                    const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                    if (connection) {
                        this.saveCurrentProject();
                    }
                } else if (eB === this.connectionStartBox) {
                    // Change width if right-click and release on the same box
                    eB.toggleWidthType();
                    this.saveCurrentProject();
                }
            } 
            
            this.connectionStartBox = null; 
            this.rightClickBox = null;
        } 
        
        if (e.button === 0) { 
            this.draggingBox = null; 
        } 
    }

    handleGlobalClick(e) { 
        const targetTextarea = e.target.closest('textarea'); 
        
        if (!targetTextarea) { 
            // Check if any box is in edit mode
            let editingBox = false;
            this.boxes.forEach(box => { 
                if (box.isEditing) { 
                    editingBox = true; 
                    box.commitEdit(); 
                } 
            }); 
        } 
    }

    handleKeyDown(e) { 
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return; 
        
        // Handle Delete/Backspace for removing hovered element
        if ((e.key === 'Delete' || e.key === 'Backspace') && this.hoveredElement) {
            // Delete the hovered element
            if (this.hoveredElement instanceof Box) {
                this.deleteBox(this.hoveredElement);
            } else if (this.hoveredElement instanceof Connection) {
                this.deleteConnection(this.hoveredElement);
            }
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after deletion
        }
        
        // Handle 'c' key for changing color of hovered element
        if (e.key === 'c' && this.hoveredElement) {
            if (this.hoveredElement instanceof Box || this.hoveredElement instanceof Connection) {
                this.hoveredElement.cycleColorTheme();
                this.saveCurrentProject();
            }
        }
        
        // Handle 's' key for changing width of hovered box (NOT connections)
        if (e.key === 's' && this.hoveredElement instanceof Box) {
            this.hoveredElement.toggleWidthType();
            this.saveCurrentProject();
        }
    }

    createBox(cx, cy) { 
        const id = `box-${this.nextBoxId++}`; 
        const bD = { 
            id: id, 
            cx: cx, 
            cy: cy, 
            width: INITIAL_BOX_WIDTH, 
            height: INITIAL_BOX_HEIGHT, 
            widthType: WIDTH_TYPES.MEDIUM,
            themeKey: 'default',
            markdown: '# Title\nUse **markdown** for formatting'
        }; 
        const b = new Box(bD, this); 
        this.boxContainer.appendChild(b.element); 
        this.boxes.set(id, b); 
        this.updateHelperText(); 
        b.startEditing(); 
        this.updateCanvasSize(); // Update canvas size after adding a box
        return b; 
    }

    //// Create a new connection or update existing one to be bidirectional
    createOrUpdateConnection(startBox, endBox) { 
        if (!startBox || !endBox || startBox === endBox) return null; 
        
        // Check if there's already a connection in the opposite direction
        let existingConnection = null;
        this.connections.forEach(conn => {
            if (conn.startBox === endBox && conn.endBox === startBox) {
                existingConnection = conn;
            }
        });
        
        // If there's an existing connection, make it bidirectional
        if (existingConnection) {
            existingConnection.data.bidirectional = true;
            existingConnection.element.setAttribute('marker-start', 'url(#arrowhead-start)');
            // No longer changing the style when making bidirectional
            existingConnection.update();
            return existingConnection;
        }
        
        // Otherwise create a new connection
        const id = `conn-${this.nextConnectionId++}`; 
        const cD = { 
            id: id, 
            startBoxId: startBox.data.id, 
            endBoxId: endBox.data.id,
            themeKey: 'default',
            pattern: CONNECTION_PATTERNS.NORMAL,
            thickness: CONNECTION_THICKNESSES.NORMAL,
            bidirectional: false
        }; 
        const conn = new Connection(cD, startBox, endBox, this); 
        this.connections.set(id, conn); 
        
        // Add both hitbox and visible connection to SVG
        this.svg.appendChild(conn.hitboxElement);
        this.svg.appendChild(conn.element);
        
        // Apply theme and styles
        conn.applyTheme();
        conn.applyPattern();
        conn.applyThickness();
        
        return conn; 
    }

    deleteBox(boxInstance) { 
        if (!boxInstance) return; 
        const bId = boxInstance.data.id; 
        const cTR = []; 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) cTR.push(c); 
        }); 
        cTR.forEach(c => this.deleteConnection(c)); 
        boxInstance.element.remove(); 
        this.boxes.delete(bId); 
        this.updateHelperText(); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === boxInstance) {
            this.hoveredElement = null;
        }
        
        // Update canvas size after deletion
        this.updateCanvasSize();
    }

    deleteConnection(connInstance) { 
        if (!connInstance) return; 
        
        // Clean up all connection elements
        connInstance.cleanup();
        
        const cId = connInstance.data.id; 
        this.connections.delete(cId); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === connInstance) {
            this.hoveredElement = null;
        }
    }

    updateConnectionsForBox(boxInstance) { 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) c.update(); 
        }); 
    }

    updateHelperText() { 
        this.helperText.style.display = this.boxes.size === 0 ? 'block' : 'none'; 
    }

    // Clear the current diagram
    clearDiagram() {
        // Remove all connections
        this.connections.forEach(conn => {
            conn.cleanup();
        });
        this.connections.clear();
        
        // Remove all boxes
        this.boxes.forEach(box => {
            box.element.remove();
        });
        this.boxes.clear();
        
        // Reset counters
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Export the entire diagram data
    exportData() {
        const boxesData = [];
        this.boxes.forEach(box => {
            boxesData.push(box.exportData());
        });
        
        const connectionsData = [];
        this.connections.forEach(conn => {
            connectionsData.push(conn.exportData());
        });
        
        return {
            boxes: boxesData,
            connections: connectionsData,
            nextBoxId: this.nextBoxId,
            nextConnectionId: this.nextConnectionId
        };
    }

    // Load diagram from exported data
    loadFromProjectData(data) {
        // Clear current diagram
        this.clearDiagram();
        
        // Set counters
        this.nextBoxId = data.nextBoxId || 1;
        this.nextConnectionId = data.nextConnectionId || 1;
        
        // Create boxes first
        const boxMap = new Map(); // Map original IDs to new box instances
        
        if (data.boxes && Array.isArray(data.boxes)) {
            data.boxes.forEach(boxData => {
                const box = new Box(boxData, this);
                this.boxContainer.appendChild(box.element);
                this.boxes.set(boxData.id, box);
                boxMap.set(boxData.id, box);
            });
        }
        
        // Then create connections
        if (data.connections && Array.isArray(data.connections)) {
            data.connections.forEach(connData => {
                const startBox = boxMap.get(connData.startBoxId);
                const endBox = boxMap.get(connData.endBoxId);
                
                if (startBox && endBox) {
                    const conn = new Connection(connData, startBox, endBox, this);
                    this.connections.set(connData.id, conn);
                    
                    // Add both hitbox and visible path to SVG
                    this.svg.appendChild(conn.hitboxElement);
                    this.svg.appendChild(conn.element);
                    
                    conn.update();
                }
            });
        }
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Save the current project through the project manager
    saveCurrentProject() {
        if (this.projectManager) {
            this.projectManager.saveCurrentProject();
        }
    }
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    // Configure marked.js for better rendering
    if (window.marked) {
        marked.setOptions({
            gfm: true,       // GitHub flavored markdown
            breaks: true,    // Add <br> on single line breaks
            headerIds: false,
            mangle: false    // Don't escape HTML
        });
    }
    
    window.diagramManager = new DiagramManager();
    
    // Add example content to the first box if needed
    setTimeout(() => {
        if (window.diagramManager.boxes.size === 0) {
            const exampleBox = window.diagramManager.createBox(window.innerWidth / 2, window.innerHeight * 0.3);
            exampleBox.data.markdown = `# Welcome to FlowChart

This is an enhanced diagram tool with **improved markdown** support.

## Features:
* Ordered and unordered lists
* Tables support
* Adjustable text size

1. Double-click anywhere to add boxes
2. Right-drag to connect boxes
3. Press 'c' to change colors
4. Press 's' to change sizes

### Example Table:
| Feature | Description |
|---------|-------------|
| Lists | Both ordered and unordered |
| Tables | Markdown table support |
| Text Size | Adjustable text scaling |`;
            exampleBox.commitEdit();
        }
    }, 100);
});
</script>

</body>
</html>
