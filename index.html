<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* --- Color Palette Variables --- */
        :root {
            /* --- Base Colors --- */
            /* Gray/Default Scale */
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            
            /* Red Scale */
            --red-50: #FEEBE8;
            --red-100: #FEDFDB;
            --red-200: #FDC7C1;
            --red-300: #FCAFA6;
            --red-400: #FB877A;
            --red-500: #FA5D4B;
            --red-600: #F93822;
            --red-700: #BA2A19;
            --red-800: #881E12;
            --red-900: #63160D;
            --red-950: #3E0E08;

            /* Green Scale */
            --green-50: #F1F8E8;
            --green-100: #E9F4DB;
            --green-200: #D9ECC0;
            --green-300: #C9E5A5;
            --green-400: #AED879;
            --green-500: #91CA4A;
            --green-600: #78BE20;
            --green-700: #5A8E18;
            --green-800: #426811;
            --green-900: #304C0C;
            --green-950: #1E2F08;

            /* Blue Scale */
            --blue-50: #E5F0FA;
            --blue-100: #D6E8F7;
            --blue-200: #B7D7F1;
            --blue-300: #99C6EB;
            --blue-400: #66AAE1;
            --blue-500: #308CD7;
            --blue-600: #0072CE;
            --blue-700: #00559A;
            --blue-800: #003E71;
            --blue-900: #002D52;
            --blue-950: #001C33;
            

            /* Purple Scale */
            --purple-50: #F3EFFA;
            --purple-100: #EDE6F7;
            --purple-200: #DFD3F1;
            --purple-300: #D2C0EB;
            --purple-400: #BCA1E1;
            --purple-500: #A580D6;
            --purple-600: #9063CD;
            --purple-700: #6C4A99;
            --purple-800: #4F3670;
            --purple-900: #392752;
            --purple-950: #241833;

            
            /* Yellow Scale */
            --yellow-50: #FEFBE5;
            --yellow-100: #FEF9D6;
            --yellow-200: #FEF5B7;
            --yellow-300: #FEF199;
            --yellow-400: #FEEA66;
            --yellow-500: #FEE330;
            --yellow-600: #FEDD00;
            --yellow-700: #BEA500;
            --yellow-800: #8B7900;
            --yellow-900: #655800;
            --yellow-950: #3F3700;

            /* Amber/Orange Scale */
            --amber-50: #FDF6E5;
            --amber-100: #FCF1D6;
            --amber-200: #FBE6B7;
            --amber-300: #F9DC99;
            --amber-400: #F7CB66;
            --amber-500: #F4B930;
            --amber-600: #F2A900;
            --amber-700: #B57E00;
            --amber-800: #855C00;
            --amber-900: #604300;
            --amber-950: #3C2A00;
            
            /* Black, White, and Transparent */
            --black: #000000;
            --white: #ffffff;
            --transparent-black-5: rgba(0, 0, 0, 0.05);
            --transparent-black-8: rgba(0, 0, 0, 0.08);
            --transparent-black-10: rgba(0, 0, 0, 0.1);
            --transparent-black-12: rgba(0, 0, 0, 0.12);
            --transparent-black-15: rgba(0, 0, 0, 0.15);
            --transparent-black-20: rgba(0, 0, 0, 0.2);
            --transparent-black-30: rgba(0, 0, 0, 0.3);
            --transparent-black-35: rgba(0, 0, 0, 0.35);
            --transparent-white-5: rgba(255, 255, 255, 0.05);
            --transparent-white-7: rgba(255, 255, 255, 0.07);
            --transparent-white-10: rgba(255, 255, 255, 0.1);
            
            /* --- Theme Variables (Light Mode) --- */
            --bg-primary: var(--gray-100);
            --bg-secondary: var(--white);
            --text-primary: var(--gray-900);
            --text-secondary: var(--gray-600);
            --text-muted: var(--gray-500);
            --border-color: var(--gray-300);
            --shadow-color: var(--transparent-black-10);
            --box-shadow: 0 2px 5px var(--transparent-black-8);
            --box-shadow-hover: 0 8px 15px var(--transparent-black-12);
            --font-scale: 1; /* Default font scale */
            
            /* Scrollbar Colors - Light Mode */
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-thumb-hover: #a1a1a1;
            
            /* Table Variables - Light Mode */
            --table-header-bg: var(--gray-600);
            --table-header-text: var(--white);
            --table-row-odd: transparent;
            --table-row-even: var(--transparent-black-5);
            --table-border: var(--border-color);
            
            /* Theme Colors - Light Mode */
            --theme-default-bg: var(--white);
            --theme-default-text: var(--gray-800);
            --theme-default-border: var(--gray-500);
            --theme-default-stroke: var(--gray-600);
            
            --theme-red-bg: var(--red-100);
            --theme-red-text: var(--red-900);
            --theme-red-border: var(--red-500);
            --theme-red-stroke: var(--red-500);
            
            --theme-green-bg: var(--green-100);
            --theme-green-text: var(--green-900);
            --theme-green-border: var(--green-500);
            --theme-green-stroke: var(--green-500);
            
            --theme-blue-bg: var(--blue-100);
            --theme-blue-text: var(--blue-900);
            --theme-blue-border: var(--blue-500);
            --theme-blue-stroke: var(--blue-500);
            
            --theme-purple-bg: var(--purple-100);
            --theme-purple-text: var(--purple-800);
            --theme-purple-border: var(--purple-500);
            --theme-purple-stroke: var(--purple-500);
            
            --theme-yellow-bg: var(--yellow-100);
            --theme-yellow-text: var(--yellow-900);
            --theme-yellow-border: var(--amber-500);
            --theme-yellow-stroke: var(--amber-500);
            
            --theme-grey-bg: var(--gray-200);
            --theme-grey-text: var(--gray-900);
            --theme-grey-border: var(--gray-900);
            --theme-grey-stroke: var(--gray-900);
            
            /* Table Header Theming - Light Mode */
            --table-header-default-bg: var(--gray-500);
            --table-header-default-text: var(--white);
            --table-header-default-border: var(--gray-500);
            
            --table-header-red-bg: var(--red-400);
            --table-header-red-text: var(--red-900);
            --table-header-red-border: var(--red-500);
            
            --table-header-green-bg: var(--green-400);
            --table-header-green-text: var(--green-950);
            --table-header-green-border: var(--green-500);
            
            --table-header-blue-bg: var(--blue-400);
            --table-header-blue-text: var(--blue-900);
            --table-header-blue-border: var(--blue-500);
            
            --table-header-purple-bg: var(--purple-400);
            --table-header-purple-text: var(--purple-950);
            --table-header-purple-border: var(--purple-500);
            
            --table-header-yellow-bg: var(--amber-400);
            --table-header-yellow-text: var(--yellow-950);
            --table-header-yellow-border: var(--amber-500);
            
            --table-header-grey-bg: var(--gray-600);
            --table-header-grey-text: var(--gray-50);
            --table-header-grey-border: var(--gray-500);
            
            /* Icon Colors */
            --sun-icon-color: var(--amber-500);
            --moon-icon-color: var(--blue-600);
            
            /* Link Colors */
            --link-color: var(--purple-500);
        }

        .dark-mode {
            /* --- Theme Variables (Dark Mode) --- */
            --bg-primary: var(--gray-800);
            --bg-secondary: var(--gray-700);
            --text-primary: var(--gray-50);
            --text-secondary: var(--gray-300);
            --text-muted: var(--gray-400);
            --border-color: var(--gray-600);
            --shadow-color: var(--transparent-black-30);
            --box-shadow: 0 2px 5px var(--transparent-black-20);
            --box-shadow-hover: 0 8px 15px var(--transparent-black-35);
            
            /* Scrollbar Colors - Dark Mode */
            --scrollbar-track: var(--gray-700);
            --scrollbar-thumb: var(--gray-600);
            --scrollbar-thumb-hover: var(--gray-500);
            
            /* Table Variables - Dark Mode */
            --table-header-bg: var(--purple-600);
            --table-header-text: var(--white);
            --table-row-odd: transparent;
            --table-row-even: var(--transparent-white-5);
            --table-border: var(--border-color);
            
            /* Theme Colors - Dark Mode */
            --theme-default-bg: var(--gray-700);
            --theme-default-text: var(--gray-50);
            --theme-default-border: var(--gray-400);
            --theme-default-stroke: var(--gray-400);
            
            --theme-red-bg: var(--red-900);
            --theme-red-text: var(--red-200);
            --theme-red-border: var(--red-500);
            --theme-red-stroke: var(--red-300);
            
            --theme-green-bg: var(--green-900);
            --theme-green-text: var(--green-200);
            --theme-green-border: var(--green-500);
            --theme-green-stroke: var(--green-400);
            
            --theme-blue-bg: var(--blue-900);
            --theme-blue-text: var(--blue-200);
            --theme-blue-border: var(--blue-500);
            --theme-blue-stroke: var(--blue-400);
            
            --theme-purple-bg: var(--purple-800);
            --theme-purple-text: var(--purple-200);
            --theme-purple-border: var(--purple-500);
            --theme-purple-stroke: var(--purple-400);
            
            --theme-yellow-bg: var(--yellow-900);
            --theme-yellow-text: var(--yellow-200);
            --theme-yellow-border: var(--amber-500);
            --theme-yellow-stroke: var(--amber-400);
            
            --theme-grey-bg: var(--gray-800);
            --theme-grey-text: var(--gray-200);
            --theme-grey-border: var(--gray-400);
            --theme-grey-stroke: var(--gray-400);
            
            /* Table Header Theming - Dark Mode */
            --table-header-default-bg: var(--gray-600);
            --table-header-default-text: var(--gray-100);
            --table-header-default-border: var(--gray-500);
            
            --table-header-red-bg: var(--red-700);
            --table-header-red-text: var(--red-100);
            --table-header-red-border: var(--red-500);
            
            --table-header-green-bg: var(--green-700);
            --table-header-green-text: var(--green-100);
            --table-header-green-border: var(--green-500);
            
            --table-header-blue-bg: var(--blue-700);
            --table-header-blue-text: var(--blue-100);
            --table-header-blue-border: var(--blue-500);
            
            --table-header-purple-bg: var(--purple-700);
            --table-header-purple-text: var(--purple-100);
            --table-header-purple-border: var(--purple-500);
            
            --table-header-yellow-bg: var(--amber-700);
            --table-header-yellow-text: var(--yellow-100);
            --table-header-yellow-border: var(--amber-500);
            
            --table-header-grey-bg: var(--gray-800);
            --table-header-grey-text: var(--gray-50);
            --table-header-grey-border: var(--gray-600);
        }

        #canvas {
            overflow: visible;
        }
        
        #connections {
            overflow: visible;
        }
        
        #box-container {
            overflow: visible;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: auto;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        /* Scrollbar width */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        /* Scrollbar track */
        ::-webkit-scrollbar-track {
            background-color: var(--scrollbar-track);
            border-radius: 6px;
        }
        
        /* Scrollbar thumb */
        ::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--scrollbar-thumb-hover);
        }
        
        /* Scrollbar corner */
        ::-webkit-scrollbar-corner {
            background-color: var(--scrollbar-track);
        }
        
        /* Firefox scrollbar styling */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }


        /* --- Theme Toggle Icons --- */
        .theme-toggle {
            position: relative;
        }

        .theme-toggle svg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Hide both icons initially */
        #sun-icon, #moon-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6);
            display: block; /* Ensure SVGs are always in layout */
        }

        /* Show active icon based on theme */
        body:not(.dark-mode) #sun-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        body.dark-mode #moon-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Hover animations */
        body:not(.dark-mode) .theme-toggle:hover #sun-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6) rotate(45deg);
        }

        body:not(.dark-mode) .theme-toggle:hover #moon-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        body.dark-mode .theme-toggle:hover #moon-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6) rotate(-45deg);
        }

        body.dark-mode .theme-toggle:hover #sun-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Sun icon styles */
        #sun-icon {
            fill: var(--sun-icon-color);
            color: var(--sun-icon-color);
        }

        /* Moon icon styles */
        #moon-icon {
            fill: var(--moon-icon-color);
            color: var(--moon-icon-color);
        }

        /* --- Project Title --- */
        #project-title {
            color: var(--text-muted);
            font-weight: 300;
            letter-spacing: 0.05em;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* --- Base Setup --- */
        html { height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

        /* --- SVG Connection Styles --- */
        .connection-path { 
            stroke-width: 2; 
            fill: none; 
            cursor: pointer; 
            transition: stroke 0.2s ease, stroke-width 0.2s ease, opacity 0.2s ease;
            pointer-events: none;
        }

        /* Improved hitbox for all connections */
        .connection-hitbox {
            stroke-width: 12; /* Wide hit area for easier interaction */
            stroke: transparent;
            fill: none;
            cursor: pointer;
            pointer-events: stroke;
        }

        .connection-path:hover { 
            opacity: 0.85; 
            filter: drop-shadow(0 0 2px var(--transparent-black-15));
        }

        /* Pattern styles */
        .connection-pattern-normal { stroke-dasharray: none; }
        .connection-pattern-dashed { stroke-dasharray: 10, 5; }
        .connection-pattern-dotted { stroke-dasharray: 2, 4; }

        /* Thickness styles */
        .connection-thickness-thin { stroke-width: 1; }
        .connection-thickness-normal { stroke-width: 2; }
        .connection-thickness-bold { stroke-width: 4; }

        /* --- Arrow hotspot styles --- */
        .arrow-hotspot {
            fill: transparent;
            stroke: transparent;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        .arrow-hotspot:hover {
            fill: var(--transparent-black-5);
        }

        /* --- Custom box styles --- */
        .box-default {
            border: 1.5px solid var(--border-color);
            box-shadow: var(--box-shadow);
            transform: translateY(0);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.3s ease, border-color 0.3s ease;
        }

        .box-default:hover {
            box-shadow: var(--box-shadow-hover);
            transform: translateY(-2px);
        }

        /* --- Markdown styling (enhanced) --- */
        .markdown-content { 
            font-size: calc(14px * var(--font-scale)); 
            line-height: 1.5; 
            word-wrap: break-word; 
            color: var(--text-primary); 
        }
        .markdown-content h1 { 
            font-size: calc(1.5em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.5em; 
            margin-bottom: 0.3em; 
        }
        .markdown-content h2 { 
            font-size: calc(1.3em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.4em; 
            margin-bottom: 0.2em; 
        }
        .markdown-content h3 { 
            font-size: calc(1.1em * var(--font-scale)); 
            font-weight: bold; 
            margin-top: 0.3em; 
            margin-bottom: 0.1em; 
        }
        .markdown-content p { margin-bottom: 0.5em; }
        .markdown-content ul, .markdown-content ol { 
            padding-left: 1.5em; 
            margin-bottom: 0.5em; 
            list-style-position: outside; 
        }
        .markdown-content ul { list-style-type: disc; }
        .markdown-content ol { list-style-type: decimal; }
        .markdown-content li { margin-bottom: 0.2em; }
        .markdown-content li > ul, .markdown-content li > ol { margin-top: 0.2em; }
        .markdown-content code { 
            background-color: var(--transparent-black-5); 
            padding: 0.1em 0.2em; 
            border-radius: 0.2em; 
            font-family: monospace; 
            font-size: calc(0.9em * var(--font-scale));
        }
        .markdown-content hr { margin: 0.5em 0; border: none; border-top: 1px solid var(--border-color); }
        .markdown-content a { color: var(--link-color); text-decoration: underline; }
        
        /* Table base styling */
        .markdown-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; font-size: calc(0.9em * var(--font-scale)); box-shadow: 0 1px 3px var(--transparent-black-10); border-radius: 4px; overflow: hidden; }
        .markdown-content table td { border: 1px solid var(--border-color); padding: 0.4em 0.7em; }
        .markdown-content table tr:nth-child(odd) { background-color: transparent; }
        .markdown-content table tr:nth-child(even) { background-color: var(--table-row-even); }
        .dark-mode .markdown-content table tr:nth-child(even) { background-color: var(--transparent-white-7); }
        .markdown-content table tr:hover { background-color: var(--transparent-black-8); }
        .dark-mode .markdown-content table tr:hover { background-color: var(--transparent-white-10); }
        .markdown-content table th { border: 1px solid var(--border-color); padding: 0.5em 0.7em; text-align: left; font-weight: bold; }

        /* Theme-specific table header styling for light mode */
        div[data-theme="default"] .markdown-content table th { 
            background-color: var(--table-header-default-bg); 
            color: var(--table-header-default-text); 
            border-color: var(--table-header-default-border); 
        }
        div[data-theme="red"] .markdown-content table th { 
            background-color: var(--table-header-red-bg); 
            color: var(--table-header-red-text); 
            border-color: var(--table-header-red-border); 
        }
        div[data-theme="green"] .markdown-content table th { 
            background-color: var(--table-header-green-bg); 
            color: var(--table-header-green-text); 
            border-color: var(--table-header-green-border); 
        }
        div[data-theme="blue"] .markdown-content table th { 
            background-color: var(--table-header-blue-bg); 
            color: var(--table-header-blue-text); 
            border-color: var(--table-header-blue-border); 
        }
        div[data-theme="purple"] .markdown-content table th { 
            background-color: var(--table-header-purple-bg); 
            color: var(--table-header-purple-text); 
            border-color: var(--table-header-purple-border); 
        }
        div[data-theme="yellow"] .markdown-content table th { 
            background-color: var(--table-header-yellow-bg); 
            color: var(--table-header-yellow-text); 
            border-color: var(--table-header-yellow-border); 
        }
        div[data-theme="grey"] .markdown-content table th { 
            background-color: var(--table-header-grey-bg); 
            color: var(--table-header-grey-text); 
            border-color: var(--table-header-grey-border); 
        }

        /* Theme-specific table header styling for dark mode */
        .dark-mode div[data-theme="default"] .markdown-content table th { 
            background-color: var(--table-header-default-bg); 
            color: var(--table-header-default-text); 
            border-color: var(--table-header-default-border); 
        }
        .dark-mode div[data-theme="red"] .markdown-content table th { 
            background-color: var(--table-header-red-bg); 
            color: var(--table-header-red-text); 
            border-color: var(--table-header-red-border); 
        }
        .dark-mode div[data-theme="green"] .markdown-content table th { 
            background-color: var(--table-header-green-bg); 
            color: var(--table-header-green-text); 
            border-color: var(--table-header-green-border); 
        }
        .dark-mode div[data-theme="blue"] .markdown-content table th { 
            background-color: var(--table-header-blue-bg); 
            color: var(--table-header-blue-text); 
            border-color: var(--table-header-blue-border); 
        }
        .dark-mode div[data-theme="purple"] .markdown-content table th { 
            background-color: var(--table-header-purple-bg); 
            color: var(--table-header-purple-text); 
            border-color: var(--table-header-purple-border); 
        }
        .dark-mode div[data-theme="yellow"] .markdown-content table th { 
            background-color: var(--table-header-yellow-bg); 
            color: var(--table-header-yellow-text); 
            border-color: var(--table-header-yellow-border); 
        }
        .dark-mode div[data-theme="grey"] .markdown-content table th { 
            background-color: var(--table-header-grey-bg); 
            color: var(--table-header-grey-text); 
            border-color: var(--table-header-grey-border); 
        }
 
        /* --- Textarea styling --- */
        .edit-textarea { 
            width: 100%; 
            height: 100%; 
            box-sizing: border-box; 
            padding: 0.5rem; 
            border: none; 
            font-family: inherit; 
            font-size: calc(14px * var(--font-scale)); 
            line-height: 1.5; 
            resize: none; 
            overflow: auto; 
            background-color: transparent;
            color: var(--text-primary);
        }
        .edit-textarea:focus { outline: none; }

        /* --- Transitions and Animations --- */
        .box-transition { transition: width 0.2s ease, height 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; }
        #preview-connection { stroke-dasharray: 5, 5; animation: dash 15s linear infinite; stroke: var(--text-secondary); }
        @keyframes dash { to { stroke-dashoffset: -1000; } }
        
        /* Theme-specific box/text classes for light mode */
        .light-default-bg { background-color: var(--theme-default-bg); }
        .light-default-text { color: var(--theme-default-text); }
        .light-default-border { border-color: var(--theme-default-border); }

        .light-red-bg { background-color: var(--theme-red-bg); }
        .light-red-text { color: var(--theme-red-text); }
        .light-red-border { border-color: var(--theme-red-border); }

        .light-green-bg { background-color: var(--theme-green-bg); }
        .light-green-text { color: var(--theme-green-text); }
        .light-green-border { border-color: var(--theme-green-border); }

        .light-blue-bg { background-color: var(--theme-blue-bg); }
        .light-blue-text { color: var(--theme-blue-text); }
        .light-blue-border { border-color: var(--theme-blue-border); }

        .light-purple-bg { background-color: var(--theme-purple-bg); }
        .light-purple-text { color: var(--theme-purple-text); }
        .light-purple-border { border-color: var(--theme-purple-border); }

        .light-yellow-bg { background-color: var(--theme-yellow-bg); }
        .light-yellow-text { color: var(--theme-yellow-text); }
        .light-yellow-border { border-color: var(--theme-yellow-border); }

        .light-grey-bg { background-color: var(--theme-grey-bg); }
        .light-grey-text { color: var(--theme-grey-text); }
        .light-grey-border { border-color: var(--theme-grey-border); }

        /* Theme-specific box/text classes for dark mode */
        .dark-default-bg { background-color: var(--theme-default-bg); }
        .dark-default-text { color: var(--theme-default-text); }
        .dark-default-border { border-color: var(--theme-default-border); }

        .dark-red-bg { background-color: var(--theme-red-bg); }
        .dark-red-text { color: var(--theme-red-text); }
        .dark-red-border { border-color: var(--theme-red-border); }

        .dark-green-bg { background-color: var(--theme-green-bg); }
        .dark-green-text { color: var(--theme-green-text); }
        .dark-green-border { border-color: var(--theme-green-border); }

        .dark-blue-bg { background-color: var(--theme-blue-bg); }
        .dark-blue-text { color: var(--theme-blue-text); }
        .dark-blue-border { border-color: var(--theme-blue-border); }

        .dark-purple-bg { background-color: var(--theme-purple-bg); }
        .dark-purple-text { color: var(--theme-purple-text); }
        .dark-purple-border { border-color: var(--theme-purple-border); }

        .dark-yellow-bg { background-color: var(--theme-yellow-bg); }
        .dark-yellow-text { color: var(--theme-yellow-text); }
        .dark-yellow-border { border-color: var(--theme-yellow-border); }

        .dark-grey-bg { background-color: var(--theme-grey-bg); }
        .dark-grey-text { color: var(--theme-grey-text); }
        .dark-grey-border { border-color: var(--theme-grey-border); }

        /* Modal styles */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }
        
        .modal-content {
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .modal.open .modal-backdrop {
            opacity: 1;
        }
        
        .modal.open .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body class="h-screen m-0 p-0">
    <!-- Project title header -->
    <div id="project-title-container" class="fixed top-5 left-0 w-full text-center pointer-events-none z-0">
        <h1 id="project-title" class="text-3xl tracking-wide"></h1>
    </div>

    <div id="canvas" class="relative w-full cursor-default">
        <svg id="connections" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10" style="overflow: visible;">
            <defs>
                <marker id="arrowhead-end" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="currentColor"/>
                </marker>
                <marker id="arrowhead-start" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                    <polygon points="10 0, 0 3.5, 10 7" fill="currentColor"/>
                </marker>
            </defs>
            <path id="preview-connection" stroke="currentColor" stroke-width="2" fill="none" marker-end="url(#arrowhead-end)" opacity="0.5" display="none" stroke-dasharray="5, 5"/>
        </svg>
        <div id="box-container" class="absolute top-0 left-0 w-full z-20 pointer-events-none"></div>
        <div id="helper-text" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-500 text-lg text-center pointer-events-none select-none z-0">
             Double click anywhere to add a box<br>
             <span class="text-sm">Use Markdown in boxes for formatting</span>
         </div>
    </div>
    
    <!-- Settings Menu (right-click style) -->
    <div id="settings-menu" class="fixed bottom-12 right-2 w-72 rounded-lg shadow-lg z-50 overflow-hidden transition-all duration-200 max-h-[80vh] flex flex-col hidden opacity-0 transform translate-y-2 pointer-events-none" style="background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: 0 5px 15px var(--shadow-color);">
        <div class="px-4 py-3 border-b border-solid" style="border-color: var(--border-color);">
            <div class="flex justify-between items-center">
                <h3 class="text-base font-semibold m-0">Projects</h3>
                <div class="flex items-center">
                    <button id="export-projects-button" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm mr-1" title="Export Projects">
                        <i class="fas fa-file-export"></i>
                    </button>
                    <button id="import-projects-button" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm mr-1" title="Import Projects">
                        <i class="fas fa-file-import"></i>
                    </button>
                    <button id="add-project-toggle" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="px-4 py-3 overflow-y-auto max-h-[50vh]">
            <!-- New project form (hidden by default) -->
            <div id="new-project-form" class="mb-3 hidden overflow-hidden transition-all duration-200 max-h-0">
                <div class="flex items-center mb-2">
                    <input type="text" id="project-name" class="flex-1 p-2 rounded border border-solid mr-2" placeholder="Enter project name"
                        style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                    <button id="commit-new-project" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600">
                        <i class="fas fa-check"></i>
                    </button>
                    <button id="cancel-new-project" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600 ml-1">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            
            <div id="project-list" class="space-y-2">
                <!-- Projects will be loaded here -->
                <div class="text-center text-gray-500 py-3" id="no-projects-message">No projects yet</div>
            </div>
        </div>
        
        <div class="h-px w-full" style="background-color: var(--border-color);"></div>
        
        <div class="px-4 py-3 border-t border-solid" style="border-color: var(--border-color);">
            <div>
                <label class="block mb-1 font-medium" for="text-scale">Text Size</label>
                <div class="flex items-center">
                    <input type="range" id="text-scale" class="w-full mr-2" min="0.8" max="1.5" step="0.1" value="1">
                    <span class="inline-block font-medium" id="text-scale-value">1.0x</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme toggle button with improved icons -->
    <div class="theme-toggle fixed bottom-2.5 right-12 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" id="theme-toggle" title="Toggle dark/light mode">
        <!-- Sun icon (filled, yellow) -->
        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        
        <!-- Moon icon (filled, dark blue) -->
        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
    </div>
    
    <!-- Settings button (gear icon) -->
    <div class="fixed bottom-2.5 right-2.5 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" id="settings-button" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" title="Projects & Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>

<script>
// --- Constants ---
const INITIAL_BOX_WIDTH = 200;
const INITIAL_BOX_HEIGHT = 80;
const LINE_HEIGHT = 23; // Height per line in pixels
const PADDING_HEIGHT = 30; // Additional padding for box height

// Width type constants
const WIDTH_TYPES = { SMALL: 'small', MEDIUM: 'medium', LARGE: 'large' };
const WIDTH_TYPE_VALUES = { [WIDTH_TYPES.SMALL]: 200, [WIDTH_TYPES.MEDIUM]: 350, [WIDTH_TYPES.LARGE]: 500 };

// Separated connection style constants
const CONNECTION_PATTERNS = {
    NORMAL: 'normal',
    DASHED: 'dashed',
    DOTTED: 'dotted'
};

const CONNECTION_THICKNESSES = {
    THIN: 'thin',
    NORMAL: 'normal',
    BOLD: 'bold'
};

// Enhanced color theme configuration with light and dark variants
const COLOR_THEMES = {
    default: {
        name: 'Default',
        light: {
            bg: 'light-default-bg',
            border: 'light-default-border',
            text: 'light-default-text',
            stroke: 'var(--theme-default-stroke)'
        },
        dark: {
            bg: 'dark-default-bg',
            border: 'dark-default-border',
            text: 'dark-default-text',
            stroke: 'var(--theme-default-stroke)'
        }
    },
    red: {
        name: 'Red',
        light: {
            bg: 'light-red-bg',
            border: 'light-red-border',
            text: 'light-red-text',
            stroke: 'var(--theme-red-stroke)'
        },
        dark: {
            bg: 'dark-red-bg',
            border: 'dark-red-border',
            text: 'dark-red-text',
            stroke: 'var(--theme-red-stroke)'
        }
    },
    green: {
        name: 'Green',
        light: {
            bg: 'light-green-bg',
            border: 'light-green-border',
            text: 'light-green-text',
            stroke: 'var(--theme-green-stroke)'
        },
        dark: {
            bg: 'dark-green-bg',
            border: 'dark-green-border',
            text: 'dark-green-text',
            stroke: 'var(--theme-green-stroke)'
        }
    },
    blue: {
        name: 'Blue',
        light: {
            bg: 'light-blue-bg',
            border: 'light-blue-border',
            text: 'light-blue-text',
            stroke: 'var(--theme-blue-stroke)'
        },
        dark: {
            bg: 'dark-blue-bg',
            border: 'dark-blue-border',
            text: 'dark-blue-text',
            stroke: 'var(--theme-blue-stroke)'
        }
    },
    purple: {
        name: 'Purple',
        light: {
            bg: 'light-purple-bg',
            border: 'light-purple-border',
            text: 'light-purple-text',
            stroke: 'var(--theme-purple-stroke)'
        },
        dark: {
            bg: 'dark-purple-bg',
            border: 'dark-purple-border',
            text: 'dark-purple-text',
            stroke: 'var(--theme-purple-stroke)'
        }
    },
    yellow: {
        name: 'Yellow',
        light: {
            bg: 'light-yellow-bg',
            border: 'light-yellow-border',
            text: 'light-yellow-text',
            stroke: 'var(--theme-yellow-stroke)'
        },
        dark: {
            bg: 'dark-yellow-bg',
            border: 'dark-yellow-border',
            text: 'dark-yellow-text',
            stroke: 'var(--theme-yellow-stroke)'
        }
    },
    grey: {
        name: 'Grey',
        light: {
            bg: 'light-grey-bg',
            border: 'light-grey-border',
            text: 'light-grey-text',
            stroke: 'var(--theme-grey-stroke)'
        },
        dark: {
            bg: 'dark-grey-bg',
            border: 'dark-grey-border',
            text: 'dark-grey-text',
            stroke: 'var(--theme-grey-stroke)'
        }
    }
};

// Get all theme keys for cycling
const THEME_KEYS = Object.keys(COLOR_THEMES);

// Define base classes for reuse in JS - using Tailwind utility classes
const BASE_BOX_CLASSES = 'absolute rounded-lg box-default cursor-move no-select py-2 px-3 pointer-events-auto overflow-hidden box-transition';

// Enhanced markdown parser with better support for lists and tables
function simpleMarkdownParser(text) {
    if (!text) return '';
    
    // Store code blocks so they don't get processed
    const codeBlocks = [];
    text = text.replace(/```([\s\S]*?)```/g, function(match) {
        codeBlocks.push(match);
        return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
    });
    
    // Process text
    text = text
        // Headers
        .replace(/### (.*?)(\n|$)/g, '<h3>$1</h3>\n')
        .replace(/## (.*?)(\n|$)/g, '<h2>$1</h2>\n')
        .replace(/# (.*?)(\n|$)/g, '<h1>$1</h1>\n')
        
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        
        // Inline code
        .replace(/`([^`]*)`/g, '<code>$1</code>')
        
        // Horizontal rule
        .replace(/^---+$/gm, '<hr>')
        
        // Tables - this is a simplified implementation
        .replace(/^\|(.+)\|$/gm, function(match, content) {
            // Split the table row into cells
            const cells = content.split('|').map(cell => cell.trim());
            
            // Check if this is a header separator row (contains only dashes and colons)
            if (cells.every(cell => /^:?-+:?$/.test(cell))) {
                return match; // Return unchanged, we'll remove these later
            }
            
            // Create table cells
            const cellsHtml = cells.map(cell => `<td>${cell}</td>`).join('');
            return `<tr>${cellsHtml}</tr>`;
        })
        // Process tables by finding consecutive table rows
        .replace(/(<tr>.*?<\/tr>)\n\|([-:\s|]+)\|\n(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, headerRow, separatorRow, bodyRows) {
            // Convert the header row's cells to <th> instead of <td>
            const tableHeader = headerRow.replace(/<td>(.*?)<\/td>/g, '<th>$1</th>');
            return `<table><thead>${tableHeader}</thead><tbody>${bodyRows}</tbody></table>`;
        })
        // Handle tables without headers
        .replace(/(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, rows) {
            // Only convert to a table if it's not already in a table
            if (!match.includes('<table>')) {
                return `<table><tbody>${rows}</tbody></table>`;
            }
            return match;
        })
        
        // Ordered lists - look for consecutive lines starting with numbers
        .replace(/^(\d+\. .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the number and period, then trim
                const content = item.replace(/^\d+\.\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ol>${listItems}</ol>\n`;
        })
        
        // Unordered lists - handle multiple list markers
        .replace(/^([\*\-\+] .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the list marker, then trim
                const content = item.replace(/^[\*\-\+]\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ul>${listItems}</ul>\n`;
        })
        
        // Paragraphs (lines not already processed)
        .replace(/^([^\n<][^\n]*?)(?:\n|$)/gm, function(match, content) {
            // Don't wrap empty lines in <p> tags
            if (content.trim() === '') return '\n';
            // Don't wrap lines that are likely part of lists or other block elements
            if (/^<\/(ol|ul|table|h[1-6])>/.test(content)) return content + '\n';
            return `<p>${content}</p>\n`;
        })
        
        // Clean up extra newlines
        .replace(/\n+/g, '\n');
    
    // Restore code blocks
    text = text.replace(/__CODE_BLOCK_(\d+)__/g, function(match, index) {
        const code = codeBlocks[parseInt(index)]
            .replace(/```(?:\w+)?\n([\s\S]*?)```/g, '$1')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        return `<pre><code>${code}</code></pre>`;
    });
    
    return text;
}

// Helper to safely remove CSS classes
function safeRemoveClass(element, className) {
    if (element && className && className.trim() !== '') {
        element.classList.remove(className);
    }
}

// --- ImportManager Class ---
class ImportManager {
    constructor(projectManager) {
        this.projectManager = projectManager;
        this.modal = this.createModal();
        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }
    
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'import-projects-modal';
        modal.className = 'fixed inset-0 flex items-center justify-center z-50 hidden modal';
        
        modal.innerHTML = `
            <div class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop" id="import-modal-backdrop"></div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl z-10 w-full max-w-md max-h-[80vh] flex flex-col overflow-hidden modal-content" 
                 style="background-color: var(--bg-secondary); color: var(--text-primary);">
                <div class="px-4 py-3 border-b border-solid flex justify-between items-center" 
                     style="border-color: var(--border-color);">
                    <h3 class="text-lg font-semibold">Import Projects</h3>
                    <button id="close-import-modal" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 flex flex-col">
                    <div class="mb-4">
                        <label class="block mb-2">Select JSON file containing projects:</label>
                        <input type="file" id="import-file-input" accept=".json" class="w-full p-2 border rounded"
                               style="border-color: var(--border-color); background-color: var(--bg-primary);">
                    </div>
                    
                    <div class="mb-4 hidden" id="import-projects-list-container">
                        <label class="block mb-2">Select projects to import:</label>
                        <div id="import-projects-list" class="border rounded p-2 max-h-48 overflow-y-auto"
                             style="border-color: var(--border-color); background-color: var(--bg-primary);">
                            <!-- Project checkboxes will be dynamically added here -->
                        </div>
                    </div>
                </div>
                
                <div class="px-4 py-3 border-t border-solid flex justify-end" 
                     style="border-color: var(--border-color);">
                    <button id="import-selected-projects" class="px-4 py-2 bg-purple-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Import Selected
                    </button>
                </div>
            </div>
        `;
        
        return modal;
    }
    
    setupEventListeners() {
        const modal = this.modal;
        const backdrop = modal.querySelector('#import-modal-backdrop');
        const closeButton = modal.querySelector('#close-import-modal');
        const fileInput = modal.querySelector('#import-file-input');
        const importButton = modal.querySelector('#import-selected-projects');
        
        // Close modal when clicking backdrop or close button
        backdrop.addEventListener('click', () => this.closeModal());
        closeButton.addEventListener('click', () => this.closeModal());
        
        // Handle file selection
        fileInput.addEventListener('change', (e) => this.handleFileSelection(e));
        
        // Handle import button click
        importButton.addEventListener('click', () => this.importSelectedProjects());
    }
    
    openModal() {
        this.modal.classList.remove('hidden');
        setTimeout(() => {
            this.modal.classList.add('open');
        }, 10);
    }
    
    closeModal() {
        const modal = this.modal;
        const fileInput = modal.querySelector('#import-file-input');
        const container = modal.querySelector('#import-projects-list-container');
        
        // Animate out
        modal.classList.remove('open');
        
        // Reset state
        fileInput.value = '';
        container.classList.add('hidden');
        
        // Hide modal after animation
        setTimeout(() => {
            modal.classList.add('hidden');
        }, 300);
    }
    
    handleFileSelection(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const importedData = JSON.parse(event.target.result);
                if (Array.isArray(importedData)) {
                    this.displayImportProjects(importedData);
                } else {
                    alert('Invalid project file format');
                }
            } catch (error) {
                console.error('Error parsing JSON:', error);
                alert('Error parsing file: ' + error.message);
            }
        };
        
        reader.readAsText(file);
    }
    
    displayImportProjects(importedProjects) {
        const modal = this.modal;
        const container = modal.querySelector('#import-projects-list-container');
        const projectsList = modal.querySelector('#import-projects-list');
        const importButton = modal.querySelector('#import-selected-projects');
        
        // Show the projects list container
        container.classList.remove('hidden');
        
        // Clear previous list
        projectsList.innerHTML = '';
        
        // Get current projects for comparison
        const currentProjects = this.projectManager.projects;
        const currentProjectsMap = new Map();
        currentProjects.forEach(project => {
            currentProjectsMap.set(project.name, project);
        });
        
        // Flag to track if any projects are available for import
        let hasSelectableProjects = false;
        
        // Add checkboxes for each project
        importedProjects.forEach(project => {
            const listItem = document.createElement('div');
            listItem.className = 'flex items-center p-1 border-b last:border-b-0';
            listItem.style.borderColor = 'var(--border-color)';
            
            const isConflict = currentProjectsMap.has(project.name);
            let isNewer = false;
            let shouldSelect = true;
            
            if (isConflict) {
                const currentProject = currentProjectsMap.get(project.name);
                isNewer = new Date(project.dateModified) > new Date(currentProject.dateModified);
                shouldSelect = isNewer;
                
                // Apply color based on date comparison
                listItem.style.color = isNewer ? 'var(--theme-green-text)' : 'var(--theme-red-text)';
            }
            
            // Format date
            const modifiedDate = new Date(project.dateModified).toLocaleDateString();
            
            listItem.innerHTML = `
                <label class="flex items-center w-full cursor-pointer">
                    <input type="checkbox" class="mr-2 import-project-checkbox" value="${project.id}" 
                           data-name="${project.name}" ${shouldSelect ? 'checked' : ''}>
                    <div class="flex-1">
                        <div class="font-medium">${project.name}</div>
                        <div class="text-xs opacity-70">Modified: ${modifiedDate}</div>
                        ${isConflict ? `<div class="text-xs font-medium">
                            ${isNewer ? '(Newer than existing project)' : '(Older than existing project)'}
                        </div>` : ''}
                    </div>
                </label>
            `;
            
            projectsList.appendChild(listItem);
            hasSelectableProjects = true;
        });
        
        // Enable/disable import button
        importButton.disabled = !hasSelectableProjects;
        
        if (!hasSelectableProjects) {
            projectsList.innerHTML = '<div class="p-2 text-center text-gray-500">No projects available to import</div>';
        }
    }
    
    importSelectedProjects() {
        const modal = this.modal;
        const checkboxes = modal.querySelectorAll('.import-project-checkbox:checked');
        const fileInput = modal.querySelector('#import-file-input');
        
        if (checkboxes.length === 0 || !fileInput.files[0]) {
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const importedProjects = JSON.parse(event.target.result);
                if (!Array.isArray(importedProjects)) {
                    throw new Error('Invalid project format');
                }
                
                // Get selected project IDs
                const selectedIds = Array.from(checkboxes).map(cb => cb.value);
                
                // Filter projects to only selected ones
                const projectsToImport = importedProjects.filter(project => 
                    selectedIds.includes(project.id));
                
                // Create a map of existing project names for comparison
                const existingProjectNames = new Map();
                this.projectManager.projects.forEach(project => {
                    existingProjectNames.set(project.name, project);
                });
                
                // Import projects, replacing any with the same name
                projectsToImport.forEach(project => {
                    // If project with same name exists, remove it
                    if (existingProjectNames.has(project.name)) {
                        const existingProject = existingProjectNames.get(project.name);
                        const existingIndex = this.projectManager.projects.findIndex(p => p.id === existingProject.id);
                        if (existingIndex >= 0) {
                            this.projectManager.projects.splice(existingIndex, 1);
                        }
                    }
                    
                    // Add the imported project
                    this.projectManager.projects.push(project);
                });
                
                // Save and update UI
                this.projectManager.saveProjects();
                this.projectManager.renderProjectList();
                
                // Close modal and show success message
                this.closeModal();
                alert(`Successfully imported ${projectsToImport.length} project(s)`);
                
            } catch (error) {
                console.error('Error importing projects:', error);
                alert('Error importing projects: ' + error.message);
            }
        };
        
        reader.readAsText(fileInput.files[0]);
    }
}

// --- ExportManager Class ---
class ExportManager {
    constructor(projectManager) {
        this.projectManager = projectManager;
        this.modal = this.createModal();
        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }
    
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'export-projects-modal';
        modal.className = 'fixed inset-0 flex items-center justify-center z-50 hidden modal';
        
        modal.innerHTML = `
            <div class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop" id="export-modal-backdrop"></div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl z-10 w-full max-w-md max-h-[80vh] flex flex-col overflow-hidden modal-content" 
                 style="background-color: var(--bg-secondary); color: var(--text-primary);">
                <div class="px-4 py-3 border-b border-solid flex justify-between items-center" 
                     style="border-color: var(--border-color);">
                    <h3 class="text-lg font-semibold">Export Projects</h3>
                    <button id="close-export-modal" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 flex flex-col">
                    <div class="mb-4">
                        <label class="block mb-2">Select projects to export:</label>
                        <div id="export-projects-list" class="border rounded p-2 max-h-48 overflow-y-auto"
                             style="border-color: var(--border-color); background-color: var(--bg-primary);">
                            <!-- Project checkboxes will be dynamically added here -->
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block mb-2" for="export-filename">Filename:</label>
                        <input type="text" id="export-filename" class="w-full p-2 border rounded" value="flowchart-projects.json"
                               style="border-color: var(--border-color); background-color: var(--bg-primary);">
                    </div>
                </div>
                
                <div class="px-4 py-3 border-t border-solid flex justify-end" 
                     style="border-color: var(--border-color);">
                    <button id="export-selected-projects" class="px-4 py-2 bg-purple-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        Export Selected
                    </button>
                </div>
            </div>
        `;
        
        return modal;
    }
    
    setupEventListeners() {
        const modal = this.modal;
        const backdrop = modal.querySelector('#export-modal-backdrop');
        const closeButton = modal.querySelector('#close-export-modal');
        const exportButton = modal.querySelector('#export-selected-projects');
        
        // Close modal when clicking backdrop or close button
        backdrop.addEventListener('click', () => this.closeModal());
        closeButton.addEventListener('click', () => this.closeModal());
        
        // Handle export button click
        exportButton.addEventListener('click', () => this.exportSelectedProjects());
    }
    
    openModal() {
        this.populateProjectsList();
        
        this.modal.classList.remove('hidden');
        setTimeout(() => {
            this.modal.classList.add('open');
        }, 10);
    }
    
    closeModal() {
        this.modal.classList.remove('open');
        
        // Hide modal after animation
        setTimeout(() => {
            this.modal.classList.add('hidden');
        }, 300);
    }
    
    populateProjectsList() {
        const modal = this.modal;
        const projectsList = modal.querySelector('#export-projects-list');
        const exportButton = modal.querySelector('#export-selected-projects');
        
        // Clear previous list
        projectsList.innerHTML = '';
        
        // Get current projects
        const projects = this.projectManager.projects;
        
        // Add checkboxes for each project
        if (projects.length > 0) {
            // Add "Select All" checkbox
            const selectAllContainer = document.createElement('div');
            selectAllContainer.className = 'flex items-center p-1 bg-black bg-opacity-5 sticky top-0 border-b';
            selectAllContainer.style.borderColor = 'var(--border-color)';
            
            selectAllContainer.innerHTML = `
                <label class="flex items-center w-full cursor-pointer">
                    <input type="checkbox" id="select-all-export" class="mr-2" checked>
                    <div class="font-medium">Select All</div>
                </label>
            `;
            
            projectsList.appendChild(selectAllContainer);
            
            // Add event listener for select all
            modal.querySelector('#select-all-export').addEventListener('change', function() {
                const checkboxes = modal.querySelectorAll('.export-project-checkbox');
                checkboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
            });
            
            // Add project items
            projects.forEach(project => {
                const modifiedDate = new Date(project.dateModified).toLocaleDateString();
                
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1 border-b last:border-b-0';
                listItem.style.borderColor = 'var(--border-color)';
                
                listItem.innerHTML = `
                    <label class="flex items-center w-full cursor-pointer">
                        <input type="checkbox" class="mr-2 export-project-checkbox" value="${project.id}" checked>
                        <div class="flex-1">
                            <div class="font-medium">${project.name}</div>
                            <div class="text-xs opacity-70">Modified: ${modifiedDate}</div>
                        </div>
                    </label>
                `;
                
                projectsList.appendChild(listItem);
            });
            
            // Enable export button
            exportButton.disabled = false;
        } else {
            projectsList.innerHTML = '<div class="p-2 text-center text-gray-500">No projects available to export</div>';
            exportButton.disabled = true;
        }
    }
    
    exportSelectedProjects() {
        const modal = this.modal;
        const checkboxes = modal.querySelectorAll('.export-project-checkbox:checked');
        
        if (checkboxes.length === 0) {
            alert('Please select at least one project to export');
            return;
        }
        
        // Get selected project IDs
        const selectedIds = Array.from(checkboxes).map(cb => cb.value);
        
        // Get projects from projectManager
        const selectedProjects = this.projectManager.projects.filter(project => 
            selectedIds.includes(project.id));
        
        // Create JSON data
        const jsonData = JSON.stringify(selectedProjects, null, 2);
        
        // Get filename
        const filenameInput = modal.querySelector('#export-filename');
        let filename = filenameInput.value.trim();
        if (!filename) {
            filename = 'flowchart-projects.json';
        } else if (!filename.toLowerCase().endsWith('.json')) {
            filename += '.json';
        }
        
        // Create download link
        const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(jsonData);
        const downloadAnchor = document.createElement('a');
        downloadAnchor.setAttribute('href', dataStr);
        downloadAnchor.setAttribute('download', filename);
        document.body.appendChild(downloadAnchor);
        
        // Trigger download
        downloadAnchor.click();
        
        // Clean up
        document.body.removeChild(downloadAnchor);
        
        // Close modal
        this.closeModal();
    }
}

// --- Settings Manager ---
class SettingsManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager; // Store reference to diagram manager
        this.settings = {
            textScale: 1.0
        };
        this.loadSettings();
    }
    
    loadSettings() {
        try {
            const storedSettings = localStorage.getItem('markdownDiagramSettings');
            if (storedSettings) {
                this.settings = { ...this.settings, ...JSON.parse(storedSettings) };
            }
            this.applySettings();
        } catch (error) {
            console.error('Error loading settings:', error);
        }
    }
    
    saveSettings() {
        try {
            localStorage.setItem('markdownDiagramSettings', JSON.stringify(this.settings));
            // Update all boxes after saving settings
            if (this.diagramManager) {
                this.diagramManager.updateAllBoxSizes();
            }
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }
    
    applySettings() {
        // Apply text scale
        document.documentElement.style.setProperty('--font-scale', this.settings.textScale);
        
        // Update UI if elements exist
        const textScaleSlider = document.getElementById('text-scale');
        const textScaleValue = document.getElementById('text-scale-value');
        
        if (textScaleSlider) textScaleSlider.value = this.settings.textScale;
        if (textScaleValue) textScaleValue.textContent = `${this.settings.textScale.toFixed(1)}x`;
        
        // Update all box sizes when settings are applied (e.g. on page load)
        if (this.diagramManager) {
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                this.diagramManager.updateAllBoxSizes();
            }, 100);
        }
    }
}

// --- Project Management ---
class ProjectManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager;
        this.projects = [];
        this.currentProjectId = null;
        this.storageKey = 'markdownDiagramProjects';
        this.projectListEl = document.getElementById('project-list');
        this.noProjectsMessage = document.getElementById('no-projects-message');
        this.projectNameInput = document.getElementById('project-name');
        this.settingsMenu = document.getElementById('settings-menu');
        this.textScaleSlider = document.getElementById('text-scale');
        this.textScaleValue = document.getElementById('text-scale-value');
        this.newProjectForm = document.getElementById('new-project-form');
        this.addProjectToggle = document.getElementById('add-project-toggle');
        
        // Store which project is currently being edited/confirmed for deletion
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        this.showingNewProjectForm = false;
        
        // Initialize import and export managers
        this.importManager = new ImportManager(this);
        this.exportManager = new ExportManager(this);
        
        this.loadProjects();
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Settings button opens the menu
        document.getElementById('settings-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleSettingsMenu();
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!this.settingsMenu.contains(e.target) && 
                e.target.id !== 'settings-button' && 
                !e.target.closest('#settings-button')) {
                this.hideSettingsMenu();
            }
        });
        
        // Add project toggle
        this.addProjectToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleNewProjectForm();
        });
        
        // Commit new project
        document.getElementById('commit-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.createNewProject();
        });
        
        // Cancel new project
        document.getElementById('cancel-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.hideNewProjectForm();
        });
        
        // Create project on Enter
        this.projectNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.createNewProject();
            }
        });
        
        // Cancel on Escape key
        this.projectNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideNewProjectForm();
            }
        });
        
        // Text scale slider auto-save
        this.textScaleSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            this.textScaleValue.textContent = `${value.toFixed(1)}x`;
            
            // Save immediately to localStorage
            const settings = JSON.parse(localStorage.getItem('markdownDiagramSettings') || '{"textScale":1.0}');
            settings.textScale = value;
            localStorage.setItem('markdownDiagramSettings', JSON.stringify(settings));
            
            // Apply the setting
            document.documentElement.style.setProperty('--font-scale', value);
            
            // Update box sizes
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = setTimeout(() => {
                this.diagramManager.updateAllBoxSizes();
            }, 50);
        });
        
        // Import button
        document.getElementById('import-projects-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.importManager.openModal();
        });
        
        // Export button
        document.getElementById('export-projects-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.exportManager.openModal();
        });
    }
    
    toggleNewProjectForm() {
        if (this.showingNewProjectForm) {
            this.hideNewProjectForm();
        } else {
            this.showNewProjectForm();
        }
    }
    
    showNewProjectForm() {
        this.showingNewProjectForm = true;
        this.newProjectForm.classList.remove('hidden');
        
        // Use setTimeout to ensure transition works
        setTimeout(() => {
            this.newProjectForm.style.maxHeight = '100px';
            // Focus the input field
            this.projectNameInput.focus();
        }, 10);
    }
    
    hideNewProjectForm() {
        this.showingNewProjectForm = false;
        this.newProjectForm.style.maxHeight = '0';
        this.projectNameInput.value = '';
        
        // Hide after transition
        setTimeout(() => {
            this.newProjectForm.classList.add('hidden');
        }, 200);
    }
    
    toggleSettingsMenu() {
        if (this.settingsMenu.classList.contains('hidden')) {
            this.showSettingsMenu();
        } else {
            this.hideSettingsMenu();
        }
    }
    
    showSettingsMenu() {
        this.settingsMenu.classList.remove('hidden');
        
        // Animate in
        setTimeout(() => {
            this.settingsMenu.classList.remove('opacity-0', 'translate-y-2', 'pointer-events-none');
            this.settingsMenu.classList.add('opacity-100', 'translate-y-0');
        }, 10);
        
        // Update project list when showing menu
        this.renderProjectList();
    }
    
    hideSettingsMenu() {
        // Reset all sub-states
        this.hideNewProjectForm();
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        
        // Animate out
        this.settingsMenu.classList.add('opacity-0', 'translate-y-2', 'pointer-events-none');
        this.settingsMenu.classList.remove('opacity-100', 'translate-y-0');
        
        // Hide after animation
        setTimeout(() => {
            this.settingsMenu.classList.add('hidden');
        }, 200);
    }
    
    loadProjects() {
        try {
            const storedProjects = localStorage.getItem(this.storageKey);
            if (storedProjects) {
                this.projects = JSON.parse(storedProjects);
                this.renderProjectList();
                
                // Load last active project if exists
                const lastActiveId = localStorage.getItem('lastActiveProject');
                if (lastActiveId && this.projects.find(p => p.id === lastActiveId)) {
                    this.loadProject(lastActiveId);
                } else if (this.projects.length > 0) {
                    // Load first project if no last active
                    this.loadProject(this.projects[0].id);
                }
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            this.projects = [];
        }
        
        this.updateProjectsVisibility();
        this.updateProjectTitle();
    }
    
    saveProjects() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.projects));
            if (this.currentProjectId) {
                localStorage.setItem('lastActiveProject', this.currentProjectId);
            }
        } catch (error) {
            console.error('Error saving projects:', error);
        }
    }
    
    updateProjectTitle() {
        const projectTitleEl = document.getElementById('project-title');
        const currentProject = this.getCurrentProject();
        
        if (currentProject) {
            // Update the H1 element
            projectTitleEl.textContent = currentProject.name;
            
            // Update the page title
            document.title = `${currentProject.name} - Flow Chart`;
        } else {
            projectTitleEl.textContent = 'New Project';
            document.title = 'Flow Chart';
        }
    }
    
    createNewProject() {
        const name = this.projectNameInput.value.trim();
        if (!name) return;
        
        const newProject = {
            id: 'project_' + Date.now(),
            name: name,
            dateCreated: new Date().toISOString(),
            dateModified: new Date().toISOString(),
            data: {
                boxes: [],
                connections: [],
                nextBoxId: 1,
                nextConnectionId: 1
            }
        };
        
        this.projects.push(newProject);
        this.saveProjects();
        this.hideNewProjectForm();
        this.renderProjectList();
        this.loadProject(newProject.id);
        this.updateProjectsVisibility();
    }
    
    renderProjectList() {
        // Clear existing projects except the "no projects" message
        const children = Array.from(this.projectListEl.children);
        children.forEach(child => {
            if (child !== this.noProjectsMessage) {
                child.remove();
            }
        });
        
        // Add project items
        this.projects.forEach(project => {
            const projectItem = document.createElement('div');
            projectItem.className = 'mb-2 rounded overflow-hidden';
            projectItem.dataset.id = project.id;
            
            // Main project container
            const projectContainer = document.createElement('div');
            projectContainer.className = 'p-2 flex justify-between items-center cursor-pointer group';
            projectContainer.style.backgroundColor = 'var(--transparent-black-5)';
            
            if (project.id === this.currentProjectId) {
                projectContainer.classList.add('bg-purple-600', 'bg-opacity-20');
            }
            
            // Check if this project is being edited
            if (this.editingProjectId === project.id) {
                // Render edit form
                projectContainer.innerHTML = `
                    <div class="flex w-full items-center">
                        <input type="text" class="flex-1 px-2 py-1 mr-2 border rounded" value="${project.name}" id="edit-${project.id}" style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" data-id="${project.id}" title="Save">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600 ml-1" data-id="${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                // Setup event listeners for the edit form
                const input = projectContainer.querySelector('input');
                const commitBtn = projectContainer.querySelector('button[title="Save"]');
                const cancelBtn = projectContainer.querySelector('button[title="Cancel"]');
                
                // Focus the input
                setTimeout(() => input.focus(), 0);
                
                // Commit on button click
                commitBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.commitProjectEdit(project.id, input.value);
                });
                
                // Cancel edit
                cancelBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.editingProjectId = null;
                    this.renderProjectList();
                });
                
                // Commit on Enter key
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.commitProjectEdit(project.id, input.value);
                    }
                });
                
                // Cancel on Escape key
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.editingProjectId = null;
                        this.renderProjectList();
                    }
                });
            }
            // Normal project display
            else {
                const dateModified = new Date(project.dateModified);
                const formattedDate = dateModified.toLocaleDateString();
                
                projectContainer.innerHTML = `
                    <div>
                        <div class="truncate">${project.name}</div>
                        <div class="text-xs opacity-60">Modified: ${formattedDate}</div>
                    </div>
                    <div class="flex gap-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Edit">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Delete">
                            <i class="fas fa-trash-alt text-red-500"></i>
                        </button>
                    </div>
                `;
            }
            
            projectItem.appendChild(projectContainer);
            
            // Check if this project has a delete confirmation showing
            if (this.confirmingDeleteId === project.id) {
                // Create delete confirmation that slides down
                const confirmDelete = document.createElement('div');
                confirmDelete.className = 'p-2 flex items-center justify-between transition-all duration-200 overflow-hidden';
                confirmDelete.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                confirmDelete.innerHTML = `
                    <span class="text-sm">Confirm delete</span>
                    <div class="flex gap-2">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" id="confirm-delete-${project.id}" title="Confirm">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600" id="cancel-delete-${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                projectItem.appendChild(confirmDelete);
                
                // Add event listeners for confirmation buttons
                confirmDelete.querySelector(`#confirm-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteProject(project.id);
                });
                
                confirmDelete.querySelector(`#cancel-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.confirmingDeleteId = null;
                    this.renderProjectList();
                });
            }
            
            // Add click event to load project (only if not in edit mode)
            if (this.editingProjectId !== project.id) {
                projectContainer.addEventListener('click', (e) => {
                    // Don't load if clicking buttons
                    if (!e.target.closest('button')) {
                        this.loadProject(project.id);
                        this.hideSettingsMenu();
                    }
                });
                
                // Add event listeners for edit and delete buttons
                const editBtn = projectContainer.querySelector('button[title="Edit"]');
                if (editBtn) {
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.startProjectEdit(project.id);
                    });
                }
                
                const deleteBtn = projectContainer.querySelector('button[title="Delete"]');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.confirmDeleteProject(project.id);
                    });
                }
            }
            
            this.projectListEl.appendChild(projectItem);
        });
        
        this.updateProjectsVisibility();
    }
    
    // Start editing a project name
    startProjectEdit(projectId) {
        this.editingProjectId = projectId;
        this.renderProjectList();
    }
    
    // Commit project name edit
    commitProjectEdit(projectId, newName) {
        newName = newName.trim();
        if (!newName) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === projectId);
        if (projectIndex >= 0) {
            this.projects[projectIndex].name = newName;
            this.saveProjects();
            
            // Update title if editing current project
            if (projectId === this.currentProjectId) {
                this.updateProjectTitle();
            }
        }
        
        this.editingProjectId = null;
        this.renderProjectList();
    }
    
    // Show delete confirmation
    confirmDeleteProject(projectId) {
        this.confirmingDeleteId = projectId;
        this.renderProjectList();
    }
    
    updateProjectsVisibility() {
        if (this.projects.length === 0) {
            this.noProjectsMessage.style.display = 'block';
        } else {
            this.noProjectsMessage.style.display = 'none';
        }
    }
    
    deleteProject(projectId) {
        this.projects = this.projects.filter(project => project.id !== projectId);
        this.saveProjects();
        
        // If deleted current project, load another one
        if (projectId === this.currentProjectId) {
            if (this.projects.length > 0) {
                this.loadProject(this.projects[0].id);
            } else {
                // No projects left, clear diagram
                this.diagramManager.clearDiagram();
                this.currentProjectId = null;
                this.updateProjectTitle();
            }
        }
        
        this.confirmingDeleteId = null;
        this.renderProjectList();
        this.updateProjectsVisibility();
    }
    
    loadProject(projectId) {
        const project = this.projects.find(p => p.id === projectId);
        if (!project) return;
        
        // Save current project if exists
        this.saveCurrentProject();
        
        // Load new project
        this.currentProjectId = projectId;
        this.diagramManager.loadFromProjectData(project.data);
        
        // Update project title
        this.updateProjectTitle();
        
        localStorage.setItem('lastActiveProject', projectId);
    }
    
    saveCurrentProject() {
        if (!this.currentProjectId) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === this.currentProjectId);
        if (projectIndex >= 0) {
            const diagramData = this.diagramManager.exportData();
            this.projects[projectIndex].data = diagramData;
            this.projects[projectIndex].dateModified = new Date().toISOString();
            this.saveProjects();
        }
    }
    
    getCurrentProject() {
        return this.projects.find(p => p.id === this.currentProjectId);
    }
}

// --- Box Class ---
class Box {
    constructor(boxData, manager) {
        this.data = boxData;
        if (!this.data.widthType) { this.data.widthType = WIDTH_TYPES.MEDIUM; }
        if (!this.data.markdown) { this.data.markdown = '# New Box\nUse **markdown** to format'; }
        if (!this.data.themeKey) { this.data.themeKey = 'default'; }
        this.manager = manager;
        this.isEditing = false;
        this.element = this.createElement();
        this.contentDiv = this.element.firstChild;
        this.textarea = null;
        this.updateElementPosition();
        this.applyColorTheme();
        this.renderMarkdown();
        this.setupEventListeners();
    }

    createElement() { 
        const div = document.createElement('div'); 
        div.className = BASE_BOX_CLASSES; 
        div.dataset.id = this.data.id; 
        div.dataset.type = 'box';
        div.dataset.theme = this.data.themeKey;
        const contentDiv = document.createElement('div'); 
        contentDiv.className = 'markdown-content relative w-full h-full'; 
        div.appendChild(contentDiv); 
        return div; 
    }
    
    setupEventListeners() {
        let isDragging = false;
        
        this.element.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.element.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.element.addEventListener('mousedown', (e) => { 
            isDragging = false; 
            // Start dragging on mousedown
            if (e.button === 0 && !this.isEditing) {
                this.manager.startDragging(this, e);
            } else if (e.button === 2) {
                // Right mouse button down - start connection or change width
                this.manager.handleBoxRightMouseDown(e, this);
            }
        });
        
        this.element.addEventListener('mousemove', () => { 
            if (this.manager.draggingBox === this) { 
                isDragging = true; 
            } 
        });
        
        this.element.addEventListener('dblclick', (e) => { 
            e.stopPropagation(); 
            if (!this.isEditing) { 
                this.startEditing(); 
            } 
        });
        
        this.element.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            return false; 
        });
    }

    // Updates the element's CSS position
    updateElementPosition() {
        const x = this.data.cx - this.data.width / 2;
        const y = this.data.cy - this.data.height / 2;
        this.element.style.left = `${Math.round(x)}px`;
        this.element.style.top = `${Math.round(y)}px`;
        this.element.style.width = `${this.data.width}px`;
        this.element.style.height = `${this.data.height}px`;
    }

    // Updates position using center coordinates - for dragging
    setCenterPosition(cx, cy) { this.data.cx = cx; this.data.cy = cy; this.updateElementPosition(); }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Apply color theme to the box
    applyColorTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get the mode-specific theme
        const modeTheme = theme[mode];
        
        // Remove all theme classes
        THEME_KEYS.forEach(key => {
            const lightTheme = COLOR_THEMES[key].light;
            const darkTheme = COLOR_THEMES[key].dark;
            
            // Remove both light and dark variants
            safeRemoveClass(this.element, lightTheme.bg);
            safeRemoveClass(this.element, lightTheme.border);
            safeRemoveClass(this.contentDiv, lightTheme.text);
            
            safeRemoveClass(this.element, darkTheme.bg);
            safeRemoveClass(this.element, darkTheme.border);
            safeRemoveClass(this.contentDiv, darkTheme.text);
        });
        
        // Add current theme classes for the current mode
        if (modeTheme.bg) this.element.classList.add(modeTheme.bg);
        if (modeTheme.border) this.element.classList.add(modeTheme.border);
        if (modeTheme.text) this.contentDiv.classList.add(modeTheme.text);
        
        // Update data attribute for theme identification
        this.element.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyColorTheme();
    }

    // Toggle between width types
    toggleWidthType() {
        const types = Object.values(WIDTH_TYPES);
        const currentIndex = types.indexOf(this.data.widthType);
        const nextIndex = (currentIndex + 1) % types.length;
        this.data.widthType = types[nextIndex];
        
        // Set the new width directly
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        this.data.width = width;
        
        // Update size based on current mode
        if (this.isEditing) {
            this.updateEditModeSize();
        } else {
            this.renderMarkdown();
        }
        
        this.manager.updateConnectionsForBox(this);
    }

    // Renders markdown content to HTML and calculates size
    renderMarkdown() {
        if (!this.data.markdown) return;
        
        try {
            // Use marked.js or fallback
            this.contentDiv.innerHTML = typeof marked !== 'undefined' && typeof marked.parse === 'function' 
                ? marked.parse(this.data.markdown) 
                : simpleMarkdownParser(this.data.markdown);
        } catch (e) {
            console.error('Error parsing markdown:', e);
            this.contentDiv.innerHTML = simpleMarkdownParser(this.data.markdown);
        }
        
        // Update size after rendering
        this.calculateRenderedSize();
    }

    // Calculate size with fixed width based on type
    calculateRenderedSize() {
        // Clone for measurement
        const clone = this.element.cloneNode(true);
        document.body.appendChild(clone);
        
        // Reset styles for measurement
        clone.style.position = 'absolute';
        clone.style.visibility = 'hidden';
        clone.style.left = '-9999px';
        clone.style.top = '-9999px';
        clone.style.height = 'auto';
        clone.style.maxWidth = 'none';
        clone.style.transition = 'none';
        
        // Use fixed width from width type directly
        const fixedWidth = WIDTH_TYPE_VALUES[this.data.widthType];
        clone.style.width = `${fixedWidth}px`;
        
        // Force reflow and measure height with the fixed width
        clone.offsetHeight;
        const newHeight = Math.max(clone.offsetHeight, 50);
        
        // Clean up
        document.body.removeChild(clone);
        
        // Update size
        this.data.width = fixedWidth;
        this.data.height = newHeight;
        this.updateElementPosition();
        
        return { width: fixedWidth, height: newHeight };
    }

    // Calculate box height based on line count
    calculateHeightFromLineCount() {
        if (!this.isEditing || !this.textarea) return 50;
        
        const lineCount = this.textarea.value.split('\n').length;
        return PADDING_HEIGHT + (lineCount * LINE_HEIGHT);
    }

    // Updates box size based on text content during editing
    updateEditModeSize() {
        if (!this.isEditing || !this.textarea) return;
        
        // Always use fixed width from width type
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Calculate height based on line count
        const height = this.calculateHeightFromLineCount();
        
        // Update size
        this.data.width = width;
        this.data.height = height;
        this.updateElementPosition();
        this.manager.updateConnectionsForBox(this);
    }

    // Switches to editing mode
    startEditing() {
        if (this.isEditing) return;
        this.isEditing = true;
        this.element.classList.remove('cursor-move');
        
        // Clear and prepare container
        this.contentDiv.innerHTML = '';
        
        // Create textarea
        this.textarea = document.createElement('textarea');
        this.textarea.className = 'edit-textarea';
        this.textarea.value = this.data.markdown || '';
        this.textarea.placeholder = 'Add markdown content...';
        
        // Set fixed width from width type
        this.data.width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Add event listeners
        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') { 
                e.preventDefault(); 
                this.cancelEdit(); 
            } else if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.commitEdit();
            }
            
            // Update size on next tick
            setTimeout(() => this.updateEditModeSize(), 0);
        });
        
        this.textarea.addEventListener('input', () => {
            this.updateEditModeSize();
        });
        
        // Prevent event propagation
        this.textarea.addEventListener('mousedown', e => e.stopPropagation());
        this.textarea.addEventListener('contextmenu', e => e.stopPropagation());
        this.textarea.addEventListener('dblclick', e => e.stopPropagation());
        this.textarea.addEventListener('click', e => e.stopPropagation());

        // Append the textarea to the DOM
        this.contentDiv.appendChild(this.textarea);

        // Focus and select text safely with a check
        requestAnimationFrame(() => {
            // Guard clause to prevent the error
            if (this.textarea && this.contentDiv.contains(this.textarea)) {
                this.textarea.focus();
                if (this.textarea.value) this.textarea.select();
            }
            this.updateEditModeSize();
        });
    }

    commitEdit() { 
        if (!this.isEditing || !this.textarea) return false; 
        const markdown = this.textarea.value.trim(); 
        if (!markdown) { 
            this.cancelEdit(); 
            return false; 
        } 
        this.data.markdown = markdown; 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
        this.manager.updateConnectionsForBox(this); 
        this.manager.saveCurrentProject();
        this.manager.updateCanvasSize(); // Update canvas size after edit
        return true; 
    }
    
    cancelEdit() { 
        if (!this.isEditing) return; 
        if (!this.data.markdown) { 
            this.manager.deleteBox(this); 
            return; 
        } 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
    }
    
    cleanupEdit() { 
        this.isEditing = false; 
        if (this.textarea && this.textarea.parentNode) { 
            this.textarea.remove(); 
        } 
        this.textarea = null; 
        this.element.classList.add('cursor-move'); 
    }
    
    getBounds() { 
        const x = this.data.cx - this.data.width / 2; 
        const y = this.data.cy - this.data.height / 2; 
        return { 
            left: x, 
            right: x + this.data.width, 
            top: y, 
            bottom: y + this.data.height, 
            width: this.data.width, 
            height: this.data.height 
        }; 
    }
    
    // Export box data
    exportData() {
        return {
            id: this.data.id,
            cx: this.data.cx,
            cy: this.data.cy,
            width: this.data.width,
            height: this.data.height,
            widthType: this.data.widthType,
            themeKey: this.data.themeKey,
            markdown: this.data.markdown
        };
    }
}

// --- Connection Class ---
class Connection {
    constructor(connectionData, startBox, endBox, manager) { 
        this.data = connectionData; 
        // Initialize data if needed
        if (!this.data.themeKey) this.data.themeKey = 'default';
        if (!this.data.pattern) this.data.pattern = CONNECTION_PATTERNS.NORMAL;
        if (!this.data.thickness) this.data.thickness = CONNECTION_THICKNESSES.NORMAL;
        if (this.data.bidirectional === undefined) this.data.bidirectional = false;
        
        this.startBox = startBox; 
        this.endBox = endBox; 
        this.manager = manager; 
        
        // Create connection group and all elements
        this.createElements();
        
        this.update(); 
        this.setupEventListeners(); 
    }
    
    createElements() {
        // Create a group for the connection
        this.group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.group.setAttribute('class', 'connection-group');
        this.group.dataset.id = this.data.id;
        this.group.dataset.type = 'connection-group';
        
        // Create the hitbox path with wide stroke for easier clicking
        this.hitboxElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        this.hitboxElement.setAttribute('class', 'connection-hitbox');
        this.hitboxElement.dataset.id = this.data.id;
        this.hitboxElement.dataset.type = 'connection-hitbox';
        
        // Create the visible connection path
        this.element = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
        this.element.setAttribute('class', 'connection-path pointer-events-none'); 
        this.element.dataset.id = this.data.id; 
        this.element.dataset.type = 'connection';
        this.element.dataset.theme = this.data.themeKey;
        
        // Set markers based on if bidirectional
        if (this.data.bidirectional) {
            this.element.setAttribute('marker-start', 'url(#arrowhead-start)');
        }
        this.element.setAttribute('marker-end', 'url(#arrowhead-end)');
        
        // Create start hotspot inside the group
        this.startHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.startHotspot.setAttribute('class', 'arrow-hotspot');
        this.startHotspot.setAttribute('r', '12');
        this.startHotspot.dataset.connection = this.data.id;
        this.startHotspot.dataset.end = 'start';
        
        // Create end hotspot inside the group
        this.endHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.endHotspot.setAttribute('class', 'arrow-hotspot');
        this.endHotspot.setAttribute('r', '12');
        this.endHotspot.dataset.connection = this.data.id;
        this.endHotspot.dataset.end = 'end';
        
        // Add all elements to the group in the correct order (hitbox first, then line, then interaction points)
        this.group.appendChild(this.hitboxElement);
        this.group.appendChild(this.element);
        this.group.appendChild(this.startHotspot);
        this.group.appendChild(this.endHotspot);
        
        // Set up event listeners for the hotspots
        this.setupHotspotEventListeners();
    }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Set up event listeners for the hotspots
    setupHotspotEventListeners() {
        this.startHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.startHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.startHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
        
        this.endHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.endHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.endHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
    }
    
    // Toggle bidirectionality of the connection
    toggleBidirectional() {
        this.data.bidirectional = !this.data.bidirectional;
        
        // Apply the updated bidirectional state
        this.update();
        
        // Call applyTheme to ensure the correct marker is used
        this.applyTheme();
    }
    
    setupEventListeners() { 
        // Add interaction events to the hitbox element
        this.hitboxElement.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.hitboxElement.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        // Add left-click event to toggle line pattern
        this.hitboxElement.addEventListener('click', (e) => {
            e.stopPropagation();
            this.cyclePattern();
            this.manager.saveCurrentProject();
        });
        
        // Add right-click event to toggle thickness
        this.hitboxElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.cycleThickness();
            this.manager.saveCurrentProject();
        });
    }
    
    // Apply the current theme to the connection
    applyTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get stroke color for current mode
        const strokeColor = theme[mode].stroke;
        
        if (this.element) {
            // Set stroke color
            this.element.setAttribute('stroke', strokeColor);
            
            // Use theme-specific markers based on theme and current mode
            const startMarkerId = `arrowhead-start-${themeKey}-${mode}`;
            const endMarkerId = `arrowhead-end-${themeKey}-${mode}`;
            
            // Use theme-specific markers
            if (this.data.bidirectional) {
                this.element.setAttribute('marker-start', `url(#${startMarkerId})`);
            } else {
                this.element.removeAttribute('marker-start');
            }
            this.element.setAttribute('marker-end', `url(#${endMarkerId})`);
            
            // Also set hover fill color for hotspots to match the theme
            this.startHotspot.style.setProperty('--transparent-black-5', strokeColor + '33');
            this.endHotspot.style.setProperty('--transparent-black-5', strokeColor + '33');
        }
        
        // Update data attributes for theme identification
        this.element.dataset.theme = themeKey;
        this.group.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyTheme();
        this.manager.saveCurrentProject();
    }
    
    // Apply current pattern to the connection
    applyPattern() {
        // Remove all pattern classes first
        this.element.classList.remove(
            'connection-pattern-normal',
            'connection-pattern-dashed', 
            'connection-pattern-dotted'
        );
        
        // Add current pattern class
        this.element.classList.add(`connection-pattern-${this.data.pattern}`);
    }
    
    // Apply current thickness to the connection
    applyThickness() {
        // Remove all thickness classes first
        this.element.classList.remove(
            'connection-thickness-thin',
            'connection-thickness-normal',
            'connection-thickness-bold'
        );
        
        // Add current thickness class
        this.element.classList.add(`connection-thickness-${this.data.thickness}`);
    }
    
    // Cycle to the next line pattern (left click)
    cyclePattern() {
        const patterns = Object.values(CONNECTION_PATTERNS);
        const currentIndex = patterns.indexOf(this.data.pattern);
        const nextIndex = (currentIndex + 1) % patterns.length;
        this.data.pattern = patterns[nextIndex];
        this.applyPattern();
    }
    
    // Cycle to the next thickness (right click)
    cycleThickness() {
        const thicknesses = Object.values(CONNECTION_THICKNESSES);
        const currentIndex = thicknesses.indexOf(this.data.thickness);
        const nextIndex = (currentIndex + 1) % thicknesses.length;
        this.data.thickness = thicknesses[nextIndex];
        this.applyThickness();
    }
    
    calculateIntersection(startPt, endPt, targetBox) { 
        const bounds = targetBox.getBounds(); 
        const dx = endPt.x - startPt.x; 
        const dy = endPt.y - startPt.y; 
        if (bounds.width <= 0 || bounds.height <= 0 || (dx === 0 && dy === 0)) { 
            return { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; 
        } 
        let t = Infinity; 
        let intersection = null; 
        const tol = 0.1; 
        const checkT = (newT, x, y, b) => { 
            if (newT >= 0 && newT < t && x >= b.left - tol && x <= b.right + tol && y >= b.top - tol && y <= b.bottom + tol) { 
                t = newT; 
                return { x, y }; 
            } 
            return null; 
        }; 
        if (dx !== 0) { 
            let tL = (bounds.left - startPt.x) / dx; 
            let yL = startPt.y + tL * dy; 
            intersection = checkT(tL, bounds.left, yL, bounds) || intersection; 
            let tR = (bounds.right - startPt.x) / dx; 
            let yR = startPt.y + tR * dy; 
            intersection = checkT(tR, bounds.right, yR, bounds) || intersection; 
        } 
        if (dy !== 0) { 
            let tT = (bounds.top - startPt.y) / dy; 
            let xT = startPt.x + tT * dx; 
            intersection = checkT(tT, xT, bounds.top, bounds) || intersection; 
            let tB = (bounds.bottom - startPt.y) / dy; 
            let xB = startPt.x + tB * dx; 
            intersection = checkT(tB, xB, bounds.bottom, bounds) || intersection; 
        } 
        if (intersection) { 
            const len = Math.sqrt(dx*dx + dy*dy) || 1; 
            const ux = dx / len; 
            const uy = dy / len; 
            intersection.x -= ux * 2; 
            intersection.y -= uy * 2; 
        } 
        return intersection || { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; 
    }
    
    update() { 
        if (!this.startBox || !this.endBox) return; 
        const sC = { x: this.startBox.data.cx, y: this.startBox.data.cy }; 
        const eC = { x: this.endBox.data.cx, y: this.endBox.data.cy }; 
        const eP = this.calculateIntersection(sC, eC, this.endBox); 
        const sP = this.calculateIntersection(eP, sC, this.startBox); 
        
        if (!isNaN(sP.x) && !isNaN(eP.x)) { 
            const pathData = `M ${sP.x} ${sP.y} L ${eP.x} ${eP.y}`;
            
            // Update both the visible path and hitbox path
            this.element.setAttribute('d', pathData); 
            this.hitboxElement.setAttribute('d', pathData);
            
            // Update hotspot positions
            this.updateHotspotPositions(sP, eP);
        } else { 
            this.element.setAttribute('d', ''); 
            this.hitboxElement.setAttribute('d', '');
        } 
        
        this.updateElementStyle(); 
    }
    
    // Update hotspot positions
    updateHotspotPositions(startPoint, endPoint) {
        // Calculate vector
        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len === 0) return;
        
        const ux = dx / len;
        const uy = dy / len;
        
        // Position hotspots
        if (this.startHotspot) {
            const startHotspotX = startPoint.x + ux * 12;
            const startHotspotY = startPoint.y + uy * 12;
            this.startHotspot.setAttribute('cx', startHotspotX);
            this.startHotspot.setAttribute('cy', startHotspotY);
        }
        
        if (this.endHotspot) {
            const endHotspotX = endPoint.x - ux * 12;
            const endHotspotY = endPoint.y - uy * 12;
            this.endHotspot.setAttribute('cx', endHotspotX);
            this.endHotspot.setAttribute('cy', endHotspotY);
        }
    }
    
    updateElementStyle() { 
        // Apply theme, pattern and thickness
        this.applyTheme();
        this.applyPattern();
        this.applyThickness();
    }
    
    // Clean up the connection by removing the whole group
    cleanup() {
        if (this.group) {
            this.group.remove();
            this.group = null;
            this.element = null;
            this.hitboxElement = null;
            this.startHotspot = null;
            this.endHotspot = null;
        }
    }
    
    // Export connection data
    exportData() {
        return {
            id: this.data.id,
            startBoxId: this.startBox.data.id,
            endBoxId: this.endBox.data.id,
            themeKey: this.data.themeKey,
            pattern: this.data.pattern,
            thickness: this.data.thickness,
            bidirectional: this.data.bidirectional
        };
    }
}

// --- Diagram Manager Class ---
class DiagramManager {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.svg = document.getElementById('connections');
        this.boxContainer = document.getElementById('box-container');
        this.helperText = document.getElementById('helper-text');
        this.previewPath = document.getElementById('preview-connection');
        
        this.boxes = new Map();
        this.connections = new Map();
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        this.draggingBox = null;
        this.dragStartPos = { x: 0, y: 0 };
        this.dragBoxStartCenter = { cx: 0, cy: 0 };
        this.connectionStartBox = null;
        this.hoveredElement = null; // Track currently hovered element
        
        // Setup arrow markers with correct color inheritance
        this.setupArrowMarkers();
        
        // Initialize theme
        this.initTheme();
        
        // Initialize settings manager with reference to this diagram manager
        this.settingsManager = new SettingsManager(this);
        
        // Initialize UI
        this.setupEventListeners();
        this.updateHelperText();
        this.setupThemeToggle();
        
        // Initialize project manager
        this.projectManager = new ProjectManager(this);
        
        // Set initial canvas size
        this.updateCanvasSize();
        
        // Add window resize listener
        window.addEventListener('resize', () => {
            this.updateCanvasSize();
        });
    }

    // Setup arrow markers with proper color inheritance
    setupArrowMarkers() {
        // Get the defs section
        const defs = this.svg.querySelector('defs');
        if (!defs) return;
        
        // Clear existing markers
        defs.innerHTML = '';
        
        // Create markers for each theme
        Object.keys(COLOR_THEMES).forEach(themeKey => {
            const theme = COLOR_THEMES[themeKey];
            
            // Create markers for both light and dark modes
            ['light', 'dark'].forEach(mode => {
                const strokeColor = theme[mode].stroke;
                
                // Create end marker
                const markerEndId = `arrowhead-end-${themeKey}-${mode}`;
                const markerEnd = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerEnd.id = markerEndId;
                markerEnd.setAttribute('markerWidth', '10');
                markerEnd.setAttribute('markerHeight', '7');
                markerEnd.setAttribute('refX', '9');
                markerEnd.setAttribute('refY', '3.5');
                markerEnd.setAttribute('orient', 'auto');
                
                const polygonEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonEnd.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygonEnd.setAttribute('fill', strokeColor);
                
                markerEnd.appendChild(polygonEnd);
                defs.appendChild(markerEnd);
                
                // Create start marker (for bidirectional)
                const markerStartId = `arrowhead-start-${themeKey}-${mode}`;
                const markerStart = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerStart.id = markerStartId;
                markerStart.setAttribute('markerWidth', '10');
                markerStart.setAttribute('markerHeight', '7');
                markerStart.setAttribute('refX', '1');
                markerStart.setAttribute('refY', '3.5');
                markerStart.setAttribute('orient', 'auto');
                
                const polygonStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonStart.setAttribute('points', '10 0, 0 3.5, 10 7');
                polygonStart.setAttribute('fill', strokeColor);
                
                markerStart.appendChild(polygonStart);
                defs.appendChild(markerStart);
            });
        });
    }
    
    // Update canvas size based on box positions with buffer zone
    updateCanvasSize() {
        // Find the maximum bounds in all directions
        let maxRight = 0;
        let maxBottom = 0;
        
        this.boxes.forEach(box => {
            const bounds = box.getBounds();
            maxRight = Math.max(maxRight, bounds.right);
            maxBottom = Math.max(maxBottom, bounds.bottom);
        });
        
        // Add buffer only for height (half viewport height)
        const bufferHeight = window.innerHeight / 2;
        
        // Get visible viewport dimensions (accounts for scrollbar presence)
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight;
        
        // For width: use exactly the content width or viewport width, whichever is larger
        // For height: add buffer for more natural vertical scrolling
        const newWidth = Math.max(maxRight, viewportWidth);
        const newHeight = Math.max(maxBottom + bufferHeight, viewportHeight);
        
        // Apply the new dimensions to relevant elements
        this.canvas.style.width = `${newWidth}px`;
        this.canvas.style.height = `${newHeight}px`;
        
        this.svg.style.width = `${newWidth}px`;
        this.svg.style.height = `${newHeight}px`;
        
        this.boxContainer.style.width = `${newWidth}px`;
        this.boxContainer.style.height = `${newHeight}px`;
    }

    updateAllBoxSizes() {
        // Recalculate and update the size of all boxes
        this.boxes.forEach(box => {
            // Force box to recalculate its size with current text scale
            box.renderMarkdown();
        });
        
        // Update all connections after box sizes change
        this.connections.forEach(connection => {
            connection.update();
        });
        
        // Update canvas size to accommodate new box sizes
        this.updateCanvasSize();
    }
    
    initTheme() {
        // Check for saved theme preference
        const darkMode = localStorage.getItem('darkMode') === 'true';
        if (darkMode) {
            document.body.classList.add('dark-mode');
        }
    }
    
    setupEventListeners() { 
        this.canvas.addEventListener('dblclick', this.handleCanvasDoubleClick.bind(this)); 
        this.canvas.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this)); 
        
        // Use separate event handlers for better scroll position management
        document.addEventListener('mousemove', (e) => {
            // Handle box dragging
            if (this.draggingBox) { 
                const dx = e.clientX - this.dragStartPos.x; 
                const dy = e.clientY - this.dragStartPos.y; 
                const nCx = this.dragBoxStartCenter.cx + dx; 
                const nCy = this.dragBoxStartCenter.cy + dy; 
                this.draggingBox.setCenterPosition(nCx, nCy); 
                this.updateConnectionsForBox(this.draggingBox); 
            } 
            // Handle connection preview drawing
            else if (this.connectionStartBox) { 
                const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
                
                // Get scroll position for accurate coordinates
                const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                
                // Get mouse position relative to canvas with scroll offsets
                const r = this.svg.getBoundingClientRect(); 
                const mX = e.clientX - r.left + scrollX; 
                const mY = e.clientY - r.top + scrollY; 
                
                this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
            }
        }); 
        
        document.addEventListener('mouseup', (e) => {
            if (this.draggingBox) { 
                this.draggingBox = null; 
                this.saveCurrentProject();
                this.updateCanvasSize(); // Update canvas size after drag
            } else if (this.connectionStartBox && e.button === 2) { 
                e.preventDefault(); 
                this.previewPath.setAttribute('display', 'none'); 
                
                // Get correct element at mouse position
                let eTE = document.elementFromPoint(e.clientX, e.clientY); 
                let eBE = eTE?.closest('.box-default'); 
                
                if (eBE) { 
                    const eB = this.boxes.get(eBE.dataset.id); 
                    if (eB && eB !== this.connectionStartBox) { 
                        // Create or update connection between boxes
                        const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                        if (connection) {
                            this.saveCurrentProject();
                        }
                    } else if (eB === this.connectionStartBox) {
                        // Change width if right-click and release on the same box
                        eB.toggleWidthType();
                        this.saveCurrentProject();
                    }
                } 
                
                this.connectionStartBox = null; 
                this.rightClickBox = null;
            } 
            
            if (e.button === 0) { 
                this.draggingBox = null; 
            } 
        });

        document.addEventListener('keydown', this.handleKeyDown.bind(this)); 
        document.addEventListener('click', this.handleGlobalClick.bind(this), true); 
        document.addEventListener('contextmenu', e => e.preventDefault()); 

        // Handle mouse leaving the window
        document.addEventListener('mouseleave', () => { 
            if (this.connectionStartBox) { 
                this.previewPath.setAttribute('display', 'none'); 
                this.connectionStartBox = null; 
            } 
        }); 

        // Add scroll event handling to ensure connections update during scrolling
        window.addEventListener('scroll', () => {
            // Update all connections when scrolling to ensure they remain accurate
            this.connections.forEach(connection => {
                connection.update();
            });
        });
    }

    setupThemeToggle() {
        const toggleBtn = document.getElementById('theme-toggle');
        
        toggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            
            // Store theme preference in localStorage
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
            
            // Update all box and connection themes
            this.updateAllThemes();
        });
    }

    // Update themes for all boxes and connections when theme mode changes
    updateAllThemes() {
        // Update boxes
        this.boxes.forEach(box => {
            box.applyColorTheme();
        });
        
        // Update connections
        this.connections.forEach(conn => {
            conn.applyTheme();
        });
    }

    handleCanvasDoubleClick(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            const rect = this.boxContainer.getBoundingClientRect(); 
            const cx = e.clientX - rect.left; 
            const cy = e.clientY - rect.top; 
            if (cx >= 0 && cy >= 0 && cx <= rect.width && cy <= rect.height) { 
                this.createBox(cx, cy); 
            } 
        } 
    }

    handleCanvasMouseDown(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            // No-op for now - we don't have selection state anymore
        } 
    }

    startDragging(box, e) {
        if (!box || box.isEditing) return;
        
        this.draggingBox = box;
        this.dragStartPos = { x: e.clientX, y: e.clientY };
        this.dragBoxStartCenter = { cx: box.data.cx, cy: box.data.cy };
    }

    handleBoxRightMouseDown(e, box) {
        if (!box || box.isEditing) return;
        
        e.preventDefault();
        
        // Right-click for starting connection
        this.connectionStartBox = box;
        const sC = { cx: box.data.cx, cy: box.data.cy };
        const r = this.svg.getBoundingClientRect();
        const mX = e.clientX - r.left;
        const mY = e.clientY - r.top;
        this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`);
        this.previewPath.setAttribute('display', 'block');
        
        // Also toggle width if mouse up on the same box
        this.rightClickBox = box;
    }

    handleMouseMove(e) { 
        if (this.draggingBox) { 
            const dx = e.clientX - this.dragStartPos.x; 
            const dy = e.clientY - this.dragStartPos.y; 
            const nCx = this.dragBoxStartCenter.cx + dx; 
            const nCy = this.dragBoxStartCenter.cy + dy; 
            this.draggingBox.setCenterPosition(nCx, nCy); 
            this.updateConnectionsForBox(this.draggingBox); 
        } else if (this.connectionStartBox) { 
            const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
            
            // Calculate the correct mouse position with scroll offsets
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            const r = this.svg.getBoundingClientRect(); 
            const mX = e.clientX - r.left + scrollX; 
            const mY = e.clientY - r.top + scrollY; 
            
            this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
        } 
    }

    handleMouseUp(e) { 
        if (this.draggingBox) { 
            this.draggingBox = null; 
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after drag
        } else if (this.connectionStartBox && e.button === 2) { 
            e.preventDefault(); 
            this.previewPath.setAttribute('display', 'none'); 
            let eTE = document.elementFromPoint(e.clientX, e.clientY); 
            let eBE = eTE?.closest('.box-default'); 
            
            if (eBE) { 
                const eB = this.boxes.get(eBE.dataset.id); 
                if (eB && eB !== this.connectionStartBox) { 
                    // Create or update connection between boxes
                    const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                    if (connection) {
                        this.saveCurrentProject();
                    }
                } else if (eB === this.connectionStartBox) {
                    // Change width if right-click and release on the same box
                    eB.toggleWidthType();
                    this.saveCurrentProject();
                }
            } 
            
            this.connectionStartBox = null; 
            this.rightClickBox = null;
        } 
        
        if (e.button === 0) { 
            this.draggingBox = null; 
        } 
    }

    handleGlobalClick(e) { 
        const targetTextarea = e.target.closest('textarea'); 
        
        if (!targetTextarea) { 
            // Check if any box is in edit mode
            let editingBox = false;
            this.boxes.forEach(box => { 
                if (box.isEditing) { 
                    editingBox = true; 
                    box.commitEdit(); 
                } 
            }); 
        } 
    }

    handleKeyDown(e) { 
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return; 
        
        // Handle Delete/Backspace for removing hovered element
        if ((e.key === 'Delete' || e.key === 'Backspace') && this.hoveredElement) {
            // Delete the hovered element
            if (this.hoveredElement instanceof Box) {
                this.deleteBox(this.hoveredElement);
            } else if (this.hoveredElement instanceof Connection) {
                this.deleteConnection(this.hoveredElement);
            }
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after deletion
        }
        
        // Handle 'c' key for changing color of hovered element
        if (e.key === 'c' && this.hoveredElement) {
            if (this.hoveredElement instanceof Box || this.hoveredElement instanceof Connection) {
                this.hoveredElement.cycleColorTheme();
                this.saveCurrentProject();
            }
        }
        
        // Handle 's' key for changing width of hovered box (NOT connections)
        if (e.key === 's' && this.hoveredElement instanceof Box) {
            this.hoveredElement.toggleWidthType();
            this.saveCurrentProject();
        }
    }

    createBox(cx, cy) { 
        const id = `box-${this.nextBoxId++}`; 
        const bD = { 
            id: id, 
            cx: cx, 
            cy: cy, 
            width: INITIAL_BOX_WIDTH, 
            height: INITIAL_BOX_HEIGHT, 
            widthType: WIDTH_TYPES.MEDIUM,
            themeKey: 'default',
            markdown: '# Title\nUse **markdown** for formatting'
        }; 
        const b = new Box(bD, this); 
        this.boxContainer.appendChild(b.element); 
        this.boxes.set(id, b); 
        this.updateHelperText(); 
        b.startEditing(); 
        this.updateCanvasSize(); // Update canvas size after adding a box
        return b; 
    }

    //// Create a new connection or update existing one to be bidirectional
    createOrUpdateConnection(startBox, endBox) { 
        if (!startBox || !endBox || startBox === endBox) return null; 
        
        // Check if there's already a connection in the opposite direction
        let existingConnection = null;
        this.connections.forEach(conn => {
            if (conn.startBox === endBox && conn.endBox === startBox) {
                existingConnection = conn;
            }
        });
        
        // If there's an existing connection, make it bidirectional
        if (existingConnection) {
            existingConnection.data.bidirectional = true;
            existingConnection.element.setAttribute('marker-start', 'url(#arrowhead-start)');
            // No longer changing the style when making bidirectional
            existingConnection.update();
            return existingConnection;
        }
        
        // Otherwise create a new connection
        const id = `conn-${this.nextConnectionId++}`; 
        const cD = { 
            id: id, 
            startBoxId: startBox.data.id, 
            endBoxId: endBox.data.id,
            themeKey: 'default',
            pattern: CONNECTION_PATTERNS.NORMAL,
            thickness: CONNECTION_THICKNESSES.NORMAL,
            bidirectional: false
        }; 
        
        // Create the connection instance
        const conn = new Connection(cD, startBox, endBox, this); 
        this.connections.set(id, conn); 
        
        // Add the connection group to SVG
        // All elements are now inside the group
        this.svg.appendChild(conn.group);
        
        // Apply theme and styles
        conn.applyTheme();
        conn.applyPattern();
        conn.applyThickness();
        
        return conn; 
    }

    deleteBox(boxInstance) { 
        if (!boxInstance) return; 
        const bId = boxInstance.data.id; 
        const cTR = []; 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) cTR.push(c); 
        }); 
        cTR.forEach(c => this.deleteConnection(c)); 
        boxInstance.element.remove(); 
        this.boxes.delete(bId); 
        this.updateHelperText(); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === boxInstance) {
            this.hoveredElement = null;
        }
        
        // Update canvas size after deletion
        this.updateCanvasSize();
    }

    deleteConnection(connInstance) { 
        if (!connInstance) return; 
        
        // Clean up all connection elements
        connInstance.cleanup();
        
        const cId = connInstance.data.id; 
        this.connections.delete(cId); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === connInstance) {
            this.hoveredElement = null;
        }
    }

    updateConnectionsForBox(boxInstance) { 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) c.update(); 
        }); 
    }

    updateHelperText() { 
        this.helperText.style.display = this.boxes.size === 0 ? 'block' : 'none'; 
    }

    // Clear the current diagram
    clearDiagram() {
        // Remove all connections
        this.connections.forEach(conn => {
            conn.cleanup();
        });
        this.connections.clear();
        
        // Remove all boxes
        this.boxes.forEach(box => {
            box.element.remove();
        });
        this.boxes.clear();
        
        // Reset counters
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Export the entire diagram data
    exportData() {
        const boxesData = [];
        this.boxes.forEach(box => {
            boxesData.push(box.exportData());
        });
        
        const connectionsData = [];
        this.connections.forEach(conn => {
            connectionsData.push(conn.exportData());
        });
        
        return {
            boxes: boxesData,
            connections: connectionsData,
            nextBoxId: this.nextBoxId,
            nextConnectionId: this.nextConnectionId
        };
    }

    // Load diagram from exported data
    loadFromProjectData(data) {
        // Clear current diagram
        this.clearDiagram();
        
        // Set counters
        this.nextBoxId = data.nextBoxId || 1;
        this.nextConnectionId = data.nextConnectionId || 1;
        
        // Create boxes first
        const boxMap = new Map(); // Map original IDs to new box instances
        
        if (data.boxes && Array.isArray(data.boxes)) {
            data.boxes.forEach(boxData => {
                const box = new Box(boxData, this);
                this.boxContainer.appendChild(box.element);
                this.boxes.set(boxData.id, box);
                boxMap.set(boxData.id, box);
            });
        }
        
        // Then create connections
        if (data.connections && Array.isArray(data.connections)) {
            data.connections.forEach(connData => {
                const startBox = boxMap.get(connData.startBoxId);
                const endBox = boxMap.get(connData.endBoxId);
                
                if (startBox && endBox) {
                    const conn = new Connection(connData, startBox, endBox, this);
                    this.connections.set(connData.id, conn);
                    
                    // Add the connection group to SVG
                    // All elements are now inside the group
                    this.svg.appendChild(conn.group);
                    
                    // Update connection after adding to DOM
                    conn.update();
                }
            });
        }
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Save the current project through the project manager
    saveCurrentProject() {
        if (this.projectManager) {
            this.projectManager.saveCurrentProject();
        }
    }
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    // Configure marked.js for better rendering
    if (window.marked) {
        marked.setOptions({
            gfm: true,       // GitHub flavored markdown
            breaks: true,    // Add <br> on single line breaks
            headerIds: false,
            mangle: false    // Don't escape HTML
        });
    }
    
    window.diagramManager = new DiagramManager();
    
    // Add example content to the first box if needed
    setTimeout(() => {
        if (window.diagramManager.boxes.size === 0) {
            const exampleBox = window.diagramManager.createBox(window.innerWidth / 2, window.innerHeight * 0.3);
            exampleBox.data.markdown = `# Welcome to FlowChart

This is an enhanced diagram tool with **improved markdown** support.

## Features:
* Ordered and unordered lists
* Tables support
* Adjustable text size

1. Double-click anywhere to add boxes
2. Right-drag to connect boxes
3. Press 'c' to change colors
4. Press 's' to change sizes

### Example Table:
| Feature | Description |
|---------|-------------|
| Lists | Both ordered and unordered |
| Tables | Markdown table support |
| Text Size | Adjustable text scaling |`;
            exampleBox.commitEdit();
        }
    }, 100);
});
</script>

</body>
</html>
