<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* --- Color Palette Variables --- */
        :root {
            /* --- Base Colors --- */
            /* Gray/Default Scale       Red Scale                 Amber/Orange Scale         Yellow Scale                  Green Scale                  Blue Scale              Purple Scale */             
            --gray-50: #EEEDED;       --red-50: #FEEBE8;     --amber-50: #FDF6E5;     --yellow-50: #FEFBE5;      --green-50: #F1F8E8;     --blue-50: #E5F0FA;     --purple-50: #F3EFFA;        
            --gray-100: #E5E3E2;     --red-100: #FEDFDB;    --amber-100: #FCF1D6;    --yellow-100: #FEF9D6;     --green-100: #E9F4DB;    --blue-100: #D6E8F7;    --purple-100: #EDE6F7;        
            --gray-200: #D1CECD;     --red-200: #FDC7C1;    --amber-200: #FBE6B7;    --yellow-200: #FEF5B7;     --green-200: #D9ECC0;    --blue-200: #B7D7F1;    --purple-200: #DFD3F1;        
            --gray-300: #BEB9B7;     --red-300: #FCAFA6;    --amber-300: #F9DC99;    --yellow-300: #FEF199;     --green-300: #C9E5A5;    --blue-300: #99C6EB;    --purple-300: #D2C0EB;        
            --gray-400: #9E9694;     --red-400: #FB877A;    --amber-400: #F7CB66;    --yellow-400: #FEEA66;     --green-400: #AED879;    --blue-400: #66AAE1;    --purple-400: #BCA1E1;        
            --gray-500: #7C726E;     --red-500: #FA5D4B;    --amber-500: #F4B930;    --yellow-500: #FEE330;     --green-500: #91CA4A;    --blue-500: #308CD7;    --purple-500: #A580D6;        
            --gray-600: #5E514D;     --red-600: #F93822;    --amber-600: #F2A900;    --yellow-600: #FEDD00;     --green-600: #78BE20;    --blue-600: #0072CE;    --purple-600: #9063CD;        
            --gray-700: #463C39;     --red-700: #BA2A19;    --amber-700: #B57E00;    --yellow-700: #BEA500;     --green-700: #5A8E18;    --blue-700: #00559A;    --purple-700: #6C4A99;        
            --gray-800: #332C2A;     --red-800: #881E12;    --amber-800: #855C00;    --yellow-800: #8B7900;     --green-800: #426811;    --blue-800: #003E71;    --purple-800: #4F3670;        
            --gray-900: #25201E;     --red-900: #63160D;    --amber-900: #604300;    --yellow-900: #655800;     --green-900: #304C0C;    --blue-900: #002D52;    --purple-900: #392752;        
            --gray-950: #171413;     --red-950: #3E0E08;    --amber-950: #3C2A00;    --yellow-950: #3F3700;     --green-950: #1E2F08;    --blue-950: #001C33;    --purple-950: #241833;        

            /* Black, White, and Transparent */
            --black: #000000;
            --white: #ffffff;
            --transparent-black-5: rgba(0, 0, 0, 0.05);
            --transparent-black-8: rgba(0, 0, 0, 0.08);
            --transparent-black-10: rgba(0, 0, 0, 0.1);
            --transparent-black-12: rgba(0, 0, 0, 0.12);
            --transparent-black-15: rgba(0, 0, 0, 0.15);
            --transparent-black-20: rgba(0, 0, 0, 0.2);
            --transparent-black-30: rgba(0, 0, 0, 0.3);
            --transparent-black-35: rgba(0, 0, 0, 0.35);
            --transparent-white-5: rgba(255, 255, 255, 0.05);
            --transparent-white-7: rgba(255, 255, 255, 0.07);
            --transparent-white-10: rgba(255, 255, 255, 0.1);
            
            /* --- Theme Variables (Light Mode) --- */
            --bg-primary: var(--white); --bg-secondary: var(--white); --text-primary: var(--gray-900); --text-secondary: var(--gray-600); --text-muted: var(--gray-500); --border-color: var(--gray-300); --shadow-color: var(--transparent-black-10); --box-shadow: 0 2px 5px var(--transparent-black-8); --box-shadow-hover: 0 8px 15px var(--transparent-black-12); --font-scale: 1; /* Default font scale */
            /* Scrollbar Colors - Light Mode */
            --scrollbar-track: #f1f1f1; --scrollbar-thumb: #c1c1c1; --scrollbar-thumb-hover: #a1a1a1;
            /* Table Variables - Light Mode */
            --table-hover-bg: var(--transparent-black-8);
            
            /* Theme Colors - Light Mode (Simplified) */
            /* Default Theme */
            --theme-default-bg: var(--white); --theme-default-text: var(--gray-800); --theme-default-border: var(--gray-500); --theme-default-stroke: var(--gray-400); --theme-default-table-header-bg: var(--gray-500); --theme-default-table-header-text: var(--white); --theme-default-table-row-odd: var(--white); --theme-default-table-row-even: var(--gray-100);
            /* Red Theme */
            --theme-red-bg: var(--red-100); --theme-red-text: var(--red-900); --theme-red-border: var(--red-500); --theme-red-stroke: var(--red-400); --theme-red-table-header-bg: var(--red-400); --theme-red-table-header-text: var(--red-900); --theme-red-table-row-odd: var(--red-50); --theme-red-table-row-even: var(--red-200);
            /* Green Theme */
            --theme-green-bg: var(--green-100); --theme-green-text: var(--green-900); --theme-green-border: var(--green-500); --theme-green-stroke: var(--green-400); --theme-green-table-header-bg: var(--green-400); --theme-green-table-header-text: var(--green-950); --theme-green-table-row-odd: var(--green-50); --theme-green-table-row-even: var(--green-200);
            /* Blue Theme */
            --theme-blue-bg: var(--blue-100); --theme-blue-text: var(--blue-900); --theme-blue-border: var(--blue-500); --theme-blue-stroke: var(--blue-400); --theme-blue-table-header-bg: var(--blue-400); --theme-blue-table-header-text: var(--blue-900); --theme-blue-table-row-odd: var(--blue-50); --theme-blue-table-row-even: var(--blue-200);
            /* Purple Theme */
            --theme-purple-bg: var(--purple-100); --theme-purple-text: var(--purple-800); --theme-purple-border: var(--purple-500); --theme-purple-stroke: var(--purple-400); --theme-purple-table-header-bg: var(--purple-400); --theme-purple-table-header-text: var(--purple-950); --theme-purple-table-row-odd: var(--purple-50); --theme-purple-table-row-even: var(--purple-200);
            /* Yellow Theme */
            --theme-yellow-bg: var(--yellow-100); --theme-yellow-text: var(--yellow-900); --theme-yellow-border: var(--amber-500); --theme-yellow-stroke: var(--amber-400); --theme-yellow-table-header-bg: var(--amber-400); --theme-yellow-table-header-text: var(--yellow-950); --theme-yellow-table-row-odd: var(--amber-50); --theme-yellow-table-row-even: var(--amber-200);
            /* Grey Theme */
            --theme-grey-bg: var(--gray-200); --theme-grey-text: var(--gray-900); --theme-grey-border: var(--gray-600); --theme-grey-stroke: var(--gray-500); --theme-grey-table-header-bg: var(--gray-600); --theme-grey-table-header-text: var(--gray-50); --theme-grey-table-row-odd: var(--white); --theme-grey-table-row-even: var(--gray-100);
            /* Icon Colors */
            --sun-icon-color: var(--amber-500); --moon-icon-color: var(--blue-600);
            /* Link Colors */
            --link-color: var(--purple-500);
        }

        /* --- Dark Mode Variables --- */
        .dark-mode {
            --bg-primary: var(--gray-800); --bg-secondary: var(--gray-700); --text-primary: var(--gray-50); --text-secondary: var(--gray-300); --text-muted: var(--gray-400); --border-color: var(--gray-600); --shadow-color: var(--transparent-black-30); --box-shadow: 0 2px 5px var(--transparent-black-20); --box-shadow-hover: 0 8px 15px var(--transparent-black-35);
            /* Scrollbar Colors - Dark Mode */
            --scrollbar-track: var(--gray-700); --scrollbar-thumb: var(--gray-600); --scrollbar-thumb-hover: var(--gray-500);
            /* Table Variables - Dark Mode */
            --table-hover-bg: var(--transparent-white-10);
            
            /* Theme Colors - Dark Mode (Simplified) */
            /* Default Theme */
            --theme-default-bg: var(--gray-700); --theme-default-text: var(--gray-50); --theme-default-border: var(--gray-500); --theme-default-stroke: var(--gray-400); --theme-default-table-header-bg: var(--gray-600); --theme-default-table-header-text: var(--gray-100); --theme-default-table-row-odd: var(--gray-800); --theme-default-table-row-even: var(--gray-700);
            /* Red Theme */
            --theme-red-bg: var(--red-900); --theme-red-text: var(--red-200); --theme-red-border: var(--red-600); --theme-red-stroke: var(--red-500); --theme-red-table-header-bg: var(--red-700); --theme-red-table-header-text: var(--red-100); --theme-red-table-row-odd: var(--red-900); --theme-red-table-row-even: var(--red-800);
            /* Green Theme */
            --theme-green-bg: var(--green-900); --theme-green-text: var(--green-200); --theme-green-border: var(--green-600); --theme-green-stroke: var(--green-500); --theme-green-table-header-bg: var(--green-700); --theme-green-table-header-text: var(--green-100); --theme-green-table-row-odd: var(--green-900); --theme-green-table-row-even: var(--green-800);
            /* Blue Theme */
            --theme-blue-bg: var(--blue-900); --theme-blue-text: var(--blue-200); --theme-blue-border: var(--blue-600); --theme-blue-stroke: var(--blue-500); --theme-blue-table-header-bg: var(--blue-700); --theme-blue-table-header-text: var(--blue-100); --theme-blue-table-row-odd: var(--blue-900); --theme-blue-table-row-even: var(--blue-800);
            /* Purple Theme */
            --theme-purple-bg: var(--purple-800); --theme-purple-text: var(--purple-200); --theme-purple-border: var(--purple-600); --theme-purple-stroke: var(--purple-500); --theme-purple-table-header-bg: var(--purple-700); --theme-purple-table-header-text: var(--purple-100); --theme-purple-table-row-odd: var(--purple-900); --theme-purple-table-row-even: var(--purple-800);
            /* Yellow Theme */
            --theme-yellow-bg: var(--yellow-900); --theme-yellow-text: var(--yellow-200); --theme-yellow-border: var(--amber-600); --theme-yellow-stroke: var(--amber-500); --theme-yellow-table-header-bg: var(--yellow-700); --theme-yellow-table-header-text: var(--yellow-100); --theme-yellow-table-row-odd: var(--yellow-900); --theme-yellow-table-row-even: var(--yellow-800);
            /* Grey Theme */
            --theme-grey-bg: var(--gray-800); --theme-grey-text: var(--gray-200); --theme-grey-border: var(--gray-500); --theme-grey-stroke: var(--gray-400); --theme-grey-table-header-bg: var(--gray-700); --theme-grey-table-header-text: var(--gray-50); --theme-grey-table-row-odd: var(--gray-900); --theme-grey-table-row-even: var(--gray-800);
        }

        /* --- Canvas & Container Styles --- */
        #canvas { overflow: visible; }
        #connections { overflow: visible; }
        #box-container { overflow: visible; }

        /* --- Body & General Styles --- */
        body { background-color: var(--bg-primary); color: var(--text-primary); transition: background-color 0.3s ease, color 0.3s ease; overflow-x: auto; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); }

        /* --- Scrollbar Styles --- */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background-color: var(--scrollbar-track); border-radius: 6px; }
        ::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 6px; transition: background-color 0.3s ease; }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-hover); }
        ::-webkit-scrollbar-corner { background-color: var(--scrollbar-track); }
        * { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); }

        /* --- Theme Toggle Icons --- */
        .theme-toggle { position: relative; }
        .theme-toggle svg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #sun-icon, #moon-icon { opacity: 0; transform: translate(-50%, -50%) scale(0.6); display: block; /* Ensure SVGs are always in layout */ }
        body:not(.dark-mode) #sun-icon { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        body.dark-mode #moon-icon { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        body:not(.dark-mode) .theme-toggle:hover #sun-icon { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(45deg); }
        body:not(.dark-mode) .theme-toggle:hover #moon-icon { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        body.dark-mode .theme-toggle:hover #moon-icon { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(-45deg); }
        body.dark-mode .theme-toggle:hover #sun-icon { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #sun-icon { fill: var(--sun-icon-color); color: var(--sun-icon-color); }
        #moon-icon { fill: var(--moon-icon-color); color: var(--moon-icon-color); }

        /* --- Project Title --- */
        #project-title { color: var(--text-muted); font-weight: 300; letter-spacing: 0.05em; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

        /* --- Base Setup --- */
        html { height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }

        /* --- SVG Connection Styles --- */
        .connection-path { stroke-width: 2; fill: none; cursor: pointer; transition: stroke 0.2s ease, stroke-width 0.2s ease, opacity 0.2s ease; pointer-events: none; }
        .connection-hitbox { stroke-width: 12; /* Wide hit area for easier interaction */ stroke: transparent; fill: none; cursor: pointer; pointer-events: stroke; }
        .connection-path:hover { opacity: 0.85; filter: drop-shadow(0 0 2px var(--transparent-black-15)); }

        /* Pattern styles */
        .connection-pattern-normal { stroke-dasharray: none; }
        .connection-pattern-dashed { stroke-dasharray: 10, 5; }
        .connection-pattern-dotted { stroke-dasharray: 2, 4; }

        /* Thickness styles */
        .connection-thickness-thin { stroke-width: 1; }
        .connection-thickness-normal { stroke-width: 2; }
        .connection-thickness-bold { stroke-width: 4; }

        /* --- Arrow hotspot styles --- */
        .arrow-hotspot { fill: transparent; stroke: transparent; cursor: pointer; transition: opacity 0.2s ease; }
        .arrow-hotspot:hover { fill: var(--transparent-black-5); }

        /* --- Custom box styles --- */
        .box-default { border: 1.5px solid var(--border-color); box-shadow: var(--box-shadow); transform: translateY(0); transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.3s ease, border-color 0.3s ease; }
        .box-default:hover { box-shadow: var(--box-shadow-hover); transform: translateY(-2px); }

        /* --- Markdown styling (enhanced) --- */
        .markdown-content { font-size: calc(14px * var(--font-scale)); line-height: 1.5; word-wrap: break-word; color: var(--text-primary); }
        .markdown-content h1 { font-size: calc(1.5em * var(--font-scale)); font-weight: bold; margin-top: 0.5em; margin-bottom: 0.3em; }
        .markdown-content h2 { font-size: calc(1.3em * var(--font-scale)); font-weight: bold; margin-top: 0.4em; margin-bottom: 0.2em; }
        .markdown-content h3 { font-size: calc(1.1em * var(--font-scale)); font-weight: bold; margin-top: 0.3em; margin-bottom: 0.1em; }
        .markdown-content p { margin-bottom: 0.5em; }
        .markdown-content ul, .markdown-content ol { padding-left: 1.5em; margin-bottom: 0.5em; list-style-position: outside; }
        .markdown-content ul { list-style-type: disc; }
        .markdown-content ol { list-style-type: decimal; }
        .markdown-content li { margin-bottom: 0.2em; }
        .markdown-content li > ul, .markdown-content li > ol { margin-top: 0.2em; }
        .markdown-content code { background-color: var(--transparent-black-5); padding: 0.1em 0.2em; border-radius: 0.2em; font-family: monospace; font-size: calc(0.9em * var(--font-scale)); }
        .markdown-content hr { margin: 0.5em 0; border: none; border-top: 1px solid var(--border-color); }
        .markdown-content a { color: var(--link-color); text-decoration: underline; }

        /* --- Table base styling --- */
        .markdown-content table { border-collapse: collapse; width: 100%; margin-bottom: 0.8em; font-size: calc(0.9em * var(--font-scale)); box-shadow: 0 1px 3px var(--transparent-black-10); border-radius: 4px; overflow: hidden; }

        /* Themed table styling */
        /* Default theme tables */
        div[data-theme="default"] .markdown-content table { border-color: var(--theme-default-border); }
        div[data-theme="default"] .markdown-content table th { background-color: var(--theme-default-table-header-bg); color: var(--theme-default-table-header-text); border-color: var(--theme-default-border); }
        div[data-theme="default"] .markdown-content table td { border-color: var(--theme-default-border); color: var(--theme-default-text); }
        div[data-theme="default"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-default-table-row-odd); }
        div[data-theme="default"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-default-table-row-even); }

        /* Red theme tables */
        div[data-theme="red"] .markdown-content table { border-color: var(--theme-red-border); }
        div[data-theme="red"] .markdown-content table th { background-color: var(--theme-red-table-header-bg); color: var(--theme-red-table-header-text); border-color: var(--theme-red-border); }
        div[data-theme="red"] .markdown-content table td { border-color: var(--theme-red-border); color: var(--theme-red-text); }
        div[data-theme="red"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-red-table-row-odd); }
        div[data-theme="red"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-red-table-row-even); }
        /* Green theme tables */
        div[data-theme="green"] .markdown-content table { border-color: var(--theme-green-border); }
        div[data-theme="green"] .markdown-content table th { background-color: var(--theme-green-table-header-bg); color: var(--theme-green-table-header-text); border-color: var(--theme-green-border); }
        div[data-theme="green"] .markdown-content table td { border-color: var(--theme-green-border); color: var(--theme-green-text); }
        div[data-theme="green"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-green-table-row-odd); }
        div[data-theme="green"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-green-table-row-even); }
        /* Blue theme tables */
        div[data-theme="blue"] .markdown-content table { border-color: var(--theme-blue-border); }
        div[data-theme="blue"] .markdown-content table th { background-color: var(--theme-blue-table-header-bg); color: var(--theme-blue-table-header-text); border-color: var(--theme-blue-border); }
        div[data-theme="blue"] .markdown-content table td { border-color: var(--theme-blue-border); color: var(--theme-blue-text); }
        div[data-theme="blue"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-blue-table-row-odd); }
        div[data-theme="blue"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-blue-table-row-even); }
        /* Purple theme tables */
        div[data-theme="purple"] .markdown-content table { border-color: var(--theme-purple-border); }
        div[data-theme="purple"] .markdown-content table th { background-color: var(--theme-purple-table-header-bg); color: var(--theme-purple-table-header-text); border-color: var(--theme-purple-border); }
        div[data-theme="purple"] .markdown-content table td { border-color: var(--theme-purple-border); color: var(--theme-purple-text); }
        div[data-theme="purple"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-purple-table-row-odd); }
        div[data-theme="purple"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-purple-table-row-even); }
        /* Yellow theme tables */
        div[data-theme="yellow"] .markdown-content table { border-color: var(--theme-yellow-border); }
        div[data-theme="yellow"] .markdown-content table th { background-color: var(--theme-yellow-table-header-bg); color: var(--theme-yellow-table-header-text); border-color: var(--theme-yellow-border); }
        div[data-theme="yellow"] .markdown-content table td { border-color: var(--theme-yellow-border); color: var(--theme-yellow-text); }
        div[data-theme="yellow"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-yellow-table-row-odd); }
        div[data-theme="yellow"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-yellow-table-row-even); }
        /* Grey theme tables */
        div[data-theme="grey"] .markdown-content table { border-color: var(--theme-grey-border); }
        div[data-theme="grey"] .markdown-content table th { background-color: var(--theme-grey-table-header-bg); color: var(--theme-grey-table-header-text); border-color: var(--theme-grey-border); }
        div[data-theme="grey"] .markdown-content table td { border-color: var(--theme-grey-border); color: var(--theme-grey-text); }
        div[data-theme="grey"] .markdown-content table tr:nth-child(odd) { background-color: var(--theme-grey-table-row-odd); }
        div[data-theme="grey"] .markdown-content table tr:nth-child(even) { background-color: var(--theme-grey-table-row-even); }

        /* Hover effect for table rows */
        .markdown-content table tr:hover { background-color: var(--table-hover-bg); }

        /* --- Textarea styling --- */
        .edit-textarea { width: 100%; height: 100%; box-sizing: border-box; padding: 0.5rem; border: none; font-family: inherit; font-size: calc(14px * var(--font-scale)); line-height: 1.5; resize: none; overflow: auto; background-color: transparent; color: var(--text-primary); }
        .edit-textarea:focus { outline: none; }

        /* --- Transitions and Animations --- */
        .box-transition { transition: width 0.2s ease, height 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; }
        #preview-connection { stroke-dasharray: 5, 5; animation: dash 15s linear infinite; stroke: var(--text-secondary); }
        @keyframes dash { to { stroke-dashoffset: -1000; } }

        /* --- Theme-specific box/text classes for light mode --- */
        .light-default-bg { background-color: var(--theme-default-bg); }
        .light-default-text { color: var(--theme-default-text); }
        .light-default-border { border-color: var(--theme-default-border); }

        .light-red-bg { background-color: var(--theme-red-bg); }
        .light-red-text { color: var(--theme-red-text); }
        .light-red-border { border-color: var(--theme-red-border); }

        .light-green-bg { background-color: var(--theme-green-bg); }
        .light-green-text { color: var(--theme-green-text); }
        .light-green-border { border-color: var(--theme-green-border); }

        .light-blue-bg { background-color: var(--theme-blue-bg); }
        .light-blue-text { color: var(--theme-blue-text); }
        .light-blue-border { border-color: var(--theme-blue-border); }

        .light-purple-bg { background-color: var(--theme-purple-bg); }
        .light-purple-text { color: var(--theme-purple-text); }
        .light-purple-border { border-color: var(--theme-purple-border); }

        .light-yellow-bg { background-color: var(--theme-yellow-bg); }
        .light-yellow-text { color: var(--theme-yellow-text); }
        .light-yellow-border { border-color: var(--theme-yellow-border); }

        .light-grey-bg { background-color: var(--theme-grey-bg); }
        .light-grey-text { color: var(--theme-grey-text); }
        .light-grey-border { border-color: var(--theme-grey-border); }

        /* --- Theme-specific box/text classes for dark mode --- */
        .dark-default-bg { background-color: var(--theme-default-bg); }
        .dark-default-text { color: var(--theme-default-text); }
        .dark-default-border { border-color: var(--theme-default-border); }

        .dark-red-bg { background-color: var(--theme-red-bg); }
        .dark-red-text { color: var(--theme-red-text); }
        .dark-red-border { border-color: var(--theme-red-border); }

        .dark-green-bg { background-color: var(--theme-green-bg); }
        .dark-green-text { color: var(--theme-green-text); }
        .dark-green-border { border-color: var(--theme-green-border); }

        .dark-blue-bg { background-color: var(--theme-blue-bg); }
        .dark-blue-text { color: var(--theme-blue-text); }
        .dark-blue-border { border-color: var(--theme-blue-border); }

        .dark-purple-bg { background-color: var(--theme-purple-bg); }
        .dark-purple-text { color: var(--theme-purple-text); }
        .dark-purple-border { border-color: var(--theme-purple-border); }

        .dark-yellow-bg { background-color: var(--theme-yellow-bg); }
        .dark-yellow-text { color: var(--theme-yellow-text); }
        .dark-yellow-border { border-color: var(--theme-yellow-border); }

        .dark-grey-bg { background-color: var(--theme-grey-bg); }
        .dark-grey-text { color: var(--theme-grey-text); }
        .dark-grey-border { border-color: var(--theme-grey-border); }

        /* --- Modal styles --- */
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.5); transition: opacity 0.3s ease; }
        .modal-content { transform: translateY(20px); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; }
        .modal.open .modal-backdrop { opacity: 1; }
        .modal.open .modal-content { transform: translateY(0); opacity: 1; }

        /* --- Project item styling --- */
        .project-item { border-radius: 4px; overflow: hidden; transition: all 0.2s ease; }
        .project-item .project-container { background-color: rgba(0, 0, 0, 0.08); }
        body.dark-mode .project-item .project-container { background-color: rgba(255, 255, 255, 0.1); /* Higher contrast in dark mode */ }
        .project-item.active { box-shadow: 0 0 0 2px var(--blue-500); /* Blue outline for active project */ }
        .project-item.active .project-container { background-color: rgba(0, 114, 206, 0.1); /* Light blue background */ }
        body.dark-mode .project-item.active .project-container { background-color: rgba(0, 114, 206, 0.2); /* Slightly stronger in dark mode */ }

        /* --- Section header styling --- */
        .settings-section-header { color: var(--text-muted); font-weight: 300; }
    </style>
</head>
<body class="h-screen m-0 p-0">
    <!-- Project title header -->
    <div id="project-title-container" class="fixed top-5 left-0 w-full text-center pointer-events-none z-0">
        <h1 id="project-title" class="text-3xl tracking-wide"></h1>
    </div>

    <div id="canvas" class="relative w-full cursor-default">
        <svg id="connections" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10" style="overflow: visible;">
            <defs>
                <marker id="arrowhead-end" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="currentColor"/>
                </marker>
                <marker id="arrowhead-start" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                    <polygon points="10 0, 0 3.5, 10 7" fill="currentColor"/>
                </marker>
            </defs>
            <path id="preview-connection" stroke="currentColor" stroke-width="2" fill="none" marker-end="url(#arrowhead-end)" opacity="0.5" display="none" stroke-dasharray="5, 5"/>
        </svg>
        <div id="box-container" class="absolute top-0 left-0 w-full z-20 pointer-events-none"></div>
        <div id="helper-text" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-gray-500 text-lg text-center pointer-events-none select-none z-0">
             Double click anywhere to add a box<br>
             <span class="text-sm">Use Markdown in boxes for formatting</span>
         </div>
    </div>
    
    <!-- Settings Menu with Fixed New Project Form -->
    <div id="settings-menu" class="fixed bottom-12 right-2 w-72 rounded-lg shadow-lg z-50 overflow-hidden transition-all duration-200 max-h-[80vh] flex flex-col hidden opacity-0 transform translate-y-2 pointer-events-none" style="background-color: var(--bg-secondary); color: var(--text-primary); box-shadow: 0 5px 15px var(--shadow-color);">
        <div class="px-4 py-3 border-b border-solid" style="border-color: var(--border-color);">
            <div class="flex justify-between items-center">
                <h3 class="text-base settings-section-header m-0">Projects</h3>
                <div class="flex items-center">
                    <button id="export-projects-button" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm mr-1" title="Export Projects">
                        <i class="fas fa-file-export"></i>
                    </button>
                    <button id="import-projects-button" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm mr-1" title="Import Projects">
                        <i class="fas fa-file-import"></i>
                    </button>
                    <button id="add-project-toggle" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors text-sm">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="px-4 py-3 overflow-y-auto max-h-[50vh]">
            <!-- New project form (hidden by default) -->
            <div id="new-project-form" class="mb-3 hidden overflow-hidden transition-all duration-200 max-h-0">
                <div class="flex flex-col mb-2">
                    <input type="text" id="project-name" class="w-full p-2 rounded border border-solid mb-2" placeholder="Enter project name"
                        style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                    <div class="flex justify-end">
                        <button id="commit-new-project" class="w-7 h-7 flex items-center justify-center rounded hover:bg-black hover:bg-opacity-10 transition-colors" style="color: var(--green-500);" title="Save Project">
                            <i class="fas fa-check"></i>
                        </button>
                        <button id="cancel-new-project" class="w-7 h-7 flex items-center justify-center rounded hover:bg-black hover:bg-opacity-10 transition-colors ml-1" style="color: var(--red-500);" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="project-list" class="space-y-2">
                <!-- Projects will be loaded here -->
                <div class="text-center py-3" id="no-projects-message" style="color: var(--text-muted);">No projects yet</div>
            </div>
        </div>
        
        <div class="h-px w-full" style="background-color: var(--border-color);"></div>
        
        <div class="px-4 py-3 border-t border-solid" style="border-color: var(--border-color);">
            <div class="flex justify-between items-start">
                <!-- Text Size Section -->
                <div>
                    <label class="block mb-1 settings-section-header text-sm">Text Size</label>
                    <div class="flex items-center">
                        <button id="text-scale-decrease" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors">
                            <i class="fas fa-minus"></i>
                        </button>
                        <span class="inline-block font-medium px-2" id="text-scale-value">1.00x</span>
                        <button id="text-scale-increase" class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Export SVG Section -->
                <div>
                    <label class="block mb-1 settings-section-header text-sm">Export</label>
                    <button id="export-svg-button" class="px-3 py-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors flex items-center" title="Export to SVG">
                        <i class="fas fa-print mr-1"></i>
                        <span>SVG</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme toggle button with improved icons -->
    <div class="theme-toggle fixed bottom-2.5 right-12 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" id="theme-toggle" title="Toggle dark/light mode">
        <!-- Sun icon (filled, yellow) -->
        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        
        <!-- Moon icon (filled, dark blue) -->
        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
    </div>
    
    <!-- Settings button (gear icon) -->
    <div class="fixed bottom-2.5 right-2.5 w-8 h-8 rounded-full flex items-center justify-center cursor-pointer text-lg z-50" id="settings-button" style="background-color: var(--bg-secondary); color: var(--text-secondary); box-shadow: 0 2px 4px var(--shadow-color);" title="Projects & Settings">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>

<script>
// --- Constants ---
const INITIAL_BOX_WIDTH = 200;
const INITIAL_BOX_HEIGHT = 80;
const LINE_HEIGHT = 23; // Height per line in pixels
const PADDING_HEIGHT = 30; // Additional padding for box height

// Width type constants
const WIDTH_TYPES = { SMALL: 'small', MEDIUM: 'medium', LARGE: 'large' };
const WIDTH_TYPE_VALUES = { [WIDTH_TYPES.SMALL]: 200, [WIDTH_TYPES.MEDIUM]: 350, [WIDTH_TYPES.LARGE]: 500 };

// Separated connection style constants
const CONNECTION_PATTERNS = {
    NORMAL: 'normal',
    DASHED: 'dashed',
    DOTTED: 'dotted'
};

const CONNECTION_THICKNESSES = {
    THIN: 'thin',
    NORMAL: 'normal',
    BOLD: 'bold'
};

// Enhanced color theme configuration with light and dark variants
const COLOR_THEMES = {
    default: {
        name: 'Default',
        light: {
            bg: 'light-default-bg',
            border: 'light-default-border',
            text: 'light-default-text',
            stroke: 'var(--theme-default-stroke)'
        },
        dark: {
            bg: 'dark-default-bg',
            border: 'dark-default-border',
            text: 'dark-default-text',
            stroke: 'var(--theme-default-stroke)'
        }
    },
    red: {
        name: 'Red',
        light: {
            bg: 'light-red-bg',
            border: 'light-red-border',
            text: 'light-red-text',
            stroke: 'var(--theme-red-stroke)'
        },
        dark: {
            bg: 'dark-red-bg',
            border: 'dark-red-border',
            text: 'dark-red-text',
            stroke: 'var(--theme-red-stroke)'
        }
    },
    green: {
        name: 'Green',
        light: {
            bg: 'light-green-bg',
            border: 'light-green-border',
            text: 'light-green-text',
            stroke: 'var(--theme-green-stroke)'
        },
        dark: {
            bg: 'dark-green-bg',
            border: 'dark-green-border',
            text: 'dark-green-text',
            stroke: 'var(--theme-green-stroke)'
        }
    },
    blue: {
        name: 'Blue',
        light: {
            bg: 'light-blue-bg',
            border: 'light-blue-border',
            text: 'light-blue-text',
            stroke: 'var(--theme-blue-stroke)'
        },
        dark: {
            bg: 'dark-blue-bg',
            border: 'dark-blue-border',
            text: 'dark-blue-text',
            stroke: 'var(--theme-blue-stroke)'
        }
    },
    purple: {
        name: 'Purple',
        light: {
            bg: 'light-purple-bg',
            border: 'light-purple-border',
            text: 'light-purple-text',
            stroke: 'var(--theme-purple-stroke)'
        },
        dark: {
            bg: 'dark-purple-bg',
            border: 'dark-purple-border',
            text: 'dark-purple-text',
            stroke: 'var(--theme-purple-stroke)'
        }
    },
    yellow: {
        name: 'Yellow',
        light: {
            bg: 'light-yellow-bg',
            border: 'light-yellow-border',
            text: 'light-yellow-text',
            stroke: 'var(--theme-yellow-stroke)'
        },
        dark: {
            bg: 'dark-yellow-bg',
            border: 'dark-yellow-border',
            text: 'dark-yellow-text',
            stroke: 'var(--theme-yellow-stroke)'
        }
    },
    grey: {
        name: 'Grey',
        light: {
            bg: 'light-grey-bg',
            border: 'light-grey-border',
            text: 'light-grey-text',
            stroke: 'var(--theme-grey-stroke)'
        },
        dark: {
            bg: 'dark-grey-bg',
            border: 'dark-grey-border',
            text: 'dark-grey-text',
            stroke: 'var(--theme-grey-stroke)'
        }
    }
};

// Get all theme keys for cycling
const THEME_KEYS = Object.keys(COLOR_THEMES);

// Define base classes for reuse in JS - using Tailwind utility classes
const BASE_BOX_CLASSES = 'absolute rounded-lg box-default cursor-move no-select py-2 px-3 pointer-events-auto overflow-hidden box-transition';

// Enhanced markdown parser with better support for lists and tables
function simpleMarkdownParser(text) {
    if (!text) return '';
    
    // Store code blocks so they don't get processed
    const codeBlocks = [];
    text = text.replace(/```([\s\S]*?)```/g, function(match) {
        codeBlocks.push(match);
        return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
    });
    
    // Process text
    text = text
        // Headers
        .replace(/### (.*?)(\n|$)/g, '<h3>$1</h3>\n')
        .replace(/## (.*?)(\n|$)/g, '<h2>$1</h2>\n')
        .replace(/# (.*?)(\n|$)/g, '<h1>$1</h1>\n')
        
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        
        // Inline code
        .replace(/`([^`]*)`/g, '<code>$1</code>')
        
        // Horizontal rule
        .replace(/^---+$/gm, '<hr>')
        
        // Tables - this is a simplified implementation
        .replace(/^\|(.+)\|$/gm, function(match, content) {
            // Split the table row into cells
            const cells = content.split('|').map(cell => cell.trim());
            
            // Check if this is a header separator row (contains only dashes and colons)
            if (cells.every(cell => /^:?-+:?$/.test(cell))) {
                return match; // Return unchanged, we'll remove these later
            }
            
            // Create table cells
            const cellsHtml = cells.map(cell => `<td>${cell}</td>`).join('');
            return `<tr>${cellsHtml}</tr>`;
        })
        // Process tables by finding consecutive table rows
        .replace(/(<tr>.*?<\/tr>)\n\|([-:\s|]+)\|\n(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, headerRow, separatorRow, bodyRows) {
            // Convert the header row's cells to <th> instead of <td>
            const tableHeader = headerRow.replace(/<td>(.*?)<\/td>/g, '<th>$1</th>');
            return `<table><thead>${tableHeader}</thead><tbody>${bodyRows}</tbody></table>`;
        })
        // Handle tables without headers
        .replace(/(<tr>.*?<\/tr>(\n<tr>.*?<\/tr>)*)/g, function(match, rows) {
            // Only convert to a table if it's not already in a table
            if (!match.includes('<table>')) {
                return `<table><tbody>${rows}</tbody></table>`;
            }
            return match;
        })
        
        // Ordered lists - look for consecutive lines starting with numbers
        .replace(/^(\d+\. .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the number and period, then trim
                const content = item.replace(/^\d+\.\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ol>${listItems}</ol>\n`;
        })
        
        // Unordered lists - handle multiple list markers
        .replace(/^([\*\-\+] .+\n)+/gm, function(match) {
            // Split the list items
            const items = match.trim().split('\n');
            const listItems = items.map(item => {
                // Remove the list marker, then trim
                const content = item.replace(/^[\*\-\+]\s*/, '');
                return `<li>${content}</li>`;
            }).join('');
            return `<ul>${listItems}</ul>\n`;
        })
        
        // Paragraphs (lines not already processed)
        .replace(/^([^\n<][^\n]*?)(?:\n|$)/gm, function(match, content) {
            // Don't wrap empty lines in <p> tags
            if (content.trim() === '') return '\n';
            // Don't wrap lines that are likely part of lists or other block elements
            if (/^<\/(ol|ul|table|h[1-6])>/.test(content)) return content + '\n';
            return `<p>${content}</p>\n`;
        })
        
        // Clean up extra newlines
        .replace(/\n+/g, '\n');
    
    // Restore code blocks
    text = text.replace(/__CODE_BLOCK_(\d+)__/g, function(match, index) {
        const code = codeBlocks[parseInt(index)]
            .replace(/```(?:\w+)?\n([\s\S]*?)```/g, '$1')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        return `<pre><code>${code}</code></pre>`;
    });
    
    return text;
}

// Helper to safely remove CSS classes
function safeRemoveClass(element, className) {
    if (element && className && className.trim() !== '') {
        element.classList.remove(className);
    }
}

// --- ImportManager Class ---
class ImportManager {
    constructor(projectManager) {
        this.projectManager = projectManager;
        this.modal = this.createModal();
        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }
    
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'import-projects-modal';
        modal.className = 'fixed inset-0 flex items-center justify-center z-50 hidden modal';
        
        modal.innerHTML = `
            <div class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop" id="import-modal-backdrop"></div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl z-10 w-full max-w-md max-h-[80vh] flex flex-col overflow-hidden modal-content" 
                 style="background-color: var(--bg-secondary); color: var(--text-primary);">
                <div class="px-4 py-3 border-b border-solid flex justify-between items-center" 
                     style="border-color: var(--border-color);">
                    <h3 class="text-lg font-semibold">Import Projects</h3>
                    <button id="close-import-modal" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 flex flex-col">
                    <div class="mb-4">
                        <label class="block mb-2">Select JSON file containing projects:</label>
                        <input type="file" id="import-file-input" accept=".json" class="w-full p-2 border rounded"
                               style="border-color: var(--border-color); background-color: var(--bg-primary);">
                    </div>
                    
                    <div class="mb-4 hidden" id="import-projects-list-container">
                        <label class="block mb-2">Select projects to import:</label>
                        <div id="import-projects-list" class="border rounded p-2 max-h-48 overflow-y-auto"
                             style="border-color: var(--border-color); background-color: var(--bg-primary);">
                            <!-- Project checkboxes will be dynamically added here -->
                        </div>
                    </div>
                </div>
                
                <div class="px-4 py-3 border-t border-solid flex justify-end" 
                     style="border-color: var(--border-color);">
                    <button id="import-selected-projects" class="px-4 py-2 bg-purple-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Import Selected
                    </button>
                </div>
            </div>
        `;
        
        return modal;
    }
    
    setupEventListeners() {
        const modal = this.modal;
        const backdrop = modal.querySelector('#import-modal-backdrop');
        const closeButton = modal.querySelector('#close-import-modal');
        const fileInput = modal.querySelector('#import-file-input');
        const importButton = modal.querySelector('#import-selected-projects');
        
        // Close modal when clicking backdrop or close button
        backdrop.addEventListener('click', () => this.closeModal());
        closeButton.addEventListener('click', () => this.closeModal());
        
        // Handle file selection
        fileInput.addEventListener('change', (e) => this.handleFileSelection(e));
        
        // Handle import button click
        importButton.addEventListener('click', () => this.importSelectedProjects());
    }
    
    openModal() {
        this.modal.classList.remove('hidden');
        setTimeout(() => {
            this.modal.classList.add('open');
        }, 10);
    }
    
    closeModal() {
        const modal = this.modal;
        const fileInput = modal.querySelector('#import-file-input');
        const container = modal.querySelector('#import-projects-list-container');
        
        // Animate out
        modal.classList.remove('open');
        
        // Reset state
        fileInput.value = '';
        container.classList.add('hidden');
        
        // Hide modal after animation
        setTimeout(() => {
            modal.classList.add('hidden');
        }, 300);
    }
    
    handleFileSelection(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const importedData = JSON.parse(event.target.result);
                if (Array.isArray(importedData)) {
                    this.displayImportProjects(importedData);
                } else {
                    alert('Invalid project file format');
                }
            } catch (error) {
                console.error('Error parsing JSON:', error);
                alert('Error parsing file: ' + error.message);
            }
        };
        
        reader.readAsText(file);
    }
    
    displayImportProjects(importedProjects) {
        const modal = this.modal;
        const container = modal.querySelector('#import-projects-list-container');
        const projectsList = modal.querySelector('#import-projects-list');
        const importButton = modal.querySelector('#import-selected-projects');
        
        // Show the projects list container
        container.classList.remove('hidden');
        
        // Clear previous list
        projectsList.innerHTML = '';
        
        // Get current projects for comparison
        const currentProjects = this.projectManager.projects;
        const currentProjectsMap = new Map();
        currentProjects.forEach(project => {
            currentProjectsMap.set(project.name, project);
        });
        
        // Flag to track if any projects are available for import
        let hasSelectableProjects = false;
        
        // Add checkboxes for each project
        importedProjects.forEach(project => {
            const listItem = document.createElement('div');
            listItem.className = 'flex items-center p-1 border-b last:border-b-0';
            listItem.style.borderColor = 'var(--border-color)';
            
            const isConflict = currentProjectsMap.has(project.name);
            let isNewer = false;
            let shouldSelect = true;
            
            if (isConflict) {
                const currentProject = currentProjectsMap.get(project.name);
                isNewer = new Date(project.dateModified) > new Date(currentProject.dateModified);
                shouldSelect = isNewer;
                
                // Apply color based on date comparison
                listItem.style.color = isNewer ? 'var(--theme-green-text)' : 'var(--theme-red-text)';
            }
            
            // Format date
            const modifiedDate = new Date(project.dateModified).toLocaleDateString();
            
            listItem.innerHTML = `
                <label class="flex items-center w-full cursor-pointer">
                    <input type="checkbox" class="mr-2 import-project-checkbox" value="${project.id}" 
                           data-name="${project.name}" ${shouldSelect ? 'checked' : ''}>
                    <div class="flex-1">
                        <div class="font-medium">${project.name}</div>
                        <div class="text-xs opacity-70">Modified: ${modifiedDate}</div>
                        ${isConflict ? `<div class="text-xs font-medium">
                            ${isNewer ? '(Newer than existing project)' : '(Older than existing project)'}
                        </div>` : ''}
                    </div>
                </label>
            `;
            
            projectsList.appendChild(listItem);
            hasSelectableProjects = true;
        });
        
        // Enable/disable import button
        importButton.disabled = !hasSelectableProjects;
        
        if (!hasSelectableProjects) {
            projectsList.innerHTML = '<div class="p-2 text-center text-gray-500">No projects available to import</div>';
        }
    }
    
    importSelectedProjects() {
        const modal = this.modal;
        const checkboxes = modal.querySelectorAll('.import-project-checkbox:checked');
        const fileInput = modal.querySelector('#import-file-input');
        
        if (checkboxes.length === 0 || !fileInput.files[0]) {
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const importedProjects = JSON.parse(event.target.result);
                if (!Array.isArray(importedProjects)) {
                    throw new Error('Invalid project format');
                }
                
                // Get selected project IDs
                const selectedIds = Array.from(checkboxes).map(cb => cb.value);
                
                // Filter projects to only selected ones
                const projectsToImport = importedProjects.filter(project => 
                    selectedIds.includes(project.id));
                
                // Create a map of existing project names for comparison
                const existingProjectNames = new Map();
                this.projectManager.projects.forEach(project => {
                    existingProjectNames.set(project.name, project);
                });
                
                // Import projects, replacing any with the same name
                projectsToImport.forEach(project => {
                    // If project with same name exists, remove it
                    if (existingProjectNames.has(project.name)) {
                        const existingProject = existingProjectNames.get(project.name);
                        const existingIndex = this.projectManager.projects.findIndex(p => p.id === existingProject.id);
                        if (existingIndex >= 0) {
                            this.projectManager.projects.splice(existingIndex, 1);
                        }
                    }
                    
                    // Add the imported project
                    this.projectManager.projects.push(project);
                });
                
                // Save and update UI
                this.projectManager.saveProjects();
                this.projectManager.renderProjectList();
                
                // Close modal and show success message
                this.closeModal();
                alert(`Successfully imported ${projectsToImport.length} project(s)`);
                
            } catch (error) {
                console.error('Error importing projects:', error);
                alert('Error importing projects: ' + error.message);
            }
        };
        
        reader.readAsText(fileInput.files[0]);
    }
}

// --- ExportManager Class ---
class ExportManager {
    constructor(projectManager) {
        this.projectManager = projectManager;
        this.modal = this.createModal();
        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }
    
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'export-projects-modal';
        modal.className = 'fixed inset-0 flex items-center justify-center z-50 hidden modal';
        
        modal.innerHTML = `
            <div class="fixed inset-0 bg-black bg-opacity-50 modal-backdrop" id="export-modal-backdrop"></div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl z-10 w-full max-w-md max-h-[80vh] flex flex-col overflow-hidden modal-content" 
                 style="background-color: var(--bg-secondary); color: var(--text-primary);">
                <div class="px-4 py-3 border-b border-solid flex justify-between items-center" 
                     style="border-color: var(--border-color);">
                    <h3 class="text-lg font-semibold">Export Projects</h3>
                    <button id="close-export-modal" class="p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 flex flex-col">
                    <div class="mb-4">
                        <label class="block mb-2">Select projects to export:</label>
                        <div id="export-projects-list" class="border rounded p-2 max-h-48 overflow-y-auto"
                             style="border-color: var(--border-color); background-color: var(--bg-primary);">
                            <!-- Project checkboxes will be dynamically added here -->
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block mb-2" for="export-filename">Filename:</label>
                        <input type="text" id="export-filename" class="w-full p-2 border rounded" value="flowchart-projects.json"
                               style="border-color: var(--border-color); background-color: var(--bg-primary);">
                    </div>
                </div>
                
                <div class="px-4 py-3 border-t border-solid flex justify-end" 
                     style="border-color: var(--border-color);">
                    <button id="export-selected-projects" class="px-4 py-2 bg-purple-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        Export Selected
                    </button>
                </div>
            </div>
        `;
        
        return modal;
    }
    
    setupEventListeners() {
        const modal = this.modal;
        const backdrop = modal.querySelector('#export-modal-backdrop');
        const closeButton = modal.querySelector('#close-export-modal');
        const exportButton = modal.querySelector('#export-selected-projects');
        
        // Close modal when clicking backdrop or close button
        backdrop.addEventListener('click', () => this.closeModal());
        closeButton.addEventListener('click', () => this.closeModal());
        
        // Handle export button click
        exportButton.addEventListener('click', () => this.exportSelectedProjects());
    }
    
    openModal() {
        this.populateProjectsList();
        
        this.modal.classList.remove('hidden');
        setTimeout(() => {
            this.modal.classList.add('open');
        }, 10);
    }
    
    closeModal() {
        this.modal.classList.remove('open');
        
        // Hide modal after animation
        setTimeout(() => {
            this.modal.classList.add('hidden');
        }, 300);
    }
    
    populateProjectsList() {
        const modal = this.modal;
        const projectsList = modal.querySelector('#export-projects-list');
        const exportButton = modal.querySelector('#export-selected-projects');
        
        // Clear previous list
        projectsList.innerHTML = '';
        
        // Get current projects
        const projects = this.projectManager.projects;
        
        // Add checkboxes for each project
        if (projects.length > 0) {
            // Add "Select All" checkbox
            const selectAllContainer = document.createElement('div');
            selectAllContainer.className = 'flex items-center p-1 bg-black bg-opacity-5 sticky top-0 border-b';
            selectAllContainer.style.borderColor = 'var(--border-color)';
            
            selectAllContainer.innerHTML = `
                <label class="flex items-center w-full cursor-pointer">
                    <input type="checkbox" id="select-all-export" class="mr-2" checked>
                    <div class="font-medium">Select All</div>
                </label>
            `;
            
            projectsList.appendChild(selectAllContainer);
            
            // Add event listener for select all
            modal.querySelector('#select-all-export').addEventListener('change', function() {
                const checkboxes = modal.querySelectorAll('.export-project-checkbox');
                checkboxes.forEach(cb => {
                    cb.checked = this.checked;
                });
            });
            
            // Add project items
            projects.forEach(project => {
                const modifiedDate = new Date(project.dateModified).toLocaleDateString();
                
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1 border-b last:border-b-0';
                listItem.style.borderColor = 'var(--border-color)';
                
                listItem.innerHTML = `
                    <label class="flex items-center w-full cursor-pointer">
                        <input type="checkbox" class="mr-2 export-project-checkbox" value="${project.id}" checked>
                        <div class="flex-1">
                            <div class="font-medium">${project.name}</div>
                            <div class="text-xs opacity-70">Modified: ${modifiedDate}</div>
                        </div>
                    </label>
                `;
                
                projectsList.appendChild(listItem);
            });
            
            // Enable export button
            exportButton.disabled = false;
        } else {
            projectsList.innerHTML = '<div class="p-2 text-center text-gray-500">No projects available to export</div>';
            exportButton.disabled = true;
        }
    }
    
    exportSelectedProjects() {
        const modal = this.modal;
        const checkboxes = modal.querySelectorAll('.export-project-checkbox:checked');
        
        if (checkboxes.length === 0) {
            alert('Please select at least one project to export');
            return;
        }
        
        // Get selected project IDs
        const selectedIds = Array.from(checkboxes).map(cb => cb.value);
        
        // Get projects from projectManager
        const selectedProjects = this.projectManager.projects.filter(project => 
            selectedIds.includes(project.id));
        
        // Create JSON data
        const jsonData = JSON.stringify(selectedProjects, null, 2);
        
        // Get filename
        const filenameInput = modal.querySelector('#export-filename');
        let filename = filenameInput.value.trim();
        if (!filename) {
            filename = 'flowchart-projects.json';
        } else if (!filename.toLowerCase().endsWith('.json')) {
            filename += '.json';
        }
        
        // Create download link
        const dataStr = 'data:text/json;charset=utf-8,' + encodeURIComponent(jsonData);
        const downloadAnchor = document.createElement('a');
        downloadAnchor.setAttribute('href', dataStr);
        downloadAnchor.setAttribute('download', filename);
        document.body.appendChild(downloadAnchor);
        
        // Trigger download
        downloadAnchor.click();
        
        // Clean up
        document.body.removeChild(downloadAnchor);
        
        // Close modal
        this.closeModal();
    }
}

// --- SVG Export Manager Class ---
class SVGExportManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager;
    }
    
    // Export the current diagram as an SVG file
    exportSVG() {
        // Get all the elements to include in the export
        const boxes = this.diagramManager.boxes;
        const connections = this.diagramManager.connections;
        
        // Create a new SVG element
        const svgNamespace = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNamespace, "svg");
        
        // Find the bounding box for all elements
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        
        // Include space for the title at the top
        const titleHeight = 60; // Reserve space for title
        minY = Math.min(minY, 0); // Ensure we start from the top
        
        // Calculate bounds from boxes
        boxes.forEach(box => {
            const bounds = box.getBounds();
            minX = Math.min(minX, bounds.left);
            minY = Math.min(minY, bounds.top);
            maxX = Math.max(maxX, bounds.right);
            maxY = Math.max(maxY, bounds.bottom);
        });
        
        // Add padding
        const padding = 20;
        minX = Math.max(0, minX - padding);
        minY = Math.max(0, minY - padding - titleHeight); // Extra space for title
        maxX += padding;
        maxY += padding;
        
        // Calculate exact dimensions
        const width = maxX - minX;
        const height = maxY - minY + titleHeight;
        
        // Set SVG attributes
        svg.setAttribute("width", width + "px");
        svg.setAttribute("height", height + "px");
        svg.setAttribute("viewBox", `${minX} ${minY} ${width} ${height}`);
        
        // Get the current theme mode
        const isDarkMode = document.body.classList.contains('dark-mode');
        
        // Add class to SVG root for dark mode
        if (isDarkMode) {
            svg.classList.add('dark-mode');
            
            // Create a background rectangle for dark mode only
            const darkBgColor = getComputedStyle(document.documentElement)
                .getPropertyValue('--bg-primary')
                .trim();
                
            // Verify we have a dark color (simple check based on common dark mode colors)
            // Only add background if we're confident it's dark mode
            if (darkBgColor.includes('rgb(31,') || darkBgColor.includes('#1f') || 
                darkBgColor.includes('rgb(30,') || darkBgColor.includes('#30') ||
                darkBgColor.includes('rgb(55,') || darkBgColor.includes('#37') ||
                darkBgColor === '#1f2937' || darkBgColor === '#374151') {
                
                const bgRect = document.createElementNS(svgNamespace, "rect");
                bgRect.setAttribute("x", minX);
                bgRect.setAttribute("y", minY);
                bgRect.setAttribute("width", width);
                bgRect.setAttribute("height", height);
                bgRect.setAttribute("fill", darkBgColor);
                
                // Insert background as first element
                svg.appendChild(bgRect);
            }
        }
        // No background rect added in light mode
        
        // Add metadata about theme mode
        const metadata = document.createElementNS(svgNamespace, "metadata");
        metadata.textContent = JSON.stringify({
            themeMode: isDarkMode ? 'dark' : 'light',
            exportDate: new Date().toISOString()
        });
        svg.appendChild(metadata);
        
        // Add style definitions that include all CSS variables and classes
        const style = document.createElementNS(svgNamespace, "style");
        style.textContent = this.extractThemeStyles();
        svg.appendChild(style);
        
        // Create a defs section for markers (arrowheads)
        const defs = document.createElementNS(svgNamespace, "defs");
        
        // Add theme-specific arrow markers for all themes
        Object.keys(COLOR_THEMES).forEach(themeKey => {
            // Create markers for both light and dark modes
            this.createArrowMarkers(defs, themeKey, 'light');
            this.createArrowMarkers(defs, themeKey, 'dark');
        });
        
        svg.appendChild(defs);
        
        // Add project title at the top
        this.addProjectTitle(svg, svgNamespace, minX, minY, width);
        
        // Create a group for connections
        const connectionsGroup = document.createElementNS(svgNamespace, "g");
        connectionsGroup.setAttribute("class", "connections");
        
        // Add all connections
        connections.forEach(connection => {
            const connectionGroup = document.createElementNS(svgNamespace, "g");
            const themeKey = connection.data.themeKey || 'default';
            
            // Set basic class to identify the element
            connectionGroup.setAttribute("class", `connection-group theme-${themeKey}`);
            
            // Create the connection path
            const path = document.createElementNS(svgNamespace, "path");
            path.setAttribute("d", connection.element.getAttribute("d"));
            path.setAttribute("class", `connection-path pattern-${connection.data.pattern} thickness-${connection.data.thickness}`);
            
            // Set markers based on directionality, with mode-specific IDs
            const mode = isDarkMode ? 'dark' : 'light';
            if (connection.data.bidirectional) {
                path.setAttribute("marker-start", `url(#arrowhead-start-${themeKey}-${mode})`);
            }
            path.setAttribute("marker-end", `url(#arrowhead-end-${themeKey}-${mode})`);
            
            connectionGroup.appendChild(path);
            connectionsGroup.appendChild(connectionGroup);
        });
        
        svg.appendChild(connectionsGroup);
        
        // Create a group for boxes
        const boxesGroup = document.createElementNS(svgNamespace, "g");
        boxesGroup.setAttribute("class", "boxes");
        
        // Add all boxes
        boxes.forEach(box => {
            const bounds = box.getBounds();
            const themeKey = box.data.themeKey || 'default';
            const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
            
            // Create a group for this box
            const boxGroup = document.createElementNS(svgNamespace, "g");
            boxGroup.setAttribute("class", `box theme-${themeKey}`);
            boxGroup.setAttribute("transform", `translate(${bounds.left}, ${bounds.top})`);
            
            // Create the box rectangle
            const rect = document.createElementNS(svgNamespace, "rect");
            rect.setAttribute("width", bounds.width);
            rect.setAttribute("height", bounds.height);
            rect.setAttribute("rx", "8"); // Rounded corners
            rect.setAttribute("ry", "8");
            
            // Apply theme classes - for both light and dark modes
            // The SVG's .dark-mode class will determine which is active
            rect.classList.add('light-' + themeKey + '-bg', 'light-' + themeKey + '-border');
            rect.classList.add('dark-' + themeKey + '-bg', 'dark-' + themeKey + '-border');
            
            boxGroup.appendChild(rect);
            
            // Create a foreignObject for the markdown content
            const foreignObject = document.createElementNS(svgNamespace, "foreignObject");
            foreignObject.setAttribute("width", bounds.width);
            foreignObject.setAttribute("height", bounds.height);
            
            // Create a new div with the proper markdown-content class (like original code)
            const div = document.createElement("div");
            div.className = "markdown-content";
            div.classList.add('light-' + themeKey + '-text', 'dark-' + themeKey + '-text');
            
            // Apply the crucial styling
            div.style.width = "100%";
            div.style.height = "100%";
            div.style.boxSizing = "border-box";
            div.style.padding = "8px 12px"; // Important for spacing!
            div.style.overflow = "hidden";
            
            // Copy innerHTML from the original
            div.innerHTML = box.contentDiv.innerHTML;
            
            foreignObject.appendChild(div);
            boxGroup.appendChild(foreignObject);
            
            boxesGroup.appendChild(boxGroup);
        });
        
        svg.appendChild(boxesGroup);
        
        // Convert SVG to a string
        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svg);
        
        // Add XML declaration and doctype
        svgString = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' +
                    '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                    svgString;
        
        // Create a blob and download the SVG
        const blob = new Blob([svgString], {type: "image/svg+xml"});
        const url = URL.createObjectURL(blob);
        
        // Get project name for the filename
        const projectName = this.getProjectName();
        const filename = projectName ? `${projectName}.svg` : "flowchart.svg";
        
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = filename;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(url);
    }
    
    // Create arrow markers for both directions
    createArrowMarkers(defs, themeKey, mode) {
        const svgNamespace = "http://www.w3.org/2000/svg";
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get the CSS variable for this theme and mode
        const strokeVarName = theme[mode].stroke.replace('var(', '').replace(')', '');
        
        // Extract the actual color value from the CSS variable
        const strokeColor = getComputedStyle(document.documentElement)
            .getPropertyValue(strokeVarName)
            .trim();
        
        // End marker
        const arrowEndMarker = document.createElementNS(svgNamespace, "marker");
        arrowEndMarker.setAttribute("id", `arrowhead-end-${themeKey}-${mode}`);
        arrowEndMarker.setAttribute("markerWidth", "10");
        arrowEndMarker.setAttribute("markerHeight", "7");
        arrowEndMarker.setAttribute("refX", "9");
        arrowEndMarker.setAttribute("refY", "3.5");
        arrowEndMarker.setAttribute("orient", "auto");
        
        const arrowEndPolygon = document.createElementNS(svgNamespace, "polygon");
        arrowEndPolygon.setAttribute("points", "0 0, 10 3.5, 0 7");
        arrowEndPolygon.setAttribute("fill", strokeColor);
        arrowEndMarker.appendChild(arrowEndPolygon);
        defs.appendChild(arrowEndMarker);
        
        // Start marker
        const arrowStartMarker = document.createElementNS(svgNamespace, "marker");
        arrowStartMarker.setAttribute("id", `arrowhead-start-${themeKey}-${mode}`);
        arrowStartMarker.setAttribute("markerWidth", "10");
        arrowStartMarker.setAttribute("markerHeight", "7");
        arrowStartMarker.setAttribute("refX", "1");
        arrowStartMarker.setAttribute("refY", "3.5");
        arrowStartMarker.setAttribute("orient", "auto");
        
        const arrowStartPolygon = document.createElementNS(svgNamespace, "polygon");
        arrowStartPolygon.setAttribute("points", "10 0, 0 3.5, 10 7");
        arrowStartPolygon.setAttribute("fill", strokeColor);
        arrowStartMarker.appendChild(arrowStartPolygon);
        defs.appendChild(arrowStartMarker);
    }
    
    // Add the project title to the SVG
    addProjectTitle(svg, svgNamespace, x, y, width) {
        const titleGroup = document.createElementNS(svgNamespace, "g");
        titleGroup.setAttribute("class", "project-title");
        
        // Get current project title
        const projectTitle = document.getElementById('project-title').textContent;
        
        // Create text element
        const titleText = document.createElementNS(svgNamespace, "text");
        titleText.setAttribute("x", x + width / 2);
        titleText.setAttribute("y", y + 40); // Position from top
        titleText.setAttribute("text-anchor", "middle");
        titleText.setAttribute("font-size", "24px");
        titleText.setAttribute("font-family", "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif");
        titleText.setAttribute("font-weight", "300");
        titleText.setAttribute("letter-spacing", "0.05em");
        titleText.setAttribute("class", "title-text");
        titleText.textContent = projectTitle;
        
        titleGroup.appendChild(titleText);
        svg.appendChild(titleGroup);
    }
    
    // Get project name for the filename
    getProjectName() {
        // Try to get project name from the title element
        const projectTitle = document.getElementById('project-title').textContent;
        if (projectTitle && projectTitle !== 'New Project') {
            return projectTitle.replace(/[^\w\-\s]/g, '').replace(/\s+/g, '-').toLowerCase();
        }
        return null;
    }
    
    // Extract all CSS variables and theme classes from the document
    extractThemeStyles() {
        // Get the font scale
        const fontScale = getComputedStyle(document.documentElement)
            .getPropertyValue('--font-scale')
            .trim();
            
        // First, extract all the CSS variables
        let cssVars = '';
        const vars = [
            // Base colors - Light Mode
            '--gray-50', '--gray-100', '--gray-200', '--gray-300', '--gray-400', '--gray-500',
            '--gray-600', '--gray-700', '--gray-800', '--gray-900',
            '--red-50', '--red-100', '--red-200', '--red-300', '--red-400', '--red-500',
            '--red-600', '--red-700', '--red-800', '--red-900', '--red-950',
            '--green-50', '--green-100', '--green-200', '--green-300', '--green-400', '--green-500',
            '--green-600', '--green-700', '--green-800', '--green-900', '--green-950',
            '--blue-50', '--blue-100', '--blue-200', '--blue-300', '--blue-400', '--blue-500',
            '--blue-600', '--blue-700', '--blue-800', '--blue-900', '--blue-950',
            '--purple-50', '--purple-100', '--purple-200', '--purple-300', '--purple-400', '--purple-500',
            '--purple-600', '--purple-700', '--purple-800', '--purple-900', '--purple-950',
            '--yellow-50', '--yellow-100', '--yellow-200', '--yellow-300', '--yellow-400', '--yellow-500',
            '--yellow-600', '--yellow-700', '--yellow-800', '--yellow-900', '--yellow-950',
            '--amber-50', '--amber-100', '--amber-200', '--amber-300', '--amber-400', '--amber-500',
            '--amber-600', '--amber-700', '--amber-800', '--amber-900', '--amber-950',
            '--black', '--white',
            
            // Theme variables - Light mode
            '--bg-primary', '--bg-secondary', '--text-primary', '--text-secondary', '--text-muted',
            '--border-color', '--shadow-color',
            
            // Theme colors - Light mode
            '--theme-default-bg', '--theme-default-text', '--theme-default-border', '--theme-default-stroke',
            '--theme-red-bg', '--theme-red-text', '--theme-red-border', '--theme-red-stroke',
            '--theme-green-bg', '--theme-green-text', '--theme-green-border', '--theme-green-stroke',
            '--theme-blue-bg', '--theme-blue-text', '--theme-blue-border', '--theme-blue-stroke',
            '--theme-purple-bg', '--theme-purple-text', '--theme-purple-border', '--theme-purple-stroke',
            '--theme-yellow-bg', '--theme-yellow-text', '--theme-yellow-border', '--theme-yellow-stroke',
            '--theme-grey-bg', '--theme-grey-text', '--theme-grey-border', '--theme-grey-stroke'
        ];
        
        // Extract all variables
        vars.forEach(varName => {
            const value = getComputedStyle(document.documentElement)
                .getPropertyValue(varName)
                .trim();
            cssVars += `${varName}: ${value};\n`;
        });
        
        // Now create rules to define base styling
        return `
            /* SVG Root with CSS Variables */
            :root {
                ${cssVars}
            }
            
            /* SVG root should also have background in dark mode */
            svg.dark-mode {
                background-color: var(--bg-primary);
            }
            
            /* Dark Mode Variables */
            .dark-mode {
                --bg-primary: var(--gray-800);
                --bg-secondary: var(--gray-700);
                --text-primary: var(--gray-50);
                --text-secondary: var(--gray-300);
                --text-muted: var(--gray-400);
                --border-color: var(--gray-600);
                --shadow-color: rgba(0, 0, 0, 0.3);
                
                /* Theme Colors - Dark Mode */
                --theme-default-bg: var(--gray-700);
                --theme-default-text: var(--gray-50);
                --theme-default-border: var(--gray-400);
                --theme-default-stroke: var(--gray-400);
                
                --theme-red-bg: var(--red-900);
                --theme-red-text: var(--red-200);
                --theme-red-border: var(--red-500);
                --theme-red-stroke: var(--red-300);
                
                --theme-green-bg: var(--green-900);
                --theme-green-text: var(--green-200);
                --theme-green-border: var(--green-500);
                --theme-green-stroke: var(--green-400);
                
                --theme-blue-bg: var(--blue-900);
                --theme-blue-text: var(--blue-200);
                --theme-blue-border: var(--blue-500);
                --theme-blue-stroke: var(--blue-400);
                
                --theme-purple-bg: var(--purple-800);
                --theme-purple-text: var(--purple-200);
                --theme-purple-border: var(--purple-500);
                --theme-purple-stroke: var(--purple-400);
                
                --theme-yellow-bg: var(--yellow-900);
                --theme-yellow-text: var(--yellow-200);
                --theme-yellow-border: var(--amber-500);
                --theme-yellow-stroke: var(--amber-400);
                
                --theme-grey-bg: var(--gray-800);
                --theme-grey-text: var(--gray-200);
                --theme-grey-border: var(--gray-400);
                --theme-grey-stroke: var(--gray-400);
            }
            
            /* Markdown content styling */
            .markdown-content { 
                font-size: ${fontScale * 14}px; 
                line-height: 1.5; 
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            }
            .markdown-content h1 { 
                font-size: 1.5em; 
                font-weight: bold; 
                margin: 0.5em 0 0.3em; 
            }
            .markdown-content h2 { 
                font-size: 1.3em; 
                font-weight: bold; 
                margin: 0.4em 0 0.2em; 
            }
            .markdown-content h3 { 
                font-size: 1.1em; 
                font-weight: bold; 
                margin: 0.3em 0 0.1em; 
            }
            .markdown-content p { margin-bottom: 0.5em; }
            .markdown-content ul, .markdown-content ol { 
                padding-left: 1.5em; 
                margin-bottom: 0.5em; 
            }
            .markdown-content li { margin-bottom: 0.2em; }
            .markdown-content li > ul, .markdown-content li > ol { margin-top: 0.2em; }
            .markdown-content code { 
                background-color: rgba(0, 0, 0, 0.05); 
                padding: 0.1em 0.2em; 
                border-radius: 0.2em; 
                font-family: monospace; 
                font-size: 0.9em;
            }
            .markdown-content hr { margin: 0.5em 0; border: none; border-top: 1px solid var(--border-color); }
            .markdown-content a { color: var(--link-color); text-decoration: underline; }
            
            /* Table styling */
            .markdown-content table { 
                border-collapse: collapse; 
                width: 100%; 
                margin-bottom: 0.8em; 
                font-size: 0.9em; 
            }
            .markdown-content table td { 
                border: 1px solid var(--border-color); 
                padding: 0.4em 0.7em; 
            }
            .markdown-content table th { 
                border: 1px solid var(--border-color); 
                padding: 0.5em 0.7em; 
                text-align: left; 
                font-weight: bold; 
            }
            
            /* Connection path styling */
            .connection-path {
                fill: none;
                pointer-events: none;
            }
            
            /* Pattern styles */
            .pattern-normal { stroke-dasharray: none; }
            .pattern-dashed { stroke-dasharray: 10, 5; }
            .pattern-dotted { stroke-dasharray: 2, 4; }
            
            /* Thickness styles */
            .thickness-thin { stroke-width: 1; }
            .thickness-normal { stroke-width: 2; }
            .thickness-bold { stroke-width: 4; }
            
            /* Box styling */
            .box rect {
                stroke-width: 1.5;
            }
            
            /* Theme-specific classes - Light Mode */
            .light-default-bg { background-color: var(--theme-default-bg); fill: var(--theme-default-bg); }
            .light-default-text { color: var(--theme-default-text); }
            .light-default-border { border-color: var(--theme-default-border); stroke: var(--theme-default-border); }
            .theme-default .connection-path { stroke: var(--theme-default-stroke); }
            
            .light-red-bg { background-color: var(--theme-red-bg); fill: var(--theme-red-bg); }
            .light-red-text { color: var(--theme-red-text); }
            .light-red-border { border-color: var(--theme-red-border); stroke: var(--theme-red-border); }
            .theme-red .connection-path { stroke: var(--theme-red-stroke); }
            
            .light-green-bg { background-color: var(--theme-green-bg); fill: var(--theme-green-bg); }
            .light-green-text { color: var(--theme-green-text); }
            .light-green-border { border-color: var(--theme-green-border); stroke: var(--theme-green-border); }
            .theme-green .connection-path { stroke: var(--theme-green-stroke); }
            
            .light-blue-bg { background-color: var(--theme-blue-bg); fill: var(--theme-blue-bg); }
            .light-blue-text { color: var(--theme-blue-text); }
            .light-blue-border { border-color: var(--theme-blue-border); stroke: var(--theme-blue-border); }
            .theme-blue .connection-path { stroke: var(--theme-blue-stroke); }
            
            .light-purple-bg { background-color: var(--theme-purple-bg); fill: var(--theme-purple-bg); }
            .light-purple-text { color: var(--theme-purple-text); }
            .light-purple-border { border-color: var(--theme-purple-border); stroke: var(--theme-purple-border); }
            .theme-purple .connection-path { stroke: var(--theme-purple-stroke); }
            
            .light-yellow-bg { background-color: var(--theme-yellow-bg); fill: var(--theme-yellow-bg); }
            .light-yellow-text { color: var(--theme-yellow-text); }
            .light-yellow-border { border-color: var(--theme-yellow-border); stroke: var(--theme-yellow-border); }
            .theme-yellow .connection-path { stroke: var(--theme-yellow-stroke); }
            
            .light-grey-bg { background-color: var(--theme-grey-bg); fill: var(--theme-grey-bg); }
            .light-grey-text { color: var(--theme-grey-text); }
            .light-grey-border { border-color: var(--theme-grey-border); stroke: var(--theme-grey-border); }
            .theme-grey .connection-path { stroke: var(--theme-grey-stroke); }
            
            /* Theme-specific classes - Dark Mode (these will only apply when .dark-mode is present) */
            .dark-mode .dark-default-bg { background-color: var(--theme-default-bg); fill: var(--theme-default-bg); }
            .dark-mode .dark-default-text { color: var(--theme-default-text); }
            .dark-mode .dark-default-border { border-color: var(--theme-default-border); stroke: var(--theme-default-border); }
            .dark-mode .theme-default .connection-path { stroke: var(--theme-default-stroke); }
            
            .dark-mode .dark-red-bg { background-color: var(--theme-red-bg); fill: var(--theme-red-bg); }
            .dark-mode .dark-red-text { color: var(--theme-red-text); }
            .dark-mode .dark-red-border { border-color: var(--theme-red-border); stroke: var(--theme-red-border); }
            .dark-mode .theme-red .connection-path { stroke: var(--theme-red-stroke); }
            
            .dark-mode .dark-green-bg { background-color: var(--theme-green-bg); fill: var(--theme-green-bg); }
            .dark-mode .dark-green-text { color: var(--theme-green-text); }
            .dark-mode .dark-green-border { border-color: var(--theme-green-border); stroke: var(--theme-green-border); }
            .dark-mode .theme-green .connection-path { stroke: var(--theme-green-stroke); }
            
            .dark-mode .dark-blue-bg { background-color: var(--theme-blue-bg); fill: var(--theme-blue-bg); }
            .dark-mode .dark-blue-text { color: var(--theme-blue-text); }
            .dark-mode .dark-blue-border { border-color: var(--theme-blue-border); stroke: var(--theme-blue-border); }
            .dark-mode .theme-blue .connection-path { stroke: var(--theme-blue-stroke); }
            
            .dark-mode .dark-purple-bg { background-color: var(--theme-purple-bg); fill: var(--theme-purple-bg); }
            .dark-mode .dark-purple-text { color: var(--theme-purple-text); }
            .dark-mode .dark-purple-border { border-color: var(--theme-purple-border); stroke: var(--theme-purple-border); }
            .dark-mode .theme-purple .connection-path { stroke: var(--theme-purple-stroke); }
            
            .dark-mode .dark-yellow-bg { background-color: var(--theme-yellow-bg); fill: var(--theme-yellow-bg); }
            .dark-mode .dark-yellow-text { color: var(--theme-yellow-text); }
            .dark-mode .dark-yellow-border { border-color: var(--theme-yellow-border); stroke: var(--theme-yellow-border); }
            .dark-mode .theme-yellow .connection-path { stroke: var(--theme-yellow-stroke); }
            
            .dark-mode .dark-grey-bg { background-color: var(--theme-grey-bg); fill: var(--theme-grey-bg); }
            .dark-mode .dark-grey-text { color: var(--theme-grey-text); }
            .dark-mode .dark-grey-border { border-color: var(--theme-grey-border); stroke: var(--theme-grey-border); }
            .dark-mode .theme-grey .connection-path { stroke: var(--theme-grey-stroke); }
            
            /* Project title styling */
            .title-text {
                fill: var(--text-muted);
                color: var(--text-muted);
            }
        `;
    }
}

// --- Settings Manager ---
class SettingsManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager; // Store reference to diagram manager
        this.settings = {
            textScale: 1.0
        };
        this.loadSettings();
    }
    
    loadSettings() {
        try {
            const storedSettings = localStorage.getItem('markdownDiagramSettings');
            if (storedSettings) {
                this.settings = { ...this.settings, ...JSON.parse(storedSettings) };
            }
            this.applySettings();
        } catch (error) {
            console.error('Error loading settings:', error);
        }
    }
    
    saveSettings() {
        try {
            localStorage.setItem('markdownDiagramSettings', JSON.stringify(this.settings));
            // Update all boxes after saving settings
            if (this.diagramManager) {
                this.diagramManager.updateAllBoxSizes();
            }
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }
    
    applySettings() {
        // Apply text scale
        document.documentElement.style.setProperty('--font-scale', this.settings.textScale);
        
        // Update UI if elements exist
        const textScaleValue = document.getElementById('text-scale-value');
        
        if (textScaleValue) textScaleValue.textContent = `${this.settings.textScale.toFixed(2)}x`;
        
        // Update all box sizes when settings are applied (e.g. on page load)
        if (this.diagramManager) {
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                this.diagramManager.updateAllBoxSizes();
            }, 100);
        }
    }
}

// --- Project Management ---
class ProjectManager {
    constructor(diagramManager) {
        this.diagramManager = diagramManager;
        this.projects = [];
        this.currentProjectId = null;
        this.storageKey = 'markdownDiagramProjects';
        this.projectListEl = document.getElementById('project-list');
        this.noProjectsMessage = document.getElementById('no-projects-message');
        this.projectNameInput = document.getElementById('project-name');
        this.settingsMenu = document.getElementById('settings-menu');
        this.textScaleValue = document.getElementById('text-scale-value');
        this.newProjectForm = document.getElementById('new-project-form');
        this.addProjectToggle = document.getElementById('add-project-toggle');
        
        // Store which project is currently being edited/confirmed for deletion
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        this.showingNewProjectForm = false;
        
        // Initialize import and export managers
        this.importManager = new ImportManager(this);
        this.exportManager = new ExportManager(this);
        this.svgExportManager = new SVGExportManager(diagramManager);
        
        this.loadProjects();
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Settings button opens the menu
        document.getElementById('settings-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleSettingsMenu();
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!this.settingsMenu.contains(e.target) && 
                e.target.id !== 'settings-button' && 
                !e.target.closest('#settings-button')) {
                this.hideSettingsMenu();
            }
        });
        
        // Add project toggle
        this.addProjectToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleNewProjectForm();
        });
        
        // Commit new project
        document.getElementById('commit-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.createNewProject();
        });
        
        // Cancel new project
        document.getElementById('cancel-new-project').addEventListener('click', (e) => {
            e.stopPropagation();
            this.hideNewProjectForm();
        });
        
        // Create project on Enter
        this.projectNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.createNewProject();
            }
        });
        
        // Cancel on Escape key
        this.projectNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideNewProjectForm();
            }
        });
        
        // Text size decrease button
        document.getElementById('text-scale-decrease').addEventListener('click', (e) => {
            e.stopPropagation();
            this.changeTextScale(-0.05);
        });
        
        // Text size increase button
        document.getElementById('text-scale-increase').addEventListener('click', (e) => {
            e.stopPropagation();
            this.changeTextScale(0.05);
        });
        
        // Import button
        document.getElementById('import-projects-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.importManager.openModal();
        });
        
        // Export button
        document.getElementById('export-projects-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.exportManager.openModal();
        });
        
        // Export to SVG button
        document.getElementById('export-svg-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.svgExportManager.exportSVG();
        });
    }
    
    // Change text scale by the specified delta
    changeTextScale(delta) {
        const settings = JSON.parse(localStorage.getItem('markdownDiagramSettings') || '{"textScale":1.0}');
        let newScale = Math.round((settings.textScale + delta) * 100) / 100; // Round to 2 decimal places
        
        // Constrain to reasonable range (0.5 to 2.0)
        newScale = Math.max(0.5, Math.min(2.0, newScale));
        
        // Update settings
        settings.textScale = newScale;
        localStorage.setItem('markdownDiagramSettings', JSON.stringify(settings));
        
        // Update display
        this.textScaleValue.textContent = `${newScale.toFixed(2)}x`;
        
        // Apply the setting
        document.documentElement.style.setProperty('--font-scale', newScale);
        
        // Update box sizes
        clearTimeout(this._resizeTimeout);
        this._resizeTimeout = setTimeout(() => {
            this.diagramManager.updateAllBoxSizes();
        }, 50);
    }
    
    toggleNewProjectForm() {
        if (this.showingNewProjectForm) {
            this.hideNewProjectForm();
        } else {
            this.showNewProjectForm();
        }
    }
    
    showNewProjectForm() {
        this.showingNewProjectForm = true;
        this.newProjectForm.classList.remove('hidden');
        
        // Use setTimeout to ensure transition works
        setTimeout(() => {
            this.newProjectForm.style.maxHeight = '100px';
            // Focus the input field
            this.projectNameInput.focus();
        }, 10);
    }
    
    hideNewProjectForm() {
        this.showingNewProjectForm = false;
        this.newProjectForm.style.maxHeight = '0';
        this.projectNameInput.value = '';
        
        // Hide after transition
        setTimeout(() => {
            this.newProjectForm.classList.add('hidden');
        }, 200);
    }
    
    toggleSettingsMenu() {
        if (this.settingsMenu.classList.contains('hidden')) {
            this.showSettingsMenu();
        } else {
            this.hideSettingsMenu();
        }
    }
    
    showSettingsMenu() {
        this.settingsMenu.classList.remove('hidden');
        
        // Animate in
        setTimeout(() => {
            this.settingsMenu.classList.remove('opacity-0', 'translate-y-2', 'pointer-events-none');
            this.settingsMenu.classList.add('opacity-100', 'translate-y-0');
        }, 10);
        
        // Update project list when showing menu
        this.renderProjectList();
    }
    
    hideSettingsMenu() {
        // Reset all sub-states
        this.hideNewProjectForm();
        this.editingProjectId = null;
        this.confirmingDeleteId = null;
        
        // Animate out
        this.settingsMenu.classList.add('opacity-0', 'translate-y-2', 'pointer-events-none');
        this.settingsMenu.classList.remove('opacity-100', 'translate-y-0');
        
        // Hide after animation
        setTimeout(() => {
            this.settingsMenu.classList.add('hidden');
        }, 200);
    }
    
    loadProjects() {
        try {
            const storedProjects = localStorage.getItem(this.storageKey);
            if (storedProjects) {
                this.projects = JSON.parse(storedProjects);
                this.renderProjectList();
                
                // Load last active project if exists
                const lastActiveId = localStorage.getItem('lastActiveProject');
                if (lastActiveId && this.projects.find(p => p.id === lastActiveId)) {
                    this.loadProject(lastActiveId);
                } else if (this.projects.length > 0) {
                    // Load first project if no last active
                    this.loadProject(this.projects[0].id);
                }
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            this.projects = [];
        }
        
        this.updateProjectsVisibility();
        this.updateProjectTitle();
    }
    
    saveProjects() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.projects));
            if (this.currentProjectId) {
                localStorage.setItem('lastActiveProject', this.currentProjectId);
            }
        } catch (error) {
            console.error('Error saving projects:', error);
        }
    }
    
    updateProjectTitle() {
        const projectTitleEl = document.getElementById('project-title');
        const currentProject = this.getCurrentProject();
        
        if (currentProject) {
            // Update the H1 element
            projectTitleEl.textContent = currentProject.name;
            
            // Update the page title
            document.title = `${currentProject.name} - Flow Chart`;
        } else {
            projectTitleEl.textContent = 'New Project';
            document.title = 'Flow Chart';
        }
    }
    
    createNewProject() {
        const name = this.projectNameInput.value.trim();
        if (!name) return;
        
        const newProject = {
            id: 'project_' + Date.now(),
            name: name,
            dateCreated: new Date().toISOString(),
            dateModified: new Date().toISOString(),
            data: {
                boxes: [],
                connections: [],
                nextBoxId: 1,
                nextConnectionId: 1
            }
        };
        
        this.projects.push(newProject);
        this.saveProjects();
        this.hideNewProjectForm();
        this.renderProjectList();
        this.loadProject(newProject.id);
        this.updateProjectsVisibility();
    }
    
    renderProjectList() {
        // Clear existing projects except the "no projects" message
        const children = Array.from(this.projectListEl.children);
        children.forEach(child => {
            if (child !== this.noProjectsMessage) {
                child.remove();
            }
        });
        
        // Add project items
        this.projects.forEach(project => {
            const projectItem = document.createElement('div');
            // Add 'project-item' class and active if current project
            projectItem.className = 'project-item mb-2 rounded overflow-hidden';
            if (project.id === this.currentProjectId) {
                projectItem.classList.add('active');
            }
            projectItem.dataset.id = project.id;
            
            // Main project container
            const projectContainer = document.createElement('div');
            projectContainer.className = 'project-container p-2 flex justify-between items-center cursor-pointer group';
            
            // Check if this project is being edited
            if (this.editingProjectId === project.id) {
                // Render edit form
                projectContainer.innerHTML = `
                    <div class="flex w-full items-center">
                        <input type="text" class="flex-1 px-2 py-1 mr-2 border rounded" value="${project.name}" id="edit-${project.id}" style="border-color: var(--border-color); background-color: var(--bg-primary); color: var(--text-primary);">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" data-id="${project.id}" title="Save">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600 ml-1" data-id="${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                // Setup event listeners for the edit form
                const input = projectContainer.querySelector('input');
                const commitBtn = projectContainer.querySelector('button[title="Save"]');
                const cancelBtn = projectContainer.querySelector('button[title="Cancel"]');
                
                // Focus the input
                setTimeout(() => input.focus(), 0);
                
                // Commit on button click
                commitBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.commitProjectEdit(project.id, input.value);
                });
                
                // Cancel edit
                cancelBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.editingProjectId = null;
                    this.renderProjectList();
                });
                
                // Commit on Enter key
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.commitProjectEdit(project.id, input.value);
                    }
                });
                
                // Cancel on Escape key
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.editingProjectId = null;
                        this.renderProjectList();
                    }
                });
            }
            // Normal project display
            else {
                const dateModified = new Date(project.dateModified);
                const formattedDate = dateModified.toLocaleDateString();
                
                projectContainer.innerHTML = `
                    <div>
                        <div class="truncate">${project.name}</div>
                        <div class="text-xs opacity-60">Modified: ${formattedDate}</div>
                    </div>
                    <div class="flex gap-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Edit">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors" data-id="${project.id}" title="Delete">
                            <i class="fas fa-trash-alt text-red-500"></i>
                        </button>
                    </div>
                `;
            }
            
            projectItem.appendChild(projectContainer);
            
            // Check if this project has a delete confirmation showing
            if (this.confirmingDeleteId === project.id) {
                // Create delete confirmation that slides down
                const confirmDelete = document.createElement('div');
                confirmDelete.className = 'p-2 flex items-center justify-between transition-all duration-200 overflow-hidden';
                confirmDelete.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
                confirmDelete.innerHTML = `
                    <span class="text-sm">Confirm delete</span>
                    <div class="flex gap-2">
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-green-600" id="confirm-delete-${project.id}" title="Confirm">
                            <i class="fas fa-check"></i>
                        </button>
                        <button class="p-1 rounded hover:bg-black hover:bg-opacity-10 transition-colors text-red-600" id="cancel-delete-${project.id}" title="Cancel">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                projectItem.appendChild(confirmDelete);
                
                // Add event listeners for confirmation buttons
                confirmDelete.querySelector(`#confirm-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteProject(project.id);
                });
                
                confirmDelete.querySelector(`#cancel-delete-${project.id}`).addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.confirmingDeleteId = null;
                    this.renderProjectList();
                });
            }
            
            // Add click event to load project (only if not in edit mode)
            if (this.editingProjectId !== project.id) {
                projectContainer.addEventListener('click', (e) => {
                    // Don't load if clicking buttons
                    if (!e.target.closest('button')) {
                        this.loadProject(project.id);
                        this.hideSettingsMenu();
                    }
                });
                
                // Add event listeners for edit and delete buttons
                const editBtn = projectContainer.querySelector('button[title="Edit"]');
                if (editBtn) {
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.startProjectEdit(project.id);
                    });
                }
                
                const deleteBtn = projectContainer.querySelector('button[title="Delete"]');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.confirmDeleteProject(project.id);
                    });
                }
            }
            
            this.projectListEl.appendChild(projectItem);
        });
        
        this.updateProjectsVisibility();
    }
    
    // Start editing a project name
    startProjectEdit(projectId) {
        this.editingProjectId = projectId;
        this.renderProjectList();
    }
    
    // Commit project name edit
    commitProjectEdit(projectId, newName) {
        newName = newName.trim();
        if (!newName) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === projectId);
        if (projectIndex >= 0) {
            this.projects[projectIndex].name = newName;
            this.saveProjects();
            
            // Update title if editing current project
            if (projectId === this.currentProjectId) {
                this.updateProjectTitle();
            }
        }
        
        this.editingProjectId = null;
        this.renderProjectList();
    }
    
    // Show delete confirmation
    confirmDeleteProject(projectId) {
        this.confirmingDeleteId = projectId;
        this.renderProjectList();
    }
    
    updateProjectsVisibility() {
        if (this.projects.length === 0) {
            this.noProjectsMessage.style.display = 'block';
        } else {
            this.noProjectsMessage.style.display = 'none';
        }
    }
    
    deleteProject(projectId) {
        this.projects = this.projects.filter(project => project.id !== projectId);
        this.saveProjects();
        
        // If deleted current project, load another one
        if (projectId === this.currentProjectId) {
            if (this.projects.length > 0) {
                this.loadProject(this.projects[0].id);
            } else {
                // No projects left, clear diagram
                this.diagramManager.clearDiagram();
                this.currentProjectId = null;
                this.updateProjectTitle();
            }
        }
        
        this.confirmingDeleteId = null;
        this.renderProjectList();
        this.updateProjectsVisibility();
    }
    
    loadProject(projectId) {
        const project = this.projects.find(p => p.id === projectId);
        if (!project) return;
        
        // Save current project if exists
        this.saveCurrentProject();
        
        // Load new project
        this.currentProjectId = projectId;
        this.diagramManager.loadFromProjectData(project.data);
        
        // Update project title
        this.updateProjectTitle();
        
        localStorage.setItem('lastActiveProject', projectId);
    }
    
    saveCurrentProject() {
        if (!this.currentProjectId) return;
        
        const projectIndex = this.projects.findIndex(p => p.id === this.currentProjectId);
        if (projectIndex >= 0) {
            const diagramData = this.diagramManager.exportData();
            this.projects[projectIndex].data = diagramData;
            this.projects[projectIndex].dateModified = new Date().toISOString();
            this.saveProjects();
        }
    }
    
    getCurrentProject() {
        return this.projects.find(p => p.id === this.currentProjectId);
    }
}

// --- Box Class ---
class Box {
    constructor(boxData, manager) {
        this.data = boxData;
        if (!this.data.widthType) { this.data.widthType = WIDTH_TYPES.MEDIUM; }
        if (!this.data.markdown) { this.data.markdown = '# New Box\nUse **markdown** to format'; }
        if (!this.data.themeKey) { this.data.themeKey = 'default'; }
        this.manager = manager;
        this.isEditing = false;
        this.element = this.createElement();
        this.contentDiv = this.element.firstChild;
        this.textarea = null;
        this.updateElementPosition();
        this.applyColorTheme();
        this.renderMarkdown();
        this.setupEventListeners();
    }

    createElement() { 
        const div = document.createElement('div'); 
        div.className = BASE_BOX_CLASSES; 
        div.dataset.id = this.data.id; 
        div.dataset.type = 'box';
        div.dataset.theme = this.data.themeKey;
        const contentDiv = document.createElement('div'); 
        contentDiv.className = 'markdown-content relative w-full h-full'; 
        div.appendChild(contentDiv); 
        return div; 
    }
    
    setupEventListeners() {
        let isDragging = false;
        
        this.element.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.element.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.element.addEventListener('mousedown', (e) => { 
            isDragging = false; 
            // Start dragging on mousedown
            if (e.button === 0 && !this.isEditing) {
                this.manager.startDragging(this, e);
            } else if (e.button === 2) {
                // Right mouse button down - start connection or change width
                this.manager.handleBoxRightMouseDown(e, this);
            }
        });
        
        this.element.addEventListener('mousemove', () => { 
            if (this.manager.draggingBox === this) { 
                isDragging = true; 
            } 
        });
        
        this.element.addEventListener('dblclick', (e) => { 
            e.stopPropagation(); 
            if (!this.isEditing) { 
                this.startEditing(); 
            } 
        });
        
        this.element.addEventListener('contextmenu', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            return false; 
        });
    }

    // Updates the element's CSS position
    updateElementPosition() {
        const x = this.data.cx - this.data.width / 2;
        const y = this.data.cy - this.data.height / 2;
        this.element.style.left = `${Math.round(x)}px`;
        this.element.style.top = `${Math.round(y)}px`;
        this.element.style.width = `${this.data.width}px`;
        this.element.style.height = `${this.data.height}px`;
    }

    // Updates position using center coordinates - for dragging
    setCenterPosition(cx, cy) { this.data.cx = cx; this.data.cy = cy; this.updateElementPosition(); }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Apply color theme to the box
    applyColorTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get the mode-specific theme
        const modeTheme = theme[mode];
        
        // Remove all theme classes
        THEME_KEYS.forEach(key => {
            const lightTheme = COLOR_THEMES[key].light;
            const darkTheme = COLOR_THEMES[key].dark;
            
            // Remove both light and dark variants
            safeRemoveClass(this.element, lightTheme.bg);
            safeRemoveClass(this.element, lightTheme.border);
            safeRemoveClass(this.contentDiv, lightTheme.text);
            
            safeRemoveClass(this.element, darkTheme.bg);
            safeRemoveClass(this.element, darkTheme.border);
            safeRemoveClass(this.contentDiv, darkTheme.text);
        });
        
        // Add current theme classes for the current mode
        if (modeTheme.bg) this.element.classList.add(modeTheme.bg);
        if (modeTheme.border) this.element.classList.add(modeTheme.border);
        if (modeTheme.text) this.contentDiv.classList.add(modeTheme.text);
        
        // Update data attribute for theme identification
        this.element.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyColorTheme();
    }

    // Toggle between width types
    toggleWidthType() {
        const types = Object.values(WIDTH_TYPES);
        const currentIndex = types.indexOf(this.data.widthType);
        const nextIndex = (currentIndex + 1) % types.length;
        this.data.widthType = types[nextIndex];
        
        // Set the new width directly
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        this.data.width = width;
        
        // Update size based on current mode
        if (this.isEditing) {
            this.updateEditModeSize();
        } else {
            this.renderMarkdown();
        }
        
        this.manager.updateConnectionsForBox(this);
    }

    // Renders markdown content to HTML and calculates size
    renderMarkdown() {
        if (!this.data.markdown) return;
        
        try {
            // Use marked.js or fallback
            this.contentDiv.innerHTML = typeof marked !== 'undefined' && typeof marked.parse === 'function' 
                ? marked.parse(this.data.markdown) 
                : simpleMarkdownParser(this.data.markdown);
        } catch (e) {
            console.error('Error parsing markdown:', e);
            this.contentDiv.innerHTML = simpleMarkdownParser(this.data.markdown);
        }
        
        // Update size after rendering
        this.calculateRenderedSize();
    }

    // Calculate size with fixed width based on type
    calculateRenderedSize() {
        // Clone for measurement
        const clone = this.element.cloneNode(true);
        document.body.appendChild(clone);
        
        // Reset styles for measurement
        clone.style.position = 'absolute';
        clone.style.visibility = 'hidden';
        clone.style.left = '-9999px';
        clone.style.top = '-9999px';
        clone.style.height = 'auto';
        clone.style.maxWidth = 'none';
        clone.style.transition = 'none';
        
        // Use fixed width from width type directly
        const fixedWidth = WIDTH_TYPE_VALUES[this.data.widthType];
        clone.style.width = `${fixedWidth}px`;
        
        // Force reflow and measure height with the fixed width
        clone.offsetHeight;
        const newHeight = Math.max(clone.offsetHeight, 50);
        
        // Clean up
        document.body.removeChild(clone);
        
        // Update size
        this.data.width = fixedWidth;
        this.data.height = newHeight;
        this.updateElementPosition();
        
        return { width: fixedWidth, height: newHeight };
    }

    // Calculate box height based on line count
    calculateHeightFromLineCount() {
        if (!this.isEditing || !this.textarea) return 50;
        
        const lineCount = this.textarea.value.split('\n').length;
        return PADDING_HEIGHT + (lineCount * LINE_HEIGHT);
    }

    // Updates box size based on text content during editing
    updateEditModeSize() {
        if (!this.isEditing || !this.textarea) return;
        
        // Always use fixed width from width type
        const width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Calculate height based on line count
        const height = this.calculateHeightFromLineCount();
        
        // Update size
        this.data.width = width;
        this.data.height = height;
        this.updateElementPosition();
        this.manager.updateConnectionsForBox(this);
    }

    // Switches to editing mode
    startEditing() {
        if (this.isEditing) return;
        this.isEditing = true;
        this.element.classList.remove('cursor-move');
        
        // Clear and prepare container
        this.contentDiv.innerHTML = '';
        
        // Create textarea
        this.textarea = document.createElement('textarea');
        this.textarea.className = 'edit-textarea';
        this.textarea.value = this.data.markdown || '';
        this.textarea.placeholder = 'Add markdown content...';
        
        // Set fixed width from width type
        this.data.width = WIDTH_TYPE_VALUES[this.data.widthType];
        
        // Add event listeners
        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') { 
                e.preventDefault(); 
                this.cancelEdit(); 
            } else if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.commitEdit();
            }
            
            // Update size on next tick
            setTimeout(() => this.updateEditModeSize(), 0);
        });
        
        this.textarea.addEventListener('input', () => {
            this.updateEditModeSize();
        });
        
        // Prevent event propagation
        this.textarea.addEventListener('mousedown', e => e.stopPropagation());
        this.textarea.addEventListener('contextmenu', e => e.stopPropagation());
        this.textarea.addEventListener('dblclick', e => e.stopPropagation());
        this.textarea.addEventListener('click', e => e.stopPropagation());

        // Append the textarea to the DOM
        this.contentDiv.appendChild(this.textarea);

        // Focus and select text safely with a check
        requestAnimationFrame(() => {
            // Guard clause to prevent the error
            if (this.textarea && this.contentDiv.contains(this.textarea)) {
                this.textarea.focus();
                if (this.textarea.value) this.textarea.select();
            }
            this.updateEditModeSize();
        });
    }

    commitEdit() { 
        if (!this.isEditing || !this.textarea) return false; 
        const markdown = this.textarea.value.trim(); 
        if (!markdown) { 
            this.cancelEdit(); 
            return false; 
        } 
        this.data.markdown = markdown; 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
        this.manager.updateConnectionsForBox(this); 
        this.manager.saveCurrentProject();
        this.manager.updateCanvasSize(); // Update canvas size after edit
        return true; 
    }
    
    cancelEdit() { 
        if (!this.isEditing) return; 
        if (!this.data.markdown) { 
            this.manager.deleteBox(this); 
            return; 
        } 
        this.cleanupEdit(); 
        this.renderMarkdown(); 
    }
    
    cleanupEdit() { 
        this.isEditing = false; 
        if (this.textarea && this.textarea.parentNode) { 
            this.textarea.remove(); 
        } 
        this.textarea = null; 
        this.element.classList.add('cursor-move'); 
    }
    
    getBounds() { 
        const x = this.data.cx - this.data.width / 2; 
        const y = this.data.cy - this.data.height / 2; 
        return { 
            left: x, 
            right: x + this.data.width, 
            top: y, 
            bottom: y + this.data.height, 
            width: this.data.width, 
            height: this.data.height 
        }; 
    }
    
    // Export box data
    exportData() {
        return {
            id: this.data.id,
            cx: this.data.cx,
            cy: this.data.cy,
            width: this.data.width,
            height: this.data.height,
            widthType: this.data.widthType,
            themeKey: this.data.themeKey,
            markdown: this.data.markdown
        };
    }
}

// --- Connection Class ---
class Connection {
    constructor(connectionData, startBox, endBox, manager) { 
        this.data = connectionData; 
        // Initialize data if needed
        if (!this.data.themeKey) this.data.themeKey = 'default';
        if (!this.data.pattern) this.data.pattern = CONNECTION_PATTERNS.NORMAL;
        if (!this.data.thickness) this.data.thickness = CONNECTION_THICKNESSES.NORMAL;
        if (this.data.bidirectional === undefined) this.data.bidirectional = false;
        
        this.startBox = startBox; 
        this.endBox = endBox; 
        this.manager = manager; 
        
        // Create connection group and all elements
        this.createElements();
        
        this.update(); 
        this.setupEventListeners(); 
    }
    
    createElements() {
        // Create a group for the connection
        this.group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.group.setAttribute('class', 'connection-group');
        this.group.dataset.id = this.data.id;
        this.group.dataset.type = 'connection-group';
        
        // Create the hitbox path with wide stroke for easier clicking
        this.hitboxElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        this.hitboxElement.setAttribute('class', 'connection-hitbox');
        this.hitboxElement.dataset.id = this.data.id;
        this.hitboxElement.dataset.type = 'connection-hitbox';
        
        // Create the visible connection path
        this.element = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
        this.element.setAttribute('class', 'connection-path pointer-events-none'); 
        this.element.dataset.id = this.data.id; 
        this.element.dataset.type = 'connection';
        this.element.dataset.theme = this.data.themeKey;
        
        // Set markers based on if bidirectional
        if (this.data.bidirectional) {
            this.element.setAttribute('marker-start', 'url(#arrowhead-start)');
        }
        this.element.setAttribute('marker-end', 'url(#arrowhead-end)');
        
        // Create start hotspot inside the group
        this.startHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.startHotspot.setAttribute('class', 'arrow-hotspot');
        this.startHotspot.setAttribute('r', '12');
        this.startHotspot.dataset.connection = this.data.id;
        this.startHotspot.dataset.end = 'start';
        
        // Create end hotspot inside the group
        this.endHotspot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this.endHotspot.setAttribute('class', 'arrow-hotspot');
        this.endHotspot.setAttribute('r', '12');
        this.endHotspot.dataset.connection = this.data.id;
        this.endHotspot.dataset.end = 'end';
        
        // Add all elements to the group in the correct order (hitbox first, then line, then interaction points)
        this.group.appendChild(this.hitboxElement);
        this.group.appendChild(this.element);
        this.group.appendChild(this.startHotspot);
        this.group.appendChild(this.endHotspot);
        
        // Set up event listeners for the hotspots
        this.setupHotspotEventListeners();
    }
    
    // Get current mode (light or dark)
    getMode() {
        return document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    }
    
    // Set up event listeners for the hotspots
    setupHotspotEventListeners() {
        this.startHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.startHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.startHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
        
        this.endHotspot.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.endHotspot.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        this.endHotspot.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleBidirectional();
            this.manager.saveCurrentProject();
        });
    }
    
    // Toggle bidirectionality of the connection
    toggleBidirectional() {
        this.data.bidirectional = !this.data.bidirectional;
        
        // Apply the updated bidirectional state
        this.update();
        
        // Call applyTheme to ensure the correct marker is used
        this.applyTheme();
    }
    
    setupEventListeners() { 
        // Add interaction events to the hitbox element
        this.hitboxElement.addEventListener('mouseenter', () => {
            this.manager.hoveredElement = this;
        });
        
        this.hitboxElement.addEventListener('mouseleave', () => {
            if (this.manager.hoveredElement === this) {
                this.manager.hoveredElement = null;
            }
        });
        
        // Add left-click event to toggle line pattern
        this.hitboxElement.addEventListener('click', (e) => {
            e.stopPropagation();
            this.cyclePattern();
            this.manager.saveCurrentProject();
        });
        
        // Add right-click event to toggle thickness
        this.hitboxElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.cycleThickness();
            this.manager.saveCurrentProject();
        });
    }
    
    // Apply the current theme to the connection
    applyTheme() {
        const mode = this.getMode();
        const themeKey = this.data.themeKey || 'default';
        const theme = COLOR_THEMES[themeKey] || COLOR_THEMES.default;
        
        // Get stroke color for current mode
        const strokeColor = theme[mode].stroke;
        
        if (this.element) {
            // Set stroke color
            this.element.setAttribute('stroke', strokeColor);
            
            // Use theme-specific markers based on theme and current mode
            const startMarkerId = `arrowhead-start-${themeKey}-${mode}`;
            const endMarkerId = `arrowhead-end-${themeKey}-${mode}`;
            
            // Use theme-specific markers
            if (this.data.bidirectional) {
                this.element.setAttribute('marker-start', `url(#${startMarkerId})`);
            } else {
                this.element.removeAttribute('marker-start');
            }
            this.element.setAttribute('marker-end', `url(#${endMarkerId})`);
            
            // Also set hover fill color for hotspots to match the theme
            this.startHotspot.style.setProperty('--transparent-black-5', strokeColor + '33');
            this.endHotspot.style.setProperty('--transparent-black-5', strokeColor + '33');
        }
        
        // Update data attributes for theme identification
        this.element.dataset.theme = themeKey;
        this.group.dataset.theme = themeKey;
    }
    
    // Cycle to the next color theme
    cycleColorTheme() {
        const currentIndex = THEME_KEYS.indexOf(this.data.themeKey);
        const nextIndex = (currentIndex + 1) % THEME_KEYS.length;
        this.data.themeKey = THEME_KEYS[nextIndex];
        this.applyTheme();
        this.manager.saveCurrentProject();
    }
    
    // Apply current pattern to the connection
    applyPattern() {
        // Remove all pattern classes first
        this.element.classList.remove(
            'connection-pattern-normal',
            'connection-pattern-dashed', 
            'connection-pattern-dotted'
        );
        
        // Add current pattern class
        this.element.classList.add(`connection-pattern-${this.data.pattern}`);
    }
    
    // Apply current thickness to the connection
    applyThickness() {
        // Remove all thickness classes first
        this.element.classList.remove(
            'connection-thickness-thin',
            'connection-thickness-normal',
            'connection-thickness-bold'
        );
        
        // Add current thickness class
        this.element.classList.add(`connection-thickness-${this.data.thickness}`);
    }
    
    // Cycle to the next line pattern (left click)
    cyclePattern() {
        const patterns = Object.values(CONNECTION_PATTERNS);
        const currentIndex = patterns.indexOf(this.data.pattern);
        const nextIndex = (currentIndex + 1) % patterns.length;
        this.data.pattern = patterns[nextIndex];
        this.applyPattern();
    }
    
    // Cycle to the next thickness (right click)
    cycleThickness() {
        const thicknesses = Object.values(CONNECTION_THICKNESSES);
        const currentIndex = thicknesses.indexOf(this.data.thickness);
        const nextIndex = (currentIndex + 1) % thicknesses.length;
        this.data.thickness = thicknesses[nextIndex];
        this.applyThickness();
    }
    
    calculateIntersection(startPt, endPt, targetBox) { 
        const bounds = targetBox.getBounds(); 
        const dx = endPt.x - startPt.x; 
        const dy = endPt.y - startPt.y; 
        if (bounds.width <= 0 || bounds.height <= 0 || (dx === 0 && dy === 0)) { 
            return { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; 
        } 
        let t = Infinity; 
        let intersection = null; 
        const tol = 0.1; 
        const checkT = (newT, x, y, b) => { 
            if (newT >= 0 && newT < t && x >= b.left - tol && x <= b.right + tol && y >= b.top - tol && y <= b.bottom + tol) { 
                t = newT; 
                return { x, y }; 
            } 
            return null; 
        }; 
        if (dx !== 0) { 
            let tL = (bounds.left - startPt.x) / dx; 
            let yL = startPt.y + tL * dy; 
            intersection = checkT(tL, bounds.left, yL, bounds) || intersection; 
            let tR = (bounds.right - startPt.x) / dx; 
            let yR = startPt.y + tR * dy; 
            intersection = checkT(tR, bounds.right, yR, bounds) || intersection; 
        } 
        if (dy !== 0) { 
            let tT = (bounds.top - startPt.y) / dy; 
            let xT = startPt.x + tT * dx; 
            intersection = checkT(tT, xT, bounds.top, bounds) || intersection; 
            let tB = (bounds.bottom - startPt.y) / dy; 
            let xB = startPt.x + tB * dx; 
            intersection = checkT(tB, xB, bounds.bottom, bounds) || intersection; 
        } 
        if (intersection) { 
            const len = Math.sqrt(dx*dx + dy*dy) || 1; 
            const ux = dx / len; 
            const uy = dy / len; 
            intersection.x -= ux * 2; 
            intersection.y -= uy * 2; 
        } 
        return intersection || { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }; 
    }
    
    update() { 
        if (!this.startBox || !this.endBox) return; 
        const sC = { x: this.startBox.data.cx, y: this.startBox.data.cy }; 
        const eC = { x: this.endBox.data.cx, y: this.endBox.data.cy }; 
        const eP = this.calculateIntersection(sC, eC, this.endBox); 
        const sP = this.calculateIntersection(eP, sC, this.startBox); 
        
        if (!isNaN(sP.x) && !isNaN(eP.x)) { 
            const pathData = `M ${sP.x} ${sP.y} L ${eP.x} ${eP.y}`;
            
            // Update both the visible path and hitbox path
            this.element.setAttribute('d', pathData); 
            this.hitboxElement.setAttribute('d', pathData);
            
            // Update hotspot positions
            this.updateHotspotPositions(sP, eP);
        } else { 
            this.element.setAttribute('d', ''); 
            this.hitboxElement.setAttribute('d', '');
        } 
        
        this.updateElementStyle(); 
    }
    
    // Update hotspot positions
    updateHotspotPositions(startPoint, endPoint) {
        // Calculate vector
        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len === 0) return;
        
        const ux = dx / len;
        const uy = dy / len;
        
        // Position hotspots
        if (this.startHotspot) {
            const startHotspotX = startPoint.x + ux * 12;
            const startHotspotY = startPoint.y + uy * 12;
            this.startHotspot.setAttribute('cx', startHotspotX);
            this.startHotspot.setAttribute('cy', startHotspotY);
        }
        
        if (this.endHotspot) {
            const endHotspotX = endPoint.x - ux * 12;
            const endHotspotY = endPoint.y - uy * 12;
            this.endHotspot.setAttribute('cx', endHotspotX);
            this.endHotspot.setAttribute('cy', endHotspotY);
        }
    }
    
    updateElementStyle() { 
        // Apply theme, pattern and thickness
        this.applyTheme();
        this.applyPattern();
        this.applyThickness();
    }
    
    // Clean up the connection by removing the whole group
    cleanup() {
        if (this.group) {
            this.group.remove();
            this.group = null;
            this.element = null;
            this.hitboxElement = null;
            this.startHotspot = null;
            this.endHotspot = null;
        }
    }
    
    // Export connection data
    exportData() {
        return {
            id: this.data.id,
            startBoxId: this.startBox.data.id,
            endBoxId: this.endBox.data.id,
            themeKey: this.data.themeKey,
            pattern: this.data.pattern,
            thickness: this.data.thickness,
            bidirectional: this.data.bidirectional
        };
    }
}

// --- Diagram Manager Class ---
class DiagramManager {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.svg = document.getElementById('connections');
        this.boxContainer = document.getElementById('box-container');
        this.helperText = document.getElementById('helper-text');
        this.previewPath = document.getElementById('preview-connection');
        
        this.boxes = new Map();
        this.connections = new Map();
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        this.draggingBox = null;
        this.dragStartPos = { x: 0, y: 0 };
        this.dragBoxStartCenter = { cx: 0, cy: 0 };
        this.connectionStartBox = null;
        this.hoveredElement = null; // Track currently hovered element
        
        // Setup arrow markers with correct color inheritance
        this.setupArrowMarkers();
        
        // Initialize theme
        this.initTheme();
        
        // Initialize settings manager with reference to this diagram manager
        this.settingsManager = new SettingsManager(this);
        
        // Initialize UI
        this.setupEventListeners();
        this.updateHelperText();
        this.setupThemeToggle();
        
        // Initialize project manager
        this.projectManager = new ProjectManager(this);
        
        // Set initial canvas size
        this.updateCanvasSize();
        
        // Add window resize listener
        window.addEventListener('resize', () => {
            this.updateCanvasSize();
        });
    }

    // Setup arrow markers with proper color inheritance
    setupArrowMarkers() {
        // Get the defs section
        const defs = this.svg.querySelector('defs');
        if (!defs) return;
        
        // Clear existing markers
        defs.innerHTML = '';
        
        // Create markers for each theme
        Object.keys(COLOR_THEMES).forEach(themeKey => {
            const theme = COLOR_THEMES[themeKey];
            
            // Create markers for both light and dark modes
            ['light', 'dark'].forEach(mode => {
                const strokeColor = theme[mode].stroke;
                
                // Create end marker
                const markerEndId = `arrowhead-end-${themeKey}-${mode}`;
                const markerEnd = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerEnd.id = markerEndId;
                markerEnd.setAttribute('markerWidth', '10');
                markerEnd.setAttribute('markerHeight', '7');
                markerEnd.setAttribute('refX', '9');
                markerEnd.setAttribute('refY', '3.5');
                markerEnd.setAttribute('orient', 'auto');
                
                const polygonEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonEnd.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygonEnd.setAttribute('fill', strokeColor);
                
                markerEnd.appendChild(polygonEnd);
                defs.appendChild(markerEnd);
                
                // Create start marker (for bidirectional)
                const markerStartId = `arrowhead-start-${themeKey}-${mode}`;
                const markerStart = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                markerStart.id = markerStartId;
                markerStart.setAttribute('markerWidth', '10');
                markerStart.setAttribute('markerHeight', '7');
                markerStart.setAttribute('refX', '1');
                markerStart.setAttribute('refY', '3.5');
                markerStart.setAttribute('orient', 'auto');
                
                const polygonStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygonStart.setAttribute('points', '10 0, 0 3.5, 10 7');
                polygonStart.setAttribute('fill', strokeColor);
                
                markerStart.appendChild(polygonStart);
                defs.appendChild(markerStart);
            });
        });
    }
    
    // Update canvas size based on box positions with buffer zone
    updateCanvasSize() {
        // Find the maximum bounds in all directions
        let maxRight = 0;
        let maxBottom = 0;
        
        this.boxes.forEach(box => {
            const bounds = box.getBounds();
            maxRight = Math.max(maxRight, bounds.right);
            maxBottom = Math.max(maxBottom, bounds.bottom);
        });
        
        // Add buffer only for height (half viewport height)
        const bufferHeight = window.innerHeight / 2;
        
        // Get visible viewport dimensions (accounts for scrollbar presence)
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight;
        
        // For width: use exactly the content width or viewport width, whichever is larger
        // For height: add buffer for more natural vertical scrolling
        const newWidth = Math.max(maxRight, viewportWidth);
        const newHeight = Math.max(maxBottom + bufferHeight, viewportHeight);
        
        // Apply the new dimensions to relevant elements
        this.canvas.style.width = `${newWidth}px`;
        this.canvas.style.height = `${newHeight}px`;
        
        this.svg.style.width = `${newWidth}px`;
        this.svg.style.height = `${newHeight}px`;
        
        this.boxContainer.style.width = `${newWidth}px`;
        this.boxContainer.style.height = `${newHeight}px`;
    }

    updateAllBoxSizes() {
        // Recalculate and update the size of all boxes
        this.boxes.forEach(box => {
            // Force box to recalculate its size with current text scale
            box.renderMarkdown();
        });
        
        // Update all connections after box sizes change
        this.connections.forEach(connection => {
            connection.update();
        });
        
        // Update canvas size to accommodate new box sizes
        this.updateCanvasSize();
    }
    
    initTheme() {
        // Check for saved theme preference
        const darkMode = localStorage.getItem('darkMode') === 'true';
        if (darkMode) {
            document.body.classList.add('dark-mode');
        }
    }
    
    setupEventListeners() { 
        this.canvas.addEventListener('dblclick', this.handleCanvasDoubleClick.bind(this)); 
        this.canvas.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this)); 
        
        // Use separate event handlers for better scroll position management
        document.addEventListener('mousemove', (e) => {
            // Handle box dragging
            if (this.draggingBox) { 
                const dx = e.clientX - this.dragStartPos.x; 
                const dy = e.clientY - this.dragStartPos.y; 
                const nCx = this.dragBoxStartCenter.cx + dx; 
                const nCy = this.dragBoxStartCenter.cy + dy; 
                this.draggingBox.setCenterPosition(nCx, nCy); 
                this.updateConnectionsForBox(this.draggingBox); 
            } 
            // Handle connection preview drawing
            else if (this.connectionStartBox) { 
                const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
                
                // Get scroll position for accurate coordinates
                const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                
                // Get mouse position relative to canvas with scroll offsets
                const r = this.svg.getBoundingClientRect(); 
                const mX = e.clientX - r.left + scrollX; 
                const mY = e.clientY - r.top + scrollY; 
                
                this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
            }
        }); 
        
        document.addEventListener('mouseup', (e) => {
            if (this.draggingBox) { 
                this.draggingBox = null; 
                this.saveCurrentProject();
                this.updateCanvasSize(); // Update canvas size after drag
            } else if (this.connectionStartBox && e.button === 2) { 
                e.preventDefault(); 
                this.previewPath.setAttribute('display', 'none'); 
                
                // Get correct element at mouse position
                let eTE = document.elementFromPoint(e.clientX, e.clientY); 
                let eBE = eTE?.closest('.box-default'); 
                
                if (eBE) { 
                    const eB = this.boxes.get(eBE.dataset.id); 
                    if (eB && eB !== this.connectionStartBox) { 
                        // Create or update connection between boxes
                        const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                        if (connection) {
                            this.saveCurrentProject();
                        }
                    } else if (eB === this.connectionStartBox) {
                        // Change width if right-click and release on the same box
                        eB.toggleWidthType();
                        this.saveCurrentProject();
                    }
                } 
                
                this.connectionStartBox = null; 
                this.rightClickBox = null;
            } 
            
            if (e.button === 0) { 
                this.draggingBox = null; 
            } 
        });

        document.addEventListener('keydown', this.handleKeyDown.bind(this)); 
        document.addEventListener('click', this.handleGlobalClick.bind(this), true); 
        document.addEventListener('contextmenu', e => e.preventDefault()); 

        // Handle mouse leaving the window
        document.addEventListener('mouseleave', () => { 
            if (this.connectionStartBox) { 
                this.previewPath.setAttribute('display', 'none'); 
                this.connectionStartBox = null; 
            } 
        }); 

        // Add scroll event handling to ensure connections update during scrolling
        window.addEventListener('scroll', () => {
            // Update all connections when scrolling to ensure they remain accurate
            this.connections.forEach(connection => {
                connection.update();
            });
        });
    }

    setupThemeToggle() {
        const toggleBtn = document.getElementById('theme-toggle');
        
        toggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            
            // Store theme preference in localStorage
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
            
            // Update all box and connection themes
            this.updateAllThemes();
        });
    }

    // Update themes for all boxes and connections when theme mode changes
    updateAllThemes() {
        // Update boxes
        this.boxes.forEach(box => {
            box.applyColorTheme();
        });
        
        // Update connections
        this.connections.forEach(conn => {
            conn.applyTheme();
        });
    }

    handleCanvasDoubleClick(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            const rect = this.boxContainer.getBoundingClientRect(); 
            const cx = e.clientX - rect.left; 
            const cy = e.clientY - rect.top; 
            if (cx >= 0 && cy >= 0 && cx <= rect.width && cy <= rect.height) { 
                this.createBox(cx, cy); 
            } 
        } 
    }

    handleCanvasMouseDown(e) { 
        if (e.target === this.canvas || e.target === this.boxContainer) { 
            // No-op for now - we don't have selection state anymore
        } 
    }

    startDragging(box, e) {
        if (!box || box.isEditing) return;
        
        this.draggingBox = box;
        this.dragStartPos = { x: e.clientX, y: e.clientY };
        this.dragBoxStartCenter = { cx: box.data.cx, cy: box.data.cy };
    }

    handleBoxRightMouseDown(e, box) {
        if (!box || box.isEditing) return;
        
        e.preventDefault();
        
        // Right-click for starting connection
        this.connectionStartBox = box;
        const sC = { cx: box.data.cx, cy: box.data.cy };
        const r = this.svg.getBoundingClientRect();
        const mX = e.clientX - r.left;
        const mY = e.clientY - r.top;
        this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`);
        this.previewPath.setAttribute('display', 'block');
        
        // Also toggle width if mouse up on the same box
        this.rightClickBox = box;
    }

    handleMouseMove(e) { 
        if (this.draggingBox) { 
            const dx = e.clientX - this.dragStartPos.x; 
            const dy = e.clientY - this.dragStartPos.y; 
            const nCx = this.dragBoxStartCenter.cx + dx; 
            const nCy = this.dragBoxStartCenter.cy + dy; 
            this.draggingBox.setCenterPosition(nCx, nCy); 
            this.updateConnectionsForBox(this.draggingBox); 
        } else if (this.connectionStartBox) { 
            const sC = { cx: this.connectionStartBox.data.cx, cy: this.connectionStartBox.data.cy }; 
            
            // Calculate the correct mouse position with scroll offsets
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            const r = this.svg.getBoundingClientRect(); 
            const mX = e.clientX - r.left + scrollX; 
            const mY = e.clientY - r.top + scrollY; 
            
            this.previewPath.setAttribute('d', `M ${sC.cx} ${sC.cy} L ${mX} ${mY}`); 
        } 
    }

    handleMouseUp(e) { 
        if (this.draggingBox) { 
            this.draggingBox = null; 
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after drag
        } else if (this.connectionStartBox && e.button === 2) { 
            e.preventDefault(); 
            this.previewPath.setAttribute('display', 'none'); 
            let eTE = document.elementFromPoint(e.clientX, e.clientY); 
            let eBE = eTE?.closest('.box-default'); 
            
            if (eBE) { 
                const eB = this.boxes.get(eBE.dataset.id); 
                if (eB && eB !== this.connectionStartBox) { 
                    // Create or update connection between boxes
                    const connection = this.createOrUpdateConnection(this.connectionStartBox, eB);
                    if (connection) {
                        this.saveCurrentProject();
                    }
                } else if (eB === this.connectionStartBox) {
                    // Change width if right-click and release on the same box
                    eB.toggleWidthType();
                    this.saveCurrentProject();
                }
            } 
            
            this.connectionStartBox = null; 
            this.rightClickBox = null;
        }
        
        if (e.button === 0) { 
            this.draggingBox = null; 
        } 
    }

    handleGlobalClick(e) { 
        const targetTextarea = e.target.closest('textarea'); 
        
        if (!targetTextarea) { 
            // Check if any box is in edit mode
            let editingBox = false;
            this.boxes.forEach(box => { 
                if (box.isEditing) { 
                    editingBox = true; 
                    box.commitEdit(); 
                } 
            }); 
        } 
    }

    handleKeyDown(e) { 
        if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return; 
        
        // Handle Delete/Backspace for removing hovered element
        if ((e.key === 'Delete' || e.key === 'Backspace') && this.hoveredElement) {
            // Delete the hovered element
            if (this.hoveredElement instanceof Box) {
                this.deleteBox(this.hoveredElement);
            } else if (this.hoveredElement instanceof Connection) {
                this.deleteConnection(this.hoveredElement);
            }
            this.saveCurrentProject();
            this.updateCanvasSize(); // Update canvas size after deletion
        }
        
        // Handle 'c' key for changing color of hovered element
        if (e.key === 'c' && this.hoveredElement) {
            if (this.hoveredElement instanceof Box || this.hoveredElement instanceof Connection) {
                this.hoveredElement.cycleColorTheme();
                this.saveCurrentProject();
            }
        }
        
        // Handle 's' key for changing width of hovered box (NOT connections)
        if (e.key === 's' && this.hoveredElement instanceof Box) {
            this.hoveredElement.toggleWidthType();
            this.saveCurrentProject();
        }
    }

    createBox(cx, cy) { 
        const id = `box-${this.nextBoxId++}`; 
        const bD = { 
            id: id, 
            cx: cx, 
            cy: cy, 
            width: INITIAL_BOX_WIDTH, 
            height: INITIAL_BOX_HEIGHT, 
            widthType: WIDTH_TYPES.MEDIUM,
            themeKey: 'default',
            markdown: '# Title\nUse **markdown** for formatting'
        }; 
        const b = new Box(bD, this); 
        this.boxContainer.appendChild(b.element); 
        this.boxes.set(id, b); 
        this.updateHelperText(); 
        b.startEditing(); 
        this.updateCanvasSize(); // Update canvas size after adding a box
        return b; 
    }

    //// Create a new connection or update existing one to be bidirectional
    createOrUpdateConnection(startBox, endBox) { 
        if (!startBox || !endBox || startBox === endBox) return null; 
        
        // Check if there's already a connection in the opposite direction
        let existingConnection = null;
        this.connections.forEach(conn => {
            if (conn.startBox === endBox && conn.endBox === startBox) {
                existingConnection = conn;
            }
        });
        
        // If there's an existing connection, make it bidirectional
        if (existingConnection) {
            existingConnection.data.bidirectional = true;
            existingConnection.element.setAttribute('marker-start', 'url(#arrowhead-start)');
            // No longer changing the style when making bidirectional
            existingConnection.update();
            return existingConnection;
        }
        
        // Otherwise create a new connection
        const id = `conn-${this.nextConnectionId++}`; 
        const cD = { 
            id: id, 
            startBoxId: startBox.data.id, 
            endBoxId: endBox.data.id,
            themeKey: 'default',
            pattern: CONNECTION_PATTERNS.NORMAL,
            thickness: CONNECTION_THICKNESSES.NORMAL,
            bidirectional: false
        }; 
        
        // Create the connection instance
        const conn = new Connection(cD, startBox, endBox, this); 
        this.connections.set(id, conn); 
        
        // Add the connection group to SVG
        // All elements are now inside the group
        this.svg.appendChild(conn.group);
        
        // Apply theme and styles
        conn.applyTheme();
        conn.applyPattern();
        conn.applyThickness();
        
        return conn; 
    }

    deleteBox(boxInstance) { 
        if (!boxInstance) return; 
        const bId = boxInstance.data.id; 
        const cTR = []; 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) cTR.push(c); 
        }); 
        cTR.forEach(c => this.deleteConnection(c)); 
        boxInstance.element.remove(); 
        this.boxes.delete(bId); 
        this.updateHelperText(); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === boxInstance) {
            this.hoveredElement = null;
        }
        
        // Update canvas size after deletion
        this.updateCanvasSize();
    }

    deleteConnection(connInstance) { 
        if (!connInstance) return; 
        
        // Clean up all connection elements
        connInstance.cleanup();
        
        const cId = connInstance.data.id; 
        this.connections.delete(cId); 
        
        // Clear hovered element if needed
        if (this.hoveredElement === connInstance) {
            this.hoveredElement = null;
        }
    }

    updateConnectionsForBox(boxInstance) { 
        this.connections.forEach(c => { 
            if (c.startBox === boxInstance || c.endBox === boxInstance) c.update(); 
        }); 
    }

    updateHelperText() { 
        this.helperText.style.display = this.boxes.size === 0 ? 'block' : 'none'; 
    }

    // Clear the current diagram
    clearDiagram() {
        // Remove all connections
        this.connections.forEach(conn => {
            conn.cleanup();
        });
        this.connections.clear();
        
        // Remove all boxes
        this.boxes.forEach(box => {
            box.element.remove();
        });
        this.boxes.clear();
        
        // Reset counters
        this.nextBoxId = 1;
        this.nextConnectionId = 1;
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Export the entire diagram data
    exportData() {
        const boxesData = [];
        this.boxes.forEach(box => {
            boxesData.push(box.exportData());
        });
        
        const connectionsData = [];
        this.connections.forEach(conn => {
            connectionsData.push(conn.exportData());
        });
        
        return {
            boxes: boxesData,
            connections: connectionsData,
            nextBoxId: this.nextBoxId,
            nextConnectionId: this.nextConnectionId
        };
    }

    // Load diagram from exported data
    loadFromProjectData(data) {
        // Clear current diagram
        this.clearDiagram();
        
        // Set counters
        this.nextBoxId = data.nextBoxId || 1;
        this.nextConnectionId = data.nextConnectionId || 1;
        
        // Create boxes first
        const boxMap = new Map(); // Map original IDs to new box instances
        
        if (data.boxes && Array.isArray(data.boxes)) {
            data.boxes.forEach(boxData => {
                const box = new Box(boxData, this);
                this.boxContainer.appendChild(box.element);
                this.boxes.set(boxData.id, box);
                boxMap.set(boxData.id, box);
            });
        }
        
        // Then create connections
        if (data.connections && Array.isArray(data.connections)) {
            data.connections.forEach(connData => {
                const startBox = boxMap.get(connData.startBoxId);
                const endBox = boxMap.get(connData.endBoxId);
                
                if (startBox && endBox) {
                    const conn = new Connection(connData, startBox, endBox, this);
                    this.connections.set(connData.id, conn);
                    
                    // Add the connection group to SVG
                    // All elements are now inside the group
                    this.svg.appendChild(conn.group);
                    
                    // Update connection after adding to DOM
                    conn.update();
                }
            });
        }
        
        // Update helper text
        this.updateHelperText();
        
        // Update canvas size
        this.updateCanvasSize();
    }

    // Save the current project through the project manager
    saveCurrentProject() {
        if (this.projectManager) {
            this.projectManager.saveCurrentProject();
        }
    }
}

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    // Configure marked.js for better rendering
    if (window.marked) {
        marked.setOptions({
            gfm: true,       // GitHub flavored markdown
            breaks: true,    // Add <br> on single line breaks
            headerIds: false,
            mangle: false    // Don't escape HTML
        });
    }
    
    window.diagramManager = new DiagramManager();
    
    // Add example content to the first box if needed
    setTimeout(() => {
        if (window.diagramManager.boxes.size === 0) {
            const exampleBox = window.diagramManager.createBox(window.innerWidth / 2, window.innerHeight * 0.3);
            exampleBox.data.markdown = `# Welcome to FlowChart

This is an enhanced diagram tool with **improved markdown** support.

## Features:
* Ordered and unordered lists
* Tables support
* Adjustable text size

1. Double-click anywhere to add boxes
2. Right-drag to connect boxes
3. Press 'c' to change colors
4. Press 's' to change sizes

### Example Table:
| Feature | Description |
|---------|-------------|
| Lists | Both ordered and unordered |
| Tables | Markdown table support |
| Text Size | Adjustable text scaling |`;
            exampleBox.commitEdit();
        }
    }, 100);
});
</script>

</body>
</html>
